# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Bard 0.8 is a compiler and virtual machine for a Scheme-like language, derived from Peter Norvig's Scheme implementation in "Paradigms of AI Programming" (PAIP). The project is written in Common Lisp.

## Build and Run

### Loading the System
```lisp
(asdf:load-system :bard)
```

### Running the REPL
```lisp
(bard:bard)
```
This starts the Bard read-eval-print loop.

### Testing Code
Run the test file:
```lisp
(load "test.bard")
```

## Architecture

### Compilation Pipeline

1. **Reader** (compile.lisp): Reads Bard syntax using a custom readtable (*bard-readtable*) that supports #t/#f for booleans, quasiquote/unquote, and complex number notation
2. **Macro Expansion** (macro.lisp, bard-macros.lisp): Expands Bard macros (let, and, or, cond, case, define, delay, letrec)
3. **Compiler** (compile.lisp): Compiles Bard expressions to bytecode instructions
4. **Optimizer** (optimize.lisp, optimizers.lisp): Performs peephole optimization on generated bytecode
5. **Assembler** (compile.lisp): Converts instruction lists with labels into executable bytecode vectors
6. **VM** (machine.lisp): Executes compiled bytecode

### Key Components

**fn.lisp**: Defines the `fn` structure representing compiled functions with code, environment, name, and argument list.

**prim.lisp**: Defines the `prim` structure for primitive operations (like +, -, cons, car, etc.) that map to VM instructions.

**env.lisp**: Environment management for variable binding. Environments are represented as lists of frames.

**compile.lisp**:
- Main compiler entry point: `compiler` function
- Instruction generation: `gen`, `seq`, `gen-label`, `gen-var`
- Expression compilation: `comp` function dispatches on expression type
- Special forms: QUOTE, BEGIN, SET!, IF, FN
- Function application compilation with primitive optimization
- Two-pass assembler that resolves labels to addresses

**machine.lisp**:
- VM class with slots: code, pc (program counter), env, stack, n-args, instr
- `runvm` method: main interpreter loop that executes bytecode
- Stack-based execution model with closures

**optimize.lisp**: Peephole optimizer framework that applies optimization rules defined in optimizers.lisp.

### Bytecode Instructions

Variable/stack: LVAR, LSET, GVAR, GSET, POP, CONST
Branching: JUMP, FJUMP, TJUMP
Functions: SAVE, RETURN, CALLJ, ARGS, ARGS., FN, PRIM
Continuations: SET-CC, CC
Operations: Arithmetic (+, -, *, /), comparison (<, >, <=, >=, =, /=), list operations (CAR, CDR, CONS, LIST1-3), I/O (READ, WRITE, DISPLAY, NEWLINE)
Other: HALT

### Compilation Flags

The `comp` function takes two boolean flags:
- `val?`: Whether the value of the expression is needed
- `more?`: Whether there are more expressions to evaluate (affects RETURN generation)

These flags enable tail-call optimization and efficient code generation.

### Macro System

Bard macros are defined with `def-bard-macro` and stored in the symbol's `bard-macro` property. The compiler checks for and expands macros before compilation. Key macros in bard-macros.lisp implement common control structures (let, and, or, cond, case, define).