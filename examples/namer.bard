;;; bard implementation of mikel's namer

;;; (load "namer.bard")
;;; (read-names "us.names")

(define variable $name-starts nothing)
(define variable $name-parts nothing)

(define method (triples (x <string>))
  (take-by 3 1 x))

(define method (long-enough? (s <string>))
  (> (length s) 1))

(define method (read-names path)
    (let ((lines (with-open-file (in path)(read-lines in)))
          (triples-list (map triples lines)))
      (set! $name-starts (filter long-enough? (map first triples-list)))
      (set! $name-parts (reduce append []
                                (map (partial filter long-enough?)
                                     (map rest triples-list))))
      path))

(define method (choose-name-start)(any $name-starts))

(define method (choose-name-next part)
  (let ((part1 (next-last part))
        (part2 (last part))
        (first-picks (filter (^ (p)(= part1 (first p))) $name-parts ))
        (second-picks (if (something? first-picks)
                          (filter (^ (p)(= part2 (second p))) first-picks)
                          nothing)))
    (if (something? second-picks)
        (any second-picks)
        nothing)))

(define variable *max-name-length* 16)

(define method (merge-name-segment name segment)
  (append name (drop 2 segment)))

(define method (build-name)
  (loop gen ((name (choose-name-start)))
        (let ((count (length name)))
          (if (> count *max-name-length*)
              name
              (let ((seg (choose-name-next name)))
                (if (and (something? seg))
                    (if (> (length seg) 2)
                        (gen (merge-name-segment name seg))
                        (merge-name-segment name seg))
                    name))))))

(define method (build-names n)
  (loop build ((names [])
               (i 0))
        (if (< i n)
            (build (add-first (build-name) names) 
                   (+ i 1))
            names)))


