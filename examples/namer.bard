;;; bard implementation of mikel's namer
;;; TODO: try a prefix-tree version
;;;       might want to add <hash-table> or <wb-tree-table> to support it

(def $name-starts nothing)
(def $name-parts nothing)
(def $name-parts-count 0)
(def *max-name-length* 16)
(def $max-tries 100)

(define method (triples x) with: ((x <string>)) (take-by 3 1 x))
(define method (long-enough? s) with: ((s <string>)) (> (length s) 1))
(define method (choose-name-start)(any $name-starts))

(define method (read-names path)
    (let ((lines (with-open-file (in path)(read-lines in)))
          (triples-list (map triples lines)))
      (set! $name-starts (filter long-enough? (map first triples-list)))
      (set! $name-parts (reduce append [] (map (partial filter long-enough?)
                                               (map rest triples-list))))
      (set! $name-parts-count (length $name-parts))
      path))

(define method (choose-name-next part)
  (let ((part1 (next-last part))
        (part2 (last part)))
    (some? (^ (p) (and (= part1 (first p))
                       (= part2 (second p))))
           (drop (random (- $name-parts-count 1))
                 $name-parts))))

(define method (merge-name-segment name segment)
  (append name (drop 2 segment)))

(define method (build-name)
  (loop gen ((name (choose-name-start))
             (try-count 0))
        (if (< try-count $max-tries)
            (let ((count (length name)))
              (if (> count *max-name-length*)
                  name
                  (let ((seg (choose-name-next name)))
                    (if (something? seg)
                        (if (> (length seg) 2)
                            (gen (merge-name-segment name seg)
                                 (+ try-count 1))
                            (merge-name-segment name seg))
                        (gen name (+ try-count 1))))))
            name)))

(define method (build-names)
  (generate ((nms []))
    (let ((nm (build-name)))
      (yield nm)
      (resume (add-first nm nms)))))

(define method (names path n)
  (read-names path)
  (let ((nms (build-names)))
    (take n nms)))
