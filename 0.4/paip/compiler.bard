;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compiler.bard
;;;; Project:       Bard
;;;; Purpose:       Bard compiler in Bard, based on Norvig's PAIP Scheme compiler
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; ----------------------------------------------------------------------
;;; general utilities
;;; ----------------------------------------------------------------------

(define method (third x)
  (element x 2))

(define method (fourth x)
  (element x 3))

(define method (every? pred items) 
  (if (empty? items)
      true
      (if (pred (first items))
          (every? pred (rest items))
          false)))

;;; ----------------------------------------------------------------------
;;; data constructors
;;; ----------------------------------------------------------------------

(define record <bard-method> environment parameters body)

;;; ----------------------------------------------------------------------
;;; environments
;;; ----------------------------------------------------------------------

(define method (find-var varname env)
  with: ((env <null>))
  nothing)

(define method (find-var varname env)
  with: ((env <pair>))
  (let ((binding (first env)))
    (if (= varname (left binding))
        binding
        (find-var varname (rest env)))))

;;; ----------------------------------------------------------------------
;;; code generators
;;; ----------------------------------------------------------------------
;;; the compiler represents environments as Bard <pair>s

(define variable *label-index* 0)

(define method (gen-label)
  (let ((num (as <string> *label-index*))
        (lbl (as <symbol> (append "L" num))))
    (set! *label-index* (+ *label-index* 1))
    lbl))

(define method (gen opname & args)
  `(,opname ,@args))

(define method (gen-var varname env)
  (let ((binding (find-var varname env)))
    (if (something? binding)
        (gen 'LREF varname)
        (gen 'GREF varname))))

(define method (gen-set place env)
  (gen 'NOT-YET-IMPLEMENTED 'setter))

;;; ----------------------------------------------------------------------
;;; expression compilers
;;; ----------------------------------------------------------------------

(define method (compile-begin exps env)
  (if (empty? exps)
      [(gen 'CONST nothing)]
      (if (= 1 (length exps))
          (compile (first exps) env)
          (append (compile (first exps) env)
                  (pair (gen 'POP)
                        (compile-begin (rest exps) env))))))

(define method (compile-if test-expr then-expr else-expr env)
  (let ((l1 (gen-label))
        (l2 (gen-label)))
    `(,@(compile test-expr env)
      ,(gen 'FJUMP l1)
      ,@(compile then-expr env)
      ,(gen 'TJUMP l2)
      (,l1) 
      ,@(compile else-expr env)
      (,l2))))

(define method (compile-method paramlist body env)
  (if (every? symbol? paramlist)
      (let ((code (compile-begin body env)))
        (make <bard-method> 
              environment: env
              parameters: paramlist
              body: `(,(gen 'ARGS (length paramlist))
                      ,@code
                      ,(gen 'RETURN))))
      (else (error (append "Invalid parameter list: " (as <string> paramlist))))))

;;; ----------------------------------------------------------------------
;;; special-form compilers
;;; ----------------------------------------------------------------------

(define variable *special-form-compilers* {})

(define method (defspecial name compfn)
  (set! *special-form-compilers*
        (merge *special-form-compilers*
               {name compfn})))

(define method (special-form? x)
  (let ((op (first x)))
    (something? (get *special-form-compilers* op))))

(define method (compile-special-form x env)
  (let ((op (first x))
        (comp (get *special-form-compilers* op)))
    (comp x env)))

(defspecial 'begin (^ (exp env) (compile-begin (rest exp) env)))

(defspecial 'if (^ (exp env) (compile-if (second exp) (third exp) (fourth exp) env)))

(defspecial 'method (^ (exp env) [(gen 'CONST (compile-method (second exp) (drop 2 exp) env))]))

(defspecial 'quote
  (^ (exp env)
     (let ((len (length exp)))
       (cond
        ((= len 2)[(gen 'CONST (second exp))])
        ((< len 2)(error ["missing argument in quote expression: " exp]))
        (else: (error ["too many arguments in quote expression: " exp]))))))

(defspecial 'set!
  (^ (exp env)
     `(,@(compile (third exp) env)
       ,(gen-set (second exp) env))))

;;; ----------------------------------------------------------------------
;;; macro expanders
;;; ----------------------------------------------------------------------

(define variable *macro-expanders* {})

(define method (defmacro name expander)
  (set! *macro-expanders*
        (merge *macro-expanders*
               {name expander})))

(define method (macro-form? x)
  (let ((op (first x)))
    (something? (get *macro-expanders* op))))

(define method (macroexpand x)
  (let ((op (first x))
        (comp (get *special-form-compilers* op)))
    (comp x env)))

;;; ----------------------------------------------------------------------
;;; the compiler driver
;;; ----------------------------------------------------------------------

(define method (compile x env)
  [(gen 'CONST x)])

(define method (compile x env)
  with: ((x <symbol>))
  [(gen-var x env)])

(define method (compile x env)
  with: ((x <pair>))
  (cond
   ((special-form? x) (compile-special-form x env))
   ((macro-form? x) (compile (macroexpand x) env))
   (else: (let ((args (reduce append
                              (map (^ (e)(compile e env))
                                   (rest x))))
                (proc (compile (first x) env))
                (argcount (length (rest x))))
            `(,@args
              ,@proc
              ,(gen 'CALLJ argcount))))))




