;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compiler.bard
;;;; Project:       Bard
;;;; Purpose:       Bard compiler in Bard, based on Norvig's PAIP Scheme compiler
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; ----------------------------------------------------------------------
;;; general utilities
;;; ----------------------------------------------------------------------

(define method (third x)
  (element x 2))

(define method (fourth x)
  (element x 3))

(define method (every? pred items) 
  (if (empty? items)
      true
      (if (pred (first items))
          (every? pred (rest items))
          false)))

;;; ----------------------------------------------------------------------
;;; data constructors
;;; ----------------------------------------------------------------------

;;; ----------------------------------------------------------------------
;;; environments
;;; ----------------------------------------------------------------------

(define method (find-var varname env)
  with: ((env <null>))
  nothing)

(define method (find-var varname env)
  with: ((env <pair>))
  (let ((binding (first env)))
    (if (= varname (left binding))
        binding
        (find-var varname (rest env)))))

;;; ----------------------------------------------------------------------
;;; code generators
;;; ----------------------------------------------------------------------
;;; the compiler represents environments as Bard <pair>s

(define variable *label-index* 0)

(define method (gen-label)
  (let ((num (as <string> *label-index*))
        (lbl (as <symbol> (append "L" num))))
    (set! *label-index* (+ *label-index* 1))
    lbl))

(define method (gen opname & args)
  `(,opname ,@args))

(define method (gen-var varname env)
  (let ((binding (find-var varname env)))
    (if (something? binding)
        (gen 'LREF varname)
        (gen 'GREF varname))))

;;; place is a variable name (a symbol)
(define method (gen-set place env)
  with: ((place <symbol>))
  (let ((binding (find-var place env)))
    (if (something? binding)
        (gen 'LSET place)
        (gen 'GSET place))))

;;; place is a list of the form (getter object)
;;; for example: (first x)
;;; getter is an accessor. check the structure definition
;;; for thing's representation to see if a setter is defined
;;; for that accessor
(define method (gen-set place env)
  with: ((place <pair>))
  (if (= 2 (length place))
      (gen 'NOT-YET-IMPLEMENTED 'structure-setter)
      (error (append "Invalid place argument to set!: " (as <string> place)))))

;;; ----------------------------------------------------------------------
;;; expression compilers
;;; ----------------------------------------------------------------------

(define method (compile-begin exps env)
  (if (empty? exps)
      [(gen 'CONST nothing)]
      (if (= 1 (length exps))
          (compile (first exps) env)
          (append (compile (first exps) env)
                  (pair (gen 'POP)
                        (compile-begin (rest exps) env))))))


(define method (compile-cond clauses env end-label)
  with: ((clauses <null>))
  [[end-label]])

(define method (compile-cond clauses env end-label)
  with: ((clauses <pair>))
  (let ((clause (first clauses))
        (more (compile-cond (rest clauses) env end-label))
        (test (first clause))
        (body (rest clause)))
    (let ((l1 (gen-label)))
      `(,@(compile test env)
        ,(gen 'FJUMP l1)
        ,@(compile-begin body env)
        ,(gen 'JUMP end-label)
        (,l1)
        ,@more))))

(define method (parse-function-expression expr)
  (let ((arrow-pos (position-if (^ (e)(= e '->)) expr))
        (informs (take arrow-pos expr))
        (outforms (drop (+ arrow-pos 1) expr)))
    (values informs outforms)))

(define method (compile-function expr env)
  (let ((input-forms output-forms (parse-function-expression expr))
        (input-types (if (something? input-forms)
                         (reduce append
                                 (map (^ (f)(compile f env))
                                      input-forms))
                         nothing))
        (input-code `(,@input-types
                      (CONST ,(length input-forms))
                      (PRIM list)))
        (output-types (if (something? output-forms)
                          (reduce append
                                  (map (^ (f)(compile f env))
                                       output-forms))
                          nothing))
        (output-code `(,@output-types
                       (CONST ,(length output-forms))
                       (PRIM list))))
    `(,@input-code
      ,@output-code
      (FUNCTION))))

(define method (compile-if test-expr then-expr else-expr env)
  (let ((l1 (gen-label))
        (l2 (gen-label)))
    `(,@(compile test-expr env)
      ,(gen 'FJUMP l1)
      ,@(compile then-expr env)
      ,(gen 'TJUMP l2)
      (,l1) 
      ,@(compile else-expr env)
      (,l2))))

(define method (compile-method paramlist body env)
  (if (every? symbol? paramlist)
      (let ((menv (append (map (^ (p) [p])
                               paramlist)
                          env))
            (code (compile-begin body menv)))
        (list (gen 'CONST code) ; compiled method body
              (gen 'CONST paramlist) ; formal parameters
              (gen 'CONST env) ; closure environment
              '(METHOD) ; instruction to construct a method and push it
              ))
      (error (append "Invalid parameter list: " (as <string> paramlist)))))

;;; ----------------------------------------------------------------------
;;; special-form compilers
;;; ----------------------------------------------------------------------

(define variable *special-form-compilers* {})

(define method (defspecial name compfn)
  (set! *special-form-compilers*
        (merge *special-form-compilers*
               {name compfn})))

(define method (special-form? x)
  (let ((op (first x)))
    (something? (get *special-form-compilers* op))))

(define method (compile-special-form x env)
  (let ((op (first x))
        (comp (get *special-form-compilers* op)))
    (comp x env)))

;;; special forms
;;; ----------------------------------------------------------------------

(defspecial 'begin
  (^ (exp env) (compile-begin (rest exp) env)))

(defspecial 'cond
  (^ (exp env) 
     (let ((end-label (gen-label)))
       (compile-cond (rest exp) env end-label))))

(defspecial 'if
  (^ (exp env) (compile-if (second exp) (third exp) (fourth exp) env)))

(defspecial '->
  (^ (exp env) (compile-function (rest exp) env)))

(defspecial 'function
  (^ (exp env) (compile-function (rest exp) env)))

(defspecial '^
  (^ (exp env) (compile-method (second exp) (drop 2 exp) env)))

(defspecial 'method
  (^ (exp env) (compile-method (second exp) (drop 2 exp) env)))

(defspecial 'quote
  (^ (exp env)
     (let ((len (length exp)))
       (cond
        ((= len 2)[(gen 'CONST (second exp))])
        ((< len 2)(error ["missing argument in quote expression: " exp]))
        (else: (error ["too many arguments in quote expression: " exp]))))))

(defspecial 'set!
  (^ (exp env)
     `(,@(compile (third exp) env)
       ,(gen-set (second exp) env))))

;;; ----------------------------------------------------------------------
;;; macro expanders
;;; ----------------------------------------------------------------------

(define variable *macro-expanders* {})

(define method (defmacro name expander)
  (set! *macro-expanders*
        (merge *macro-expanders*
               {name expander})))

(define method (macro-form? x)
  (let ((op (first x)))
    (something? (get *macro-expanders* op))))

(define method (macroexpand x)
  (let ((op (first x))
        (comp (get *special-form-compilers* op)))
    (comp x env)))

;;; ----------------------------------------------------------------------
;;; primitives
;;; ----------------------------------------------------------------------

(define variable *primitives* {})

(define method (defprim name required-count rest?)
  (set! *primitives*
        (merge *primitives*
               {name {required-count: required-count
                      rest: rest?}})))

(define method (primitive? x)
  (let ((op (first x)))
    (something? (get *primitives* op))))

(define method (compile-primitive-call x env)
  (let ((arg-forms (rest x))
        (args (if (something? arg-forms)
                  (reduce append
                          (map (^ (e)(compile e env))
                               arg-forms))
                  [])))
    `(,@args
      ,(gen 'PRIM (first x)))))


;;; primitives
;;; ----------------------------------------------------------------------

;;; ----------------------------------------------------------------------
;;; the compiler driver
;;; ----------------------------------------------------------------------

(define method (compile x env)
  [(gen 'CONST x)])

(define method (compile x env)
  with: ((x <symbol>))
  [(gen-var x env)])

(define method (compile x env)
  with: ((x <pair>))
  (cond
   ((special-form? x) (compile-special-form x env))
   ((macro-form? x) (compile (macroexpand x) env))
   ((primitive? x) (compile-primitive-call x env))
   (else: (let ((args (reduce append
                              (map (^ (e)(compile e env))
                                   (rest x))))
                (proc (compile (first x) env))
                (argcount (length (rest x))))
            `(,@args
              ,@proc
              ,(gen 'CALL argcount))))))




