;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compile.bard
;;;; Project:       Bard
;;;; Purpose:       Compiler: bard -> octavo
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; ---------------------------------------------------------------------
;;; ABOUT
;;; ---------------------------------------------------------------------
;;; we compile to an intermediate form called octavo, which consists of
;;; a simple s-expression-based language designed to be easy to
;;; manipulate and easy to compile to various target languages

;;; ---------------------------------------------------------------------
;;; environments
;;; ---------------------------------------------------------------------

(def $globals {})

(define record <var> val name mutable)

(define method (env-frame & vars) vars)

(define method (null-env) [])

(define method (push-frame fr env)(add-first fr env))

(define method (pop-frame env)
  (values (first env)
          (rest env)))

(define method (in-frame varname frame)
  (position-if (^ (var)(= varname (get var 'name)))
               frame))

(define method (in-env varname env)
  (let ((j nothing)
        (i (position-if (^ (frame)
                           (let ((pos (in-frame varname frame)))
                             (if pos (begin
                                      (set! j pos)
                                      true)
                                 false)))
                        env)))
    (values i j)))

(define method (make-tmp-env env params)
  (let ((vars (map (^ (p)(make <var> name: p val: nothing mutable: false))
                   params)))
    (push-frame (apply env-frame vars)
                env)))

;;; ---------------------------------------------------------------------
;;; special forms
;;; ---------------------------------------------------------------------

(define variable $bard-special-forms {})

(define method (special-form? expr)
  (and (something? (get $bard-special-forms (first expr)))
       true))

(define method (defspecial opname comp-fn)
  (set! $bard-special-forms
        (put-key $bard-special-forms opname comp-fn)))

(define method (compile-special-form expr env)
  (let ((compiler (get $bard-special-forms (first expr))))
    (compiler expr env)))

(defspecial '^ 
  (^ (expr env) 
     (let ((params (element expr 1))
           ;; make a temporary env with the lambda params so we can
           ;; compile the lambda body in an environment where the
           ;; lambda params are lexical variables
           (tmp-env (make-tmp-env env params))
           (body (compile `(begin ,@(drop 2 expr)) tmp-env)))
       `(LAMBDA ,params ,body))))

(defspecial 'begin 
  (^ (expr env) 
     `(BEGIN ,@(map (^ (e)(compile e env)) 
                    (rest expr)))))

(defspecial 'case (^ (expr env) ))

(defspecial 'cond (^ (expr env) ))

(defspecial 'def
  (^ (expr env) 
     `(DEF ,(element expr 1) ,(compile (element expr 2) env))))

(defspecial 'define (^ (expr env) ))

(defspecial 'ensure (^ (expr env) ))

(defspecial 'generate (^ (expr env) ))

(defspecial 'if
  (^ (expr env) 
     (let ((testexp (element expr 1))
           (thenexp (element expr 2))
           (elseexp (let ((alt (drop 3 expr)))
                      (if (empty? alt)
                          nothing
                          (if (empty? (rest alt))
                              (first alt)
                              (error ["malformed if expression: " expr]))))))
       `(IF ,(compile testexp env)
            ,(compile thenexp env)
            ,(compile elseexp env)))))

(defspecial 'let (^ (expr env) ))

(defspecial 'loop (^ (expr env) ))

(defspecial 'match (^ (expr env) ))

(defspecial 'quasiquote (^ (expr env) ))

(defspecial 'quote
  (^ (expr env) 
     (let ((len (length expr)))
       (if (= 2 len)
           `(QUOTE ,(second expr))
           (error ["malformed quotation: " expr])))))

(defspecial 'repeat
  (^ (expr env) 
     `(REPEAT ,(compile (list 'begin (second expr)) env))))

(defspecial 'setter
  (^ (expr env) 
     (let ((place (second expr)))
       (if (symbol? place) 
           (let ((i j (in-env place env)))
             (if (something? i)
                 `(LSETR ,i ,j)
                 `(GSETR ,place)))
           (if (list? place)
               (if (= 2 (length place))
                   (let ((obj-ref (first place))
                         (key (second place)))
                     `(FGETR ,(compile obj-ref env) ,key))
                   (error ["malformed setter expression: " expr]))
               (error ["malformed setter expression: " expr]))))))

(defspecial 'set!
  (^ (expr env)
     (compile (add-first (add-first 'setter (take 1 (drop 1 expr)))
                         (drop 2 expr))
              env)))

(defspecial 'undefine
  (^ (expr env) `(UNDEF ,(second expr))))

(defspecial 'unless (^ (expr env) ))

(defspecial 'values (^ (expr env) ))

(defspecial 'when (^ (expr env) ))

(defspecial 'with-exit (^ (expr env) ))

(defspecial 'with-open (^ (expr env) ))

;;; ---------------------------------------------------------------------
;;; macros
;;; ---------------------------------------------------------------------

(define variable $bard-macro-forms {})

(define method (macro-form? expr)
  (and (something? (get $bard-macro-forms (first expr)))
       true))

(define method (defmacro opname comp-fn)
  (set! $bard-macro-forms
        (put-key $bard-macro-forms opname comp-fn)))

(define method (expand-macro-form expr)
  (let ((expander (get $bard-macro-forms (first expr))))
    (expander expr)))

;;; ---------------------------------------------------------------------
;;; compiling
;;; ---------------------------------------------------------------------

(define method (compile-app expr env)
  (cond
   ((special-form? expr) (compile-special-form expr env))
   ((macro-form? expr) (compile (expand-macro-form expr) env))
   (else: `(APPLY
            ,(compile (first expr) env)
            ,(map (^ (e)(compile e env)) 
                  (rest expr))))))

(define method (compile-var expr env)
  (let ((i j (in-env expr env)))
    (if (something? i)
        `(LREF ,i ,j)
        `(GREF ,expr))))

(define method (compile expr env) expr)

(define method (compile expr env)
  with: ((expr <pair>))
  (compile-app expr env))

(define method (compile expr env)
  with: ((expr <symbol>))
  (compile-var expr env))

(define method (compile-file path)
  (with-open-file (in path)
    (with-exit (return)
      (repeat
       (let ((form (read in)))
         (if (= form #!eof)
             (return 'done)
             (begin
              (display form)
              (newline))))))))

