;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          modules.bard
;;;; Project:       Bard
;;;; Purpose:       model implementations of bard's modules
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; ---------------------------------------------------------------------
;;; global variables
;;; ---------------------------------------------------------------------
;;; global variables are anonymous, identified by id numbers
;;; TODO: use a vector representation of globals in the compiler for
;;;       improved efficiency

(define variable *globals* [])
(define variable *global-permissions* [])
(define variable *next-global-id* 0)

(define method (add-global! value mutable?)
  (set! *globals* (append *globals* [value]))
  (set! *global-permissions* (append *global-permissions* [mutable?]))
  (set! *next-global-id* (+ 1 *next-global-id*))
  (- *next-global-id* 1))

(define method (gid-defined? gid)
  (and (> gid -1)
       (< gid *next-global-id*)))

(define method (gid->value gid)
  (if (gid-defined? gid)
      (get *globals* gid)
      (error ["Undefined global id: " gid])))

(define method (gid-mutable? gid)
  (if (gid-defined? gid)
      (get *global-permissions* gid)
      (error ["Undefined global id: " gid])))

(define method (set-gid-value! gid val)
  (if (gid-defined? gid)
      (if (gid-mutable? gid)
          (set! *globals*
                (put *globals* gid val))
          (error ["Tried to write to immutable global id: " gid]))
      (error ["Undefined global id: " gid])))

;;; ---------------------------------------------------------------------
;;; modules
;;; ---------------------------------------------------------------------
;;; modules are namespaces
;;; a module variable is a module-defined alias for a global
;;; these aliases are the only way to make globals visible

(define variable *modules* {})

(define method (find-module mname)
  (get *modules* mname))

(define method (list-modules)
  (keys *modules*))

(define macro (defmodule mname)
  (let ((mvar (gensym)))
    `(let ((,mvar { name: ',mname variables: {} exports: {} imports: {}}))
       (set! *modules* (merge *modules* { ',mname ,mvar}))
       ',mname)))

(define method (delete-module! mname)
  (if (something? (find-module mname))
      (let ((mkeys (filter (^ (k)(not (= k mname)))
                           (keys *modules*)))
            (mvals (map (^ (k)(get *modules* k))
                        mkeys))
            (plist (reduce append (map list mkeys mvals)))
            (new-modules (apply (partial make <alist-table>) plist)))
        (set! *modules* new-modules))
      nothing))

(define method (add-module-variable! mname varname gid)
  (let ((module (find-module mname))
        (mvars (get module variables:))
        (new-module (merge module {variables: (merge mvars {varname gid})})))
    (set! *modules* (merge *modules* {mname new-module}))
    mname))

(define method (define-module-variable mname varname val mutable?)
  (if (something? (find-module mname))
      (let ((gid (add-global! val mutable?)))
        (add-module-variable! mname varname gid)
        (values varname mname))
      (error ["No such module: " mname])))

(define method (lookup-module-variable mname varname)
  (let ((module (find-module mname)))
    (if (something? module)
        (let ((vars (get module variables:))
              (gid (get vars varname)))
          (if (something? gid)
              (gid->value gid)
              (error ["No variable " varname " defined in module " mname])))
        (error ["No such module: " mname]))))

(define method (set-module-variable! mname varname val)
  (let ((module (find-module mname)))
    (if (something? module)
        (let ((vars (get module variables:))
              (gid (get vars varname)))
          (if (something? gid)
              (begin
               (set-gid-value! gid val)
               val)
              (error ["No variable " varname " defined in module " mname])))
        (error ["No such module: " mname]))))
