;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compiler.bard
;;;; Project:       Bard
;;;; Purpose:       the bard compiler in bard
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; ---------------------------------------------------------------------
;;; modules
;;; ---------------------------------------------------------------------

;;; ---------------------------------------------------------------------
;;; globals
;;; ---------------------------------------------------------------------

;;; ---------------------------------------------------------------------
;;; environments
;;; ---------------------------------------------------------------------

(define record lvar val name mutable?)

(define method (env-frame vars) vars)

(define method (null-env) nothing)
(define method (add-frame env frame) (add-first frame env))

(define method (in-env? var env)
  with: ((var <symbol>))
  (some? (^ (fr)(some? (^ (v)(= var (get v 'name)))
                       fr))
         env))

;;; ---------------------------------------------------------------------
;;; expression compilers
;;; ---------------------------------------------------------------------

(define method (compile--> args env)
  (let ((params (map (^ (a) (gensym)) args))
        (fns (map (^ (p f) `(,f ,p)) params (map (^ (a)(compile a env)) args))))
    `(METHOD ,params (VALUES ,@fns))))

(define method (compile-begin args env)
  (let ((body (map (^ (e) `(EVAL ,(compile e env))) args)))
    `(BEGIN ,@body)))

(define method (compile-cascade args env)
  )

(define method (compile-cond args env)
  (let ((clauses (map (^ (c) `((EVAL ,(compile (first c) env))
                               (EVAL ,(compile (add-first 'begin (rest c)) env))))
                      args)))
    `(COND ,@clauses)))

(define method (compile-def args env)
  `(DEF ,(first args)
        ,(compile (second args) env)))

(define method (compile-define args env)
  )

(define method (compile-ensure args env)
  `(DYNAMIC-WIND (LAMBDA () ,(compile (first args) env))
                 (LAMBDA () ,(compile (second args) env))
                 (LAMBDA () ,(compile (element args 2) env))))

(define method (compile-function args env)
  )

(define method (compile-generate args env)
  )

(define method (compile-if args env)
  (let ((test (compile (first args) env))
        (then (compile (second args) env))
        (else-form (drop 2 args))
        (else (if (something? else-form)
                  (compile (first else-form) env)
                  nothing)))
    `(IF (EVAL ,test)
         (EVAL ,then)
         (EVAL ,else))))

(define method (compile-let args env)
  )

(define method (compile-loop args env)
  )

(define method (compile-match args env)
  )

(define method (compile-method args env)
  (let ((params (first args))
        (body (drop 1 args)))
    `(METHOD ,params ,(add-first 'BEGIN (map (^ (e)(compile e env)) body)))))

(define method (compile-not args env)
  )

(define method (compile-protocol args env)
  )

(define method (compile-quasiquote args env)
  )

(define method (compile-quote args env)
  )

(define method (compile-receive args env)
  )

(define method (compile-repeat args env)
  )

(define method (compile-send args env)
  )

(define method (compile-set! args env)
  )

(define method (compile-setter args env)
  )

(define method (compile-time args env)
  )

(define method (compile-undefine args env)
  )

(define method (compile-unless args env)
  )

(define method (compile-values args env)
  )

(define method (compile-when args env)
  )

(define method (compile-with-open args env)
  )

(define method (compile-application op args env)
  (cond
   ((= op '^)(compile-method args env))
   ((= op '->)(compile--> args env))
   ((= op 'begin)(compile-begin args env))
   ((= op 'cascade)(compile-cascade args env))
   ((= op 'cond)(compile-cond args env))
   ((= op 'def)(compile-def args env))
   ((= op 'define)(compile-define args env))
   ((= op 'ensure)(compile-ensure args env))
   ((= op 'function)(compile-function args env))
   ((= op 'generate)(compile-generate args env))
   ((= op 'if)(compile-if args env))
   ((= op 'let)(compile-let args env))
   ((= op 'loop)(compile-loop args env))
   ((= op 'match)(compile-match args env))
   ((= op 'method)(compile-method args env))
   ((= op 'not)(compile-not args env))
   ((= op 'protocol)(compile-protocol args env))
   ((= op 'quasiquote)(compile-quasiquote args env))
   ((= op 'quote)(compile-quote args env))
   ((= op 'receive)(compile-receive args env))
   ((= op 'repeat)(compile-repeat args env))
   ((= op 'send)(compile-send args env))
   ((= op 'set!)(compile-set! args env))
   ((= op 'setter)(compile-setter args env))
   ((= op 'time)(compile-time args env))
   ((= op 'undefine)(compile-undefine args env))
   ((= op 'unless)(compile-unless args env))
   ((= op 'values)(compile-values args env))
   ((= op 'when)(compile-when args env))
   ((= op 'with-open)(compile-with-open args env))))

(define method (compile-var var env)
  (if (in-env? var env)
      `(LREF ,var)
      `(GREF ,var)))

(define method (compile expr env) expr)

(define method (compile expr env) 
  with: ((expr <symbol>))
  (compile-var expr env))

(define method (compile expr env) 
  with: ((expr <pair>))
  (compile-application (first expr) (rest expr) env))

;;; (compile '(^ (x y) x) [])
;;; (compile '(^ (x y) x) [[(make lvar val: 0 name: 'x mutable?: false)]])
;;; (compile '(begin 1 2 3) [])
;;; (compile '(if 1 2 3) [])
