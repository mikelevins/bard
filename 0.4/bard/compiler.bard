;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compiler.bard
;;;; Project:       Bard
;;;; Purpose:       the bard compiler in bard
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; TODO
;;; ensure
;;; let
;;; loop
;;; match
;;; protocol
;;; quasiquote
;;; receive
;;; send
;;; set!
;;; setter
;;; time
;;; with-exit
;;; with-open

;;; ---------------------------------------------------------------------
;;; utils
;;; ---------------------------------------------------------------------

(define variable *label-counter* 0)

(define method (gen-label & nm)
  (let ((nm (if nm (as <string> (first nm)) "L"))
        (n *label-counter*))
    (set! *label-counter* (+ *label-counter* 1))
    (as <symbol> (append nm (as <string> n)))))

(define method (interpose thing things)
  with: ((things <null>))
  [])

(define method (interpose thing things)
  with: ((things <pair>))
  (if (empty? (rest things))
      things
      (pair (first things)
            (pair thing
                  (interpose thing (rest things))))))

(define method (not-yet-implemented name)
  (error [name " is not yet implemented "]))

;;; ---------------------------------------------------------------------
;;; environments
;;; ---------------------------------------------------------------------

(define method (null-env)
  [])

(define method (add-binding env var val)
  with: ((var <symbol>))
  (pair (pair var val)
        env))

(define method (add-bindings env vars vals)
  (let ((bindings (map (method (k v)(pair k v))
                       vars vals)))
    (append bindings env)))

(define method (add-vars env vars)
  (let ((bindings (map (method (k)(pair k nothing))
                       vars)))
    (append bindings env)))


;;; ---------------------------------------------------------------------
;;; compilers for define
;;; ---------------------------------------------------------------------

;;; define class
;;; ---------------------------------------------------------------------

(define method (compile-define-class expression environment)
  (let ((forms (drop 2 expression))
        (cname (first forms))
        (superforms (rest forms))
        (supercount (length superforms)))
    (if (> supercount 0)
        (let ((supers (reduce append
                              (map (^ (s)(compile s environment))
                                   superforms))))
          `(,@supers
            (CONST ,supercount)
            (PRIM list)
            (PRIM make-class)
            (GSET ,cname)))
        `((CONST ())
          (PRIM make-class)
          (GSET ,cname)))))

;;; define constant
;;; ---------------------------------------------------------------------

(define method (compile-define-constant expression environment)
  (let ((var (element expression 2))
        (val-form (element expression 3))
        (val (compile val-form environment)))
    `((GRW ,var)
      ,@val
      (GSET ,var)
      (GRO ,var))))

;;; define macro
;;; ---------------------------------------------------------------------

(define method (compile-define-macro expression environment)
  (not-yet-implemented 'compile-define-macro))

;;; define method
;;; ---------------------------------------------------------------------

(define method (compile-define-method expression environment)
  (not-yet-implemented 'compile-define-method))

;;; define protocol
;;; ---------------------------------------------------------------------

(define method (compile-define-protocol expression environment)
  (not-yet-implemented 'compile-define-protocol))

;;; define variable
;;; ---------------------------------------------------------------------

(define method (compile-define-variable expression environment)
  (let ((var (element expression 2))
        (val-form (element expression 3))
        (val (compile val-form environment)))
    `(,@val
      (GSET ,var))))

;;; ---------------------------------------------------------------------
;;; defining structures
;;; ---------------------------------------------------------------------

;;; define record
;;; ---------------------------------------------------------------------

(define method (compile-define-record expression environment)
  (not-yet-implemented 'compile-define-record))

;;; define vector
;;; ---------------------------------------------------------------------

(define method (compile-define-vector expression environment)
  (not-yet-implemented 'compile-define-vector))

;;; define union
;;; ---------------------------------------------------------------------

(define method (compile-define-union expression environment)
  (not-yet-implemented 'compile-define-union))


;;; ---------------------------------------------------------------------
;;; special form compilers
;;; ---------------------------------------------------------------------

;;; defining special forms

(define variable *special-form-definitions* {})

(define method (define-special-form name compiler-fn)
  (set! *special-form-definitions*
        (merge *special-form-definitions*
               {name compiler-fn})))

(define method (special-form? x)
  (and (get *special-form-definitions* x)
       true))

(define method (compile-special-form expression environment)
  (let ((name (first expression))
        (special-compile (get *special-form-definitions* name)))
    (special-compile expression environment)))

;;; compilers

;;; begin
;;; ---------------------------------------------------------------------

(define method (compile-begin-sequence exprs environment)
  (interpose '(POP 1)
             (reduce append
                     (map (method (x)(compile x environment))
                          exprs))))

(define-special-form 'begin
  (method (expression environment)
          (compile-begin-sequence (rest expression) environment)))

;;; cond
;;; ---------------------------------------------------------------------

(define method (compile-cond-clauses clauses environment end-label)
  with: ((clauses <null>))
  `(,end-label))

(define method (compile-cond-clauses clauses environment end-label)
  with: ((clauses <pair>))
  (let ((test-form (first clauses))
        (test-code (compile test-form environment))
        (body-form (second clauses))
        (body-code (compile body-form environment))
        (more (drop 2 clauses))
        (next-label (gen-label))
        (case-code `(,@test-code
                     (FGO ,next-label)
                     ,@body-code
                     (GO ,end-label)
                     ,next-label)))
    (append case-code
            (compile-cond-clauses more environment end-label))))

(define-special-form 'cond
  (method (expression environment)
          (let ((clauses (rest expression))
                (end-label (gen-label)))
            (compile-cond-clauses clauses environment end-label))))

;;; define
;;; ---------------------------------------------------------------------

(define-special-form 'define
  (method (expression environment)
          (if (and (list? expression)
                   (> (length expression) 2))
              (let ((deftype (second expression)))
                (cond
                 ((= deftype 'class)(compile-define-class expression environment))
                 ((= deftype 'constant)(compile-define-constant expression environment))
                 ((= deftype 'macro)(compile-define-macro expression environment))
                 ((= deftype 'method)(compile-define-method expression environment))
                 ((= deftype 'protocol)(compile-define-protocol expression environment))
                 ((= deftype 'variable)(compile-define-variable expression environment))
                 ((= deftype 'record)(compile-define-record expression environment))
                 ((= deftype 'vector)(compile-define-vector expression environment))
                 ((= deftype 'union)(compile-define-union expression environment))
                 (else: (error ["don't know how to define " deftype]))))
              (error ["not enough elements in define expression: " expression]))))

;;; function
;;; ---------------------------------------------------------------------
;;; (-> Integer Anything -> Anything)
;;; (function Integer Anything -> Anything)

(define method (compile-function expression environment)
  (let ((signature (rest expression))
        (arrow-pos (position '-> signature)))
    (if (something? arrow-pos)
        (let ((input-types (reduce append
                                   (map (^ (x)(compile x environment))
                                        (take arrow-pos signature))))
              (input-count (length input-types))
              (output-types (reduce append
                                    (map (^ (x)(compile x environment))
                                         (rest (drop arrow-pos signature)))))
              (output-count (length output-types)))
          `(,@input-types
            (CONST ,input-count)
            (PRIM list)
            ,@output-types
            (CONST ,output-count)
            (PRIM list)
            (PRIM function)))
        (error ["Syntax error in function form: " expression]))))

(define-special-form '->
  (method (expression environment)
          (compile-function expression environment)))

(define-special-form 'function
  (method (expression environment)
          (compile-function expression environment)))

;;; if
;;; ---------------------------------------------------------------------

(define method (compile-if expression environment)
  (let ((test-form (element expression 1))
        (test-code (compile test-form environment))
        (then-form (element expression 2))
        (then-code (compile then-form environment))
        (else-label (gen-label))
        (else-form (element expression 3))
        (else-code (compile else-form environment))
        (end-label (gen-label)))
    `(,@test-code
      (FGO ,else-label)
      ,@then-code
      (GO ,end-label)
      ,else-label
      ,@else-code
      ,end-label)))

(define-special-form 'if
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 4)(error ["syntax error in if expression: " expression]))
             ((= len 4)(compile-if expression environment))
             (else (error ["syntax error in if expression: " expression]))))))

;;; method
;;; ---------------------------------------------------------------------
;;; (^ (x) (+ x 1))
;;; (method (x) (+ x 1))

(define method (parse-method-args paramlist)
  (let ((rest-pos (position '& paramlist)))
    (if (something? rest-pos)
        (let ((params (take rest-pos paramlist))
              (rest-params (drop (+ rest-pos 1) paramlist)))
          (if (= 1 (length rest-params))
              (values params (first rest-params))
              (error ["Syntax error in parameter list: " paramlist])))
        (values paramlist nothing))))

(define method (compile-method expression environment)
  (let ((params restarg (parse-method-args (second expression)))
        (body (drop 2 expression)))
    (if (= <pair> (type params))
        (let ((compile-env (add-vars environment params))
              (body-code (compile-begin-sequence body compile-env)))
          `((CONST ,params)
            (CONST ,restarg)
            (CONST ,body-code)
            (PRIM method)))
        (error ["syntax error in method expression: " expression]))))

(define-special-form '^ 
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 2)(error ["syntax error in method expression: " expression]))
             (else (compile-method expression environment))))))

(define-special-form 'method 
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 2)(error ["syntax error in method expression: " expression]))
             (else (compile-method expression environment))))))

;;; quote
;;; ---------------------------------------------------------------------

(define-special-form 'quote 
  (method (expression environment)
          [['CONST (second expression)]]))

;;; undefine
;;; ---------------------------------------------------------------------

(define-special-form 'undefine
  (method (expression environment)
          (let ((len (length expression)))
            (if (= 2 len)
                `((UNDEF ,(second expression)))
                (error ["syntax error in undefine expression: " expression])))))

;;; unless
;;; ---------------------------------------------------------------------

(define method (compile-unless expression environment)
  (let ((test-form (element expression 1))
        (test-code (compile test-form environment))
        (body-forms (drop 2 expression))
        (body-code (compile-begin-sequence body-forms environment))
        (end-label (gen-label)))
    `(,@test-code
      (TGO ,end-label)
      ,@body-code
      ,end-label)))

(define-special-form 'unless
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 2)(error ["syntax error in unless expression: " expression]))
             (else (compile-unless expression environment))))))

;;; values
;;; ---------------------------------------------------------------------

(define-special-form 'values
  (method (expression environment)
          (let ((forms (rest expression))
                (forms-count (length forms))
                (forms-code (reduce append
                                    (map (^ (f)(compile f environment))
                                         forms))))
            `(,@forms-code
              (CONST ,forms-count)
              (PRIM values)))))

;;; when
;;; ---------------------------------------------------------------------

(define method (compile-when expression environment)
  (let ((test-form (element expression 1))
        (test-code (compile test-form environment))
        (body-forms (drop 2 expression))
        (body-code (compile-begin-sequence body-forms environment))
        (end-label (gen-label)))
    `(,@test-code
      (FGO ,end-label)
      ,@body-code
      ,end-label)))

(define-special-form 'when
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 2)(error ["syntax error in when expression: " expression]))
             (else (compile-when expression environment))))))

;;; ---------------------------------------------------------------------
;;; macro expanders
;;; ---------------------------------------------------------------------

(define variable *macro-definitions* {})

(define method (define-macroexpander name expander-fn)
  (set! *macro-definitions*
        (merge *macro-definitions*
               {name expander-fn})))

(define method (macroname? x)
  (and (get *macro-definitions* x)
       true))

(define method (macroexpand expression)
  (let ((name (first expression))
        (expand (get *macro-definitions* name)))
    (expand expression)))

;;; ---------------------------------------------------------------------
;;; primitives
;;; ---------------------------------------------------------------------

(define variable *primitives* {})

(define method (define-primitive name prim-fn)
  (set! *primitives*
        (merge *primitives*
               {name prim-fn})))

(define method (primitive? x)
  (and (get *primitives* x)
       true))

(define method (compile-primitive-call expression environment)
  (let ((argcount (length (rest expression))))
    [['PRIM (first expression) argcount]]))

;;; ---------------------------------------------------------------------
;;; environments
;;; ---------------------------------------------------------------------

(define method (environment-bindings env)
  env)

(define method (binding-key binding)
  (left binding))

(define method (find-variable-binding var-expr env)
  (some? (^ (x)(= var-expr (binding-key x)))
        (environment-bindings env)))

(define method (in-environment? var-expr env)
  (and (something? (find-variable-binding var-expr env))
       true))

;;; ---------------------------------------------------------------------
;;; main compiler
;;; ---------------------------------------------------------------------

(define method (compile-variable-reference expression environment)
  (if (in-environment? expression environment)
      [['LREF expression]]
      [['GREF expression]]))

(define method (compile-apply-value expression environment)
  (let ((val (first expression))
        (val-code (compile val environment))
        (arg-exprs (rest expression))
        (args-code (reduce append
                           (map (^ (x)(compile x environment))
                                arg-exprs))))
    (reverse (pair (pair 'APPLY [(length args-code)])
                   (append val-code
                         (reverse args-code))))))

(define method (compile-procedure-call-for operator expression environment)
  (compile-apply-value expression environment))

(define method (compile-procedure-call-for operator expression environment)
  with: ((operator <symbol>))
  (if (special-form? operator)
      (compile-special-form expression environment)
      (if (macroname? operator)
          (compile (macroexpand expression) environment)
          (if (primitive? operator)
              (compile-primitive-call expression environment)
              (compile-apply-value expression environment)))))

(define method (compile-procedure-call-for operator expression environment)
  with: ((operator <pair>))
  (compile-apply-value expression environment))

(define method (compile-procedure-call expression environment)
  (compile-procedure-call-for (first expression)
                              expression
                              environment))

(define method (compile expression environment)
  [['CONST expression]])

(define method (compile expression environment)
  with: ((expression <symbol>))
  (compile-variable-reference expression environment))

(define method (compile expression environment)
  with: ((expression <pair>))
  (compile-procedure-call expression environment))
