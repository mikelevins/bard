;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compiler.bard
;;;; Project:       Bard
;;;; Purpose:       the bard compiler in bard
;;;; Author:        mikel evins
;;;; Copyright:     2013 by mikel evins
;;;;
;;;; ***********************************************************************

;;; ---------------------------------------------------------------------
;;; utils
;;; ---------------------------------------------------------------------

(define variable *label-counter* 0)

(define method (gen-label & nm)
  (let ((nm (if nm (as <string> (first nm)) "L"))
        (n *label-counter*))
    (set! *label-counter* (+ *label-counter* 1))
    (as <symbol> (append nm (as <string> n)))))

(define method (interpose thing things)
  with: ((things <null>))
  [])

(define method (interpose thing things)
  with: ((things <pair>))
  (if (empty? (rest things))
      things
      (pair (first things)
            (pair thing
                  (interpose thing (rest things))))))

;;; ---------------------------------------------------------------------
;;; special form compilers
;;; ---------------------------------------------------------------------

;;; defining special forms

(define variable *special-form-definitions* {})

(define method (define-special-form name compiler-fn)
  (set! *special-form-definitions*
        (merge *special-form-definitions*
               {name compiler-fn})))

(define method (special-form? x)
  (and (get *special-form-definitions* x)
       true))

(define method (compile-special-form expression environment)
  (let ((name (first expression))
        (special-compile (get *special-form-definitions* name)))
    (special-compile expression environment)))

;;; compilers

;;; begin
;;; ---------------------------------------------------------------------

(define method (compile-begin-sequence exprs environment)
  (interpose '(POP 1)
             (reduce append
                     (map (method (x)(compile x environment))
                          exprs))))

(define-special-form 'begin
  (method (expression environment)
          (compile-begin-sequence (rest expression) environment)))

;;; cond
;;; ---------------------------------------------------------------------

(define method (compile-cond-clauses clauses environment end-label)
  with: ((clauses <null>))
  `(,end-label))

(define method (compile-cond-clauses clauses environment end-label)
  with: ((clauses <pair>))
  (let ((test-form (first clauses))
        (test-code (compile test-form environment))
        (body-form (second clauses))
        (body-code (compile body-form environment))
        (more (drop 2 clauses))
        (next-label (gen-label))
        (case-code `(,@test-code
                     (FGO ,next-label)
                     ,@body-code
                     (GO ,end-label)
                     ,next-label)))
    (append case-code
            (compile-cond-clauses more environment end-label))))

(define-special-form 'cond
  (method (expression environment)
          (let ((clauses (rest expression))
                (end-label (gen-label)))
            (compile-cond-clauses clauses environment end-label))))

;;; if
;;; ---------------------------------------------------------------------

(define method (compile-if expression environment)
  (let ((test-form (element expression 1))
        (test-code (compile test-form environment))
        (then-form (element expression 2))
        (then-code (compile then-form environment))
        (else-label (gen-label))
        (else-form (element expression 3))
        (else-code (compile else-form environment))
        (end-label (gen-label)))
    `(,@test-code
      (FGO ,else-label)
      ,@then-code
      (GO ,end-label)
      ,else-label
      ,@else-code
      ,end-label)))

(define-special-form 'if
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 4)(error "syntax error in if expression: " expression))
             ((= len 4)(compile-if expression environment))
             (else (error "syntax error in if expression: " expression))))))

;;; quote
;;; ---------------------------------------------------------------------

(define-special-form 'quote 
  (method (expression environment)
          [['CONST (second expression)]]))

;;; unless
;;; ---------------------------------------------------------------------

(define method (compile-unless expression environment)
  (let ((test-form (element expression 1))
        (test-code (compile test-form environment))
        (body-forms (drop 2 expression))
        (body-code (compile-begin-sequence body-forms environment))
        (end-label (gen-label)))
    `(,@test-code
      (TGO ,end-label)
      ,@body-code
      ,end-label)))

(define-special-form 'unless
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 2)(error "syntax error in unless expression: " expression))
             (else (compile-unless expression environment))))))

;;; when
;;; ---------------------------------------------------------------------

(define method (compile-when expression environment)
  (let ((test-form (element expression 1))
        (test-code (compile test-form environment))
        (body-forms (drop 2 expression))
        (body-code (compile-begin-sequence body-forms environment))
        (end-label (gen-label)))
    `(,@test-code
      (FGO ,end-label)
      ,@body-code
      ,end-label)))

(define-special-form 'when
  (method (expression environment)
          (let ((len (length expression)))
            (cond
             ((< len 2)(error "syntax error in when expression: " expression))
             (else (compile-when expression environment))))))

;;; ---------------------------------------------------------------------
;;; macro expanders
;;; ---------------------------------------------------------------------

(define variable *macro-definitions* {})

(define method (define-macroexpander name expander-fn)
  (set! *macro-definitions*
        (merge *macro-definitions*
               {name expander-fn})))

(define method (macroname? x)
  (and (get *macro-definitions* x)
       true))

(define method (macroexpand expression)
  (let ((name (first expression))
        (expand (get *macro-definitions* name)))
    (expand expression)))

;;; ---------------------------------------------------------------------
;;; primitives
;;; ---------------------------------------------------------------------

(define variable *primitives* {})

(define method (define-primitive name prim-fn)
  (set! *primitives*
        (merge *primitives*
               {name prim-fn})))

(define method (primitive? x)
  (and (get *primitives* x)
       true))

(define method (compile-primitive-call expression environment)
  (let ((argcount (length (rest expression))))
    [['PRIM (first expression) argcount]]))

;;; ---------------------------------------------------------------------
;;; environments
;;; ---------------------------------------------------------------------

(define method (environment-bindings env)
  env)

(define method (binding-key binding)
  (left binding))

(define method (find-variable-binding var-expr env)
  (some? (^ (x)(= var-expr (binding-key x)))
        (environment-bindings env)))

(define method (in-environment? var-expr env)
  (and (something? (find-variable-binding var-expr env))
       true))

;;; ---------------------------------------------------------------------
;;; main compiler
;;; ---------------------------------------------------------------------

(define method (compile-variable-reference expression environment)
  (if (in-environment? expression environment)
      [['LREF expression]]
      [['GREF expression]]))

(define method (compile-apply-value expression environment)
  (let ((val (first expression))
        (val-code (compile val environment))
        (arg-exprs (rest expression))
        (args-code (reduce append
                           (map (^ (x)(compile x environment))
                                arg-exprs))))
    (reverse (pair (pair 'APPLY [(length args-code)])
                   (append val-code
                         (reverse args-code))))))

(define method (compile-procedure-call-for operator expression environment)
  (compile-apply-value expression environment))

(define method (compile-procedure-call-for operator expression environment)
  with: ((operator <symbol>))
  (if (special-form? operator)
      (compile-special-form expression environment)
      (if (macroname? operator)
          (compile (macroexpand expression) environment)
          (if (primitive? operator)
              (compile-primitive-call expression environment)
              (compile-apply-value expression environment)))))

(define method (compile-procedure-call-for operator expression environment)
  with: ((operator <pair>))
  (compile-apply-value expression environment))

(define method (compile-procedure-call expression environment)
  (compile-procedure-call-for (first expression)
                              expression
                              environment))

(define method (compile expression environment)
  [['CONST expression]])

(define method (compile expression environment)
  with: ((expression <symbol>))
  (compile-variable-reference expression environment))

(define method (compile expression environment)
  with: ((expression <pair>))
  (compile-procedure-call expression environment))
