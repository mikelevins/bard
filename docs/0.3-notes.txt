Protocols:

(protocol Shapes
          ((intersects? <Shape> <Shape>) => (maybe <Boolean>)))

(define-method intersects? (x <rectangle>)(y <rectangle>)
    ...)

(protocol Transmitting
          ((transfer <Source-Agent> <Destination-Agent>) 
           => <Transfer-Report>)
          ((open <File> &key (direction: :input)) 
           => <Stream>)
          ((close <Stream>) => <void>))

Protocol declarations are essentially like a Prolog database. They
constitue a set of relations, where the names of categories are logic
variables. A method definition acts like an assertion. When the method
is defined, the type system must unify all its categories against the
changed set of assertions. If a category ends up unbound, that's okay,
but means a protocol is not fully implemented; it should be able to
report that, so the user can decide what to do about it. If it finds a
contradiction, that's an error; the database is inconsistent. The
runtime should prevent that at the point where the assertion is made,
rejecting the method definition as causing an inconsistency, and it
should report the other method definitions with which it's
inconsistent.


