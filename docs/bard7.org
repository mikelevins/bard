#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/asciidoctor.css" />
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./css/styles.css" />
#+OPTIONS: toc:nil
#+OPTIONS: num:1
#+OPTIONS: ^:nil
#+TITLE: bard 0.7

bard 0.7 is the seventh major iteration of design and implementation
of the Bard programming language. Bard is intended to be an
old-fashioned Lisp in the sense that it fully embraces interactive
programming and unrestricted malleability. This version of the
implementation also shoots for the kind of easy portability of source
and object code represented by old-fashioned Smalltalk environments,
using a compiler to a platform-agnostic bytecode format and a portable virtual machine.

Bard 0.7 also embraces more recent developments in
programming-language design, including a functional-first language
with immutable-first datatypes, protocol-oriented programming, and
support for internet protocols and widely-used data formats.

Finally, Bard is intended to be a small language with a relatively
simple surface. This document records my progress toward that goal.

* Data

Bard 0.7 offers the following built-in datatypes:

| Type name | Examples                                   | Description                              |
|-----------+--------------------------------------------+------------------------------------------|
| Null      | ~nothing~                                  | The type of ~nothing~.                   |
| Boolean   | ~true~, ~false~                            | True and false.                          |
|           |                                            | ~nothing~ is also logically false.       |
| Number    | ~0~, ~1~, ~-2~, ~3/4~, ~5.6~               | Any numeric value.                       |
| Text      | ~""~, ~"Some text"~                        | A text string.                           |
| List      | ~[1 2 3]~,~("one" "two" "three")~          | A sequence of values.                    |
| Map       | ~{}~, ~{:name "Fred" :color "Orange"}~     | A mapping from keys to values.           |
| Operation | ~(function foo Bar -> Baz)~,               | A value that can be applied to some      |
|           | ~(^ [x] (+ x 1))~                          | number of arguments to compute a result. |
| Structure | ~(record <point> {:x <float> :y <float>})~ | A blueprint for constructing values.     |
|           | ~(tuple <ostype> [<byte> {:exactly 4}])~   |                                          |
|           | ~(enum <color> 'Red 'Green 'Blue)~         |                                          |

* Protocols, Types, Classes, and Structures

A Bard *type* is either a *class* or a *structure*.

A *structure* is a recipe for assembling data into a value. Bard defines a small set of *built-in structures*, including concrete representations of all the types listed in the previous section. It also defines a set of *operations* that you can use to define your own structures.

A structure can be *instantiated*--that is, it can be used to create values. Values created from a structure are said to be *instances* of that structure, and they belong to the *type* that the structure represents.

A *class*, on the other hand, is a named collection of types. Most classes are defined to fulfill one or more roles in a *protocol*. 

A *protocol* is a defined set of *operations* and *variables*. Operations accept input values and produce output values. A protocol can declare abstract types for those inputs and outputs. The abstract types thus defined are *classes*.

In Bard, a class is simply the name of a role in one or more protocol functions. It does not specify any internal structure or any taxonomic relationship to any other type. A class need not have any instances at all.

The most common way to make a value into an instance of a class is by *specializing* a protocol function to operate on that value. If there's a method of a function specialized for a value, then the value's structure belongs to the corresponding class declared by the function's definition.

For example, if I define a function like this:

#+BEGIN_SRC lisp
  (function foo Bar -> Baz)
#+END_SRC

then I have implicitly created the function ~foo~ and the classes ~Bar~ and ~Baz~. If I now *specialize* ~foo~ for some input structure, like this:

#+BEGIN_SRC lisp
  (define method (foo bar)
    with {bar (a <small-integer>)}
    ...
  )
#+END_SRC

then I have implicitly declared that ~<small-integer>~ is a *member* of the ~Bar~ class. If I now call ~foo~ with an instance of ~<small-integer>~, like so:

#+BEGIN_SRC lisp
  (foo 15)
#+END_SRC

then Bard finds the method that I defined above and applies it.

* Operations

An *operation* is a value that can be applied to some sequence of
expressions to compute a result. There are four kinds of operations:

- *special forms* are built into the Bard system and may follow their own rules of evaluation.
- *functions* are polymorphic operators that evaluate their arguments, examine the results, and choose a *method* to apply to the values.
- *methods* are monomorphic operators that apply bard expressions to their input parameters to compute results. Methods are commonly applied by functions, but may also be referenced and applied directly.
- *macros* are operations that rewrite calling expressions before applying them. When you apply a macro, the code in its definition rewrites the entire expression, and then evaluates the transformed expression. You can use macros to add new syntax to Bard.

* The Bard Runtime

Bard 0.7 is a virtual machine that executes portable bytecode. It supports compiling Bard source code in the form of S-expressions to a bytecode format called *bardo*. It may in the future also support compiling bardo to native machine code.

* Lexical Syntax

** Literal Values
*** Named Constants

*Named constants* are *names* that are defined in all lexical contexts, and that always refer to the same value. 4 of them are defined by the Bard language:

| Name      | Description                     |
|-----------+---------------------------------|
| nothing   | The empty list, set, or map.    |
| true      | The Boolean true value.         |
| false     | The Boolean false value.        |
| undefined | The absence of any useful value |
|           |                                 |

*** Numbers

*Numbers* are numeric values including integers, ratios, decimal numbers, and bytes. Bard 0.7 defines several built in numeric structures.

| Values              | Structure       | Notes                                                           |
|---------------------+-----------------+-----------------------------------------------------------------|
| 0, 100, -2          | <small-integer> | Integers that can be conveniently represented by a machine word |
| 9999999999999999999 | <big-integer>   | Unlimited-precision integers                                    |
| 2/3                 | <ratio>         | Fractional number represented by ratios of integers             |
| 0.1                 | <float>         | Decimal numbers represented as floating-point values            |
| #<byte>3            | <byte>          | 8-bit bytes                                                     |

*** Names

*Names* are values that Bard uses to name elements of the language such as functions, variables, and special forms, or to represent certain kinds of name-like data, such as files and network resources. There are three kinds of names:

| Examples                               | Structure   | Notes                                          |
|----------------------------------------+-------------+------------------------------------------------|
| ~foo~, ~Bar~, ~<symbol>~               | ~<symbol>~  | Names used for variables, functions, and so on |
| ~:type~, ~:Family~                     | ~<keyword>~ | Names that always evaluate to themselves       |
| ~@file:///tmp/~,~@https://barcode.net~ | ~<uri>~     | URIs                                           |

*** Lists

Lists are sequences of values, addressable by index. ~List~ is a class, not a structure, and its members include several different structures that represent sequences of values. Instances of ~List~ participate in the ~Listing~ protocol.

Some lists are mutable; others are immutable.

| Examples | Structure  | Notes                     |
|----------+------------+---------------------------|
| (...)    | ~<cons>~   | Singly-linked lists       |
| [...]    | ~<vector>~ | One-dimensional arrays    |
| "..."    | ~<string>~ | See "Text Strings", below |


*** Text Strings

Text strings are Lists of characters. They participate in the ~Listing~ protocol and so all List operations work on them, but they also participate in the ~TextProcessing~ protocol, which adds numerous operations specialized for handling text.

Like ~List~, ~Text~ is a class, not a structure, and there may be several different structures that implement it.

| Examples | Structure  | Notes                                                        |
|----------+------------+--------------------------------------------------------------|
| "..."    | ~<string>~ | ~<string>~ is just one possible structure representing Text. |


*** Characters

Characters are the atomic elements of text strings. The class ~Character~ comprises the structure used to represent them.

| Examples                | Structure     | Notes                                                                    |
|-------------------------+---------------+--------------------------------------------------------------------------|
| ~#\A~, ~#\z~, ~#\space~ | ~<character>~ | A Bard implementation may support several different Character structures |

*** Maps

Maps are data structures that associate *keys* with *values*. The ~Map~ class comprises several structures that map keys to values with different storage and performance characteristics.

Some maps are mutable; others are immutable.

| Examples                       | Structure  | Notes                                                     |
|--------------------------------+------------+-----------------------------------------------------------|
| ~{}~, ~{:name "Fred" :age 35}~ | ~<wb-map>~ | Bard supports several mutable and immutable types of maps |


*** Functions 

Functions are operations that select methods to apply based on an examination of the values of their arguments. You can create a function using the ~function~ special form, but until you add methods to it, it cannot actually compute anything.

Following is an expression that creates a named function and its input and output classes:

#+BEGIN_SRC lisp
  (function foo Bar -> Baz)
#+END_SRC

*** Methods

The special form named ~^~ ("caret" or "lambda") constructs a *method*, also known as a *monomophic function*. A method is a procedure that can be applied to some sequence of values to compute a result.

The most common use of methods is as the code that a specialized function actually executes when it matches the attributes of some set of inputs, but you can also construct and apply methods directly.

Following is an expression that creates a method that squares its input:

#+BEGIN_SRC lisp
  (^ [x] (* x x))
#+END_SRC

** Naming Conventions
*** Constants
*** Special Variables
*** Classes
*** Structures
*** Protocols

** Operations
*** Function calls
*** Syntax Forms
    A *syntax form* is a special form whose evaluation rules give it a special syntax, different from the normal function-call syntax.
*** Returning multiple values
*** Binding variables

** Packages
** Defining Protocols and Operations
** Defining Structures
** Assignment
** Flow of Control
** Built-in Protocols

*** Addressing
Operations on resource names and identifiers.

*** Comparing
Testing values for equality, equivalence, and sort order.

*** Converting
Constructing values of one type that are in some sense equivalent to values of another type. Alternatively, copying values from one type to another.

*** Creating
Constructing values from structures.

*** Listing
Operations on sequences of values.

*** Macros
Macros defined by Bard.

*** Mapping
Operations on mappings from keys to values.

*** Pairing
Operations on paired values.

*** Printing
Printing output.

*** Reading
Reading input.

*** Serializing
Converting values to a form that can be transported and stored outside the bard runtime, and converting values in such forms back into live Bard data in the runtime.

*** Streaming
Operations on objects that produce or consume values.

*** Tapping
Operations that convert values to streams.

*** TextProcessing
Operations on text strings.

*** Typing
Operations on types and operations on values that produce types.
