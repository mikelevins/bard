#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/asciidoctor.css" />
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./css/styles.css" />
#+OPTIONS: toc:nil
#+OPTIONS: num:1
#+OPTIONS: ^:nil
#+TITLE: bard 0.7

bard 0.7 is the seventh major iteration of design and implementation
of the Bard programming language. Bard is intended to be an
old-fashioned Lisp in the sense that it fully embraces interactive
programming and unrestricted malleability. This version of the
implementation also shoots for the kind of easy portability of source
and object code represented by old-fashioned Smalltalk environments,
using a compiler to a platform-agnostic bytecode format and a portable virtual machine.

Bard 0.7 also embraces more recent developments in
programming-language design, including a functional-first language
with immutable-first datatypes, protocol-oriented programming, and
support for internet protocols and widely-used data formats.

Finally, Bard is intended to be a small language with a relatively
simple surface. This document records my progress toward that goal.

* Data

Bard 0.7 offers the following built-in datatypes:

| Type name | Description                                                                       |
|-----------+-----------------------------------------------------------------------------------|
| Null      | The type of ~nothing~.                                                            |
| Boolean   | ~true~ or ~false~. ~nothing~ is also logically false.                             |
| Number    | Any numeric value.                                                                |
| Text      | A text string.                                                                    |
| List      | A sequence of values.                                                             |
| Map       | A mapping from keys to values.                                                    |
| Operation | A value that can be applied to some number of argument forms to compute a result. |
| Structure | A blueprint for constructing values.                                              |

* Protocols, Types, Classes, and Structures

A Bard *type* is either a *class* or a *structure*.

A *structure* is a recipe for assembling data into a value. Bard defines a small set of *built-in structures*, including concrete representations of all the types listed in the previous section. It also defines a set of *operations* that you can use to define your own structures.

A structure can be *instantiated*--that is, it can be used to create values. Values created from a structure are said to be *instances* of that structure, and they belong to the *type* that the structure represents.

A *class*, on the other hand, is a named collection of types. Most classes are defined to fulfill one or more roles in a *protocol*. 

A *protocol* is a defined set of *operations* and *variables*. Operations accept input values and produce output values. A protocol can declare abstract types for those inputs and outputs. The abstract types thus defined are *classes*.

In Bard, a class is simply the name of a role in one or more protocol functions. It does not specify any internal structure or any taxonomic relationship to any other type. A class need not have any instances at all.

The most common way to make a value into an instance of a class is by *specializing* a protocol function to operate on that value. If there's a method of a function specialized for a value, then the value's structure belongs to the corresponding class declared by the function's definition.

For example, if I declare a function like this:

#+BEGIN_SRC lisp
  (function foo Bar -> Baz)
#+END_SRC

then I have implicitly created the function ~foo~ and the classes ~Bar~ and ~Baz~. If I now *specialize* ~foo~ for some input structure, like this:

#+BEGIN_SRC lisp
  (define method (foo bar)
    with {bar (a <small-integer>)}
    ...
  )
#+END_SRC

then I have implicitly declared that ~<small-integer>~ is a *member* of the ~Bar~ class. If I now call ~foo~ with an instance of ~<small-integer>~, like so:

#+BEGIN_SRC lisp
  (foo 15)
#+END_SRC

then Bard finds the method that I defined above and applies it.

* Operations

An *operation* is a value that can be applied to some sequence of
expressions to compute a result. There are four kinds of operations:

- *special forms:* *Special forms* are built into the Bard system and may follow their own rules of evaluation.
- *functions:* A *function* is a polymorphic operator that evaluates its arguments, examines the results, and chooses a *method* to apply to those values.
- *methods:* A *method* is a monomorphic operator that applies a body of bard expressions to its input parameters to compute a result. Methods are commonly applied by functions, but may also be referenced and applied directly.
- *macros:* A *macro* is an *rexpression rewriter*. When you evaluate a macro expression, the entire expression is passed to the body of Bard code given by the macro's definition. That body of Bard code operates on the expression to compute a new expression. Bard then evaluates that new expression as if it had been the expression that was originally called. Bard programmers may use macros to define syntax extensions to Bard.

* The Bard Runtime

Bard 0.7 is a virtual machine that executes portable bytecode. It supports compiling Bard source code, in the form of S-expressions to a bytecode format called *bardo*. It may in the future also support compiling bardo to native machine code.

* Lexical Syntax

** Literal Values
*** Named Constants

*Named constants* are *names* that are defined in all lexical contexts, and that always refer to the same value. N of them are defined by the Bard language:

| Name      | Description                     |
|-----------+---------------------------------|
| nothing   | The empty list, set, or map.    |
| true      | The Boolean true value.         |
| false     | The Boolean false value.        |
| undefined | The absence of any useful value |
|           |                                 |


*** Numbers
*** Names
*** Lists
*** Text strings
*** Characters
*** Maps
*** Functions and Methods

** Naming Conventions
*** Constants
*** Special Variables
*** Classes
*** Structures
*** Protocols

** Operations
*** Function calls
*** Syntax Forms
    A *syntax form* is a special form whose evaluation rules give it a special syntax, different from the normal function-call syntax.
*** Returning multiple values
*** Binding variables

** Packages
** Defining Protocols and Operations
** Defining Structures
** Assignment
** Flow of Control
** Built-in Protocols
*** Addressing
*** Comparing
*** Converting
*** Creating
*** Listing
*** Macros
*** Mapping
*** Pairing
*** Printing
*** Reading
*** Serializing
*** Streaming
*** Tapping
*** Text-Processing
*** Typing
