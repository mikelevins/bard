#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/asciidoctor.css" />
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./css/styles.css" />
#+OPTIONS: toc:nil
#+OPTIONS: num:1
#+OPTIONS: ^:nil
#+TITLE: bard 0.7

bard 0.7 is the seventh major iteration of design and implementation
of the Bard programming language. Bard is intended to be an
old-fashioned Lisp in the sense that it fully embraces interactive
programming and unrestricted malleability. This version of the
implementation also shoots for the kind of easy portability of source
and object code represented by old-fashioned Smalltalk environments,
using a compiler to a platform-agnostic bytecode format and a portable virtual machine.

Bard 0.7 also embraces more recent developments in
programming-language design, including a functional-first language
with immutability-first datatypes, protocol-oriented programming, and
support for internet protocols and widely-used data formats.

Finally, Bard is intended to be a small language with a relatively
simple surface. This document records my progress toeard that goal.

* Data

Bard 0.7 offers the following built-in datatypes:

| Type name | Description                                                                       |
|-----------+-----------------------------------------------------------------------------------|
| Null      | The type of ~nothing~.                                                            |
| Boolean   | ~true~ or ~false~. ~nothing~ is also logically false.                             |
| Number    | Any numeric value.                                                                |
| Text      | A text string.                                                                    |
| List      | A sequence of values.                                                             |
| Map       | A mapping from keys to values.                                                    |
| Operation | A value that can be applied to some number of argument forms to compute a result. |
| Structure | A blueprint for constructing values.                                              |

* Protocols, Types, Classes, and Structures

A Bard *type* is either a *class* or a *structure*.

A *structure* is a recipe for assembling data into a value. Bard defines a small set of *built-in structures*, including concrete representations of all the types listed in the previous section. It also defines a set of *operations* that you can use to define your own structures.

Structures are concrete blueprints for constructing values.

A *class*, on the other hand, is a collection of types that fulfill one or more roles in a *protocol*. A *protocol* is a defined set of *operations* and *variables*. Operations accept input values and produce output values. A protocol can declare abstract types for these inputs and outputs. Those abstract types are *classes*.

In Bard, a class is just the name of a role in one or more protocol functions. It does not specify any internal structure or any taxonomic relatinship to any other type. A class need not have any instances at all.

The most common way to make a value into an instance of a class is by *specializing* a protocol function to operate on that value. If there's a method of a function specialized for a value, then the value's structure belongs to the corresponding class declared by the function's definition.

For example, if I declare a function like this:

#+BEGIN_SRC lisp
  (function foo Bar -> Baz)
#+END_SRC

then I have implicitly created the function ~foo~ and the classes ~Bar~ and ~Baz~. If I now *specialize* ~foo~ for some input structure, like this:

#+BEGIN_SRC lisp
  (define method (foo bar)
    with {bar (a <small-integer>)}
    ...
  )
#+END_SRC

then I have implicitly declared that ~<small-integer>~ is a *member* of the ~Bar~ class. If I now call ~foo~ with an instance of ~<small-integer>~, like so:

#+BEGIN_SRC lisp
  (foo 15)
#+END_SRC

then Bard finds the method that I defined above and applies it.

* Operations

* The Bard Runtime

