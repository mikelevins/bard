Bard

Every expression is one of:

  - a literal
  - an application

Every value is one of:

  - an atom
  - a map

An atom is one of:

  - nothing
  - true or false
  - a number
  - a cell
  - a structure

Cells

A cell is a container for a value. The contained value may be changed
by assignment. Bard Cell's are implemented so that mutation of cells
is atomic and thread-safe.

  (define $c (cell 0))
  $c => #<cell 0>
  (get $c) => 0
  (put! 1 $c)
  (get $c) => 1

Structures

A structure is a recursive datatype defined as either nothing or a
structure node. A structure node is either a leaf (a value) node, or
another structure. Structures are defined using symbolic constructors
and destructured using pattern-matching.

  (define Cons (structure (cons head tail)))
  (define $c (cons 1 2))
  (head $c) => 1
  (tail $c) => 2

Applying a structure constructor to appropriate inputs constructs a
structure-instance whose type is the structure. Applying the
constructor's parameters to such an instance returns the values passed
as parameters to the constructor.

Bard provides pattern-matching functions that can be used to
destructure structure instances.

Applications

An application is a sequence (a kind of map) in which the first
element is a map and the remaining elements form a key sequence for
the map. An application is evaluated by using the key sequence as
input to the lookup procedure for the type of map to compute zero or
more output values.

Maps

When applied, a map computes a set of output values from a sequence of
input keys, one set of values per key sequence. From most general to
most restrictive, the kinds of maps are:

- functions

  A function maps arbitrary sets of input parameters to expressions
  used to compute output values. Functions are the most flexible and
  dynamic type of maps: 

  - both the keys and the values are evaluated each time the function
    is applied

  - when the function is applied, the inputs are examined to determine
    a handler that is used to compute the outputs.

  - the set of handlers may be altered after the function is
    constructed

  - a function is a lexical closure over the environment in effect
    when the function was created

  (define serialize
          (function
            ([(x :: <Number>) (p :: <Port>)]
             (write x p))
            ([(x :: <Number>) (f :: <Filename>)]
             (serialize x (open-file f :direction :write)))))

  (define movies
          (function
            ([(title := "True Grit")] "Joel Coen")
            ([(title := "The Birds")] "Alfred Hitchcock")))

  (movies "The Birds") => "Alfred Hitchcock"
  (get movies "The Birds") => "Alfred Hitchcock"

If a function is not polymorphic in its arguments, the syntax for
creating it is simpler:

  (function [x] (* x x))

The more general syntax allows overloading on the number and type of
parameters. 

When a parameter is a sequence, the first element of the sequence is
the formal parameter name, and the remaining elements form a plist of
qualifiers. The keys recognized in the plist are:

  :: identifies the type of the parameter
  := identifies the required value (the match value for dispatching) of the parameter
  :default identifies a value to be used if the parameter is omitted.

- tables

  a table is similar to, but more restrictive than, a function.

  - a table's keys and values are evaluated and fixed at
    creation time

  - a table is immutable; you can use a table as an
    input to create a new table, but you cannot alter an
    table once created.

  - when a table is applied to a set of inputs, the set of
    inputs is matched against the table's keys to determine the
    value to be returned

  (define *movies*
          (table
            "True Grit" "Joel Coen"
            "The Birds" "Alfred Hitchcock"))

  (*movies* "The Birds") => "Alfred Hitchcock"
  (get *movies* "The Birds") => "Alfred Hitchcock"

- records

  A record is like a table whose keys must be symbolic names

  (define *movies*
          (record
            True-Grit "Joel Coen"
            The-Birds "Alfred Hitchcock"))

  (*movies* 'The-Birds) => "Alfred Hitchcock"
  (get *movies* 'The-Birds) => "Alfred Hitchcock"

- sequences

  A sequence is like a table whiose keys must be taken from a
  contiguous sequence of monotonically-increasing integers starting
  with zero.

  (define *movies*
          (seq
            "True Grit"
            "The Birds"))

  (*movies* 0) => "True Grit"
  (get *movies* 0) => "True Grit"

- sets

  A set is like a table whose keys must each be unique, and
  whose values are either true or false. (For a member of the set, the
  value is true; for a non-member, it is false.)

  (define *movies*
          (set
            "True Grit"
            "The Birds"))

  (*movies* "The Birds") => true
  (get *movies* "The Birds") => true
  (get *movies* "Psycho") => false

