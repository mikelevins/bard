= bard 0.7
mikel evins
:toc: preamble
:toclevels: 2

bard 0.7 is the seventh major iteration of the Bard programming language. 

Bard is meant to be an old-fashioned Lisp: it fully embraces interactive programming and unrestricted malleability.

Version 0.7 also shoots for the kind of easy portability of source and object code that old-fashioned Smalltalk environments have. It compiles to platform-agnostic bytecode that runs on a portable virtual machine.

Bard is a functional-first language with immutable-first datatypes, protocol-oriented programming, and support for internet protocols and widely-used data formats.

Finally, Bard is intended to be a small language, no more complicated than necessary.

This document records my progress toward these goals.

== Overview

Bard is a Lisp; that is, it's a programming language in the long tradition of Lisp, and shares many features with older Lisps.

It's not a version of Common Lisp or Scheme or Clojure, or of any Lisp that came before it. Its design is influenced by many of those preceding Lisps, but it's not intended to be a version or dialect of any of them.

Bard is intended to be an interactive language. It's designed to be convenient for a programmer who prefers to work by starting up an interactive environment and teaching it, expression by expression, how to be a program. It has other characteristics that reflect things I've learned and appreciated from previous Lisps, and from other languages, especially functional languages. Its overriding rule, though, is to work well and comfortably as an interactive programming environment.

== Values

=== Named Constants

[cols="1m, 3",options="header",]
.The named constants
|===
|Name      |Description
|undefined |The absence of any useful value
|nothing   |The empty list
|true      |The Boolean true value.
|false     |The Boolean false value.
|===

=== Literal values

[cols=".<3m,.^1m,.>4",options="header",]
.Literal values
|===
|Examples                       |Type      |Description
|100, 2/3, 12.34, #xFF, #b1011  |Number    |Numeric values
|Blue                           |Symbol    |Names of language elements like types, variables, and functions
|Foo:                           |Keyword   |Keys in records and similar uses. Keywords are symbols that always evaluate to themselves
|@"http://barcode.net"          |URI       |File names and other resource identifiers
|[1 2 3]                        |List      |Sequences of values
|{name: "Fred" color: "Orange"} |Map       |Finite maps from keys to values
| #\A, #\space, #u+A9FF         |Character |Text characters
| "Some text"                   |Text      |Text strings
|(^ [x] (* x x))                |Method    |Basic procedures
|===

== Types

=== Structures

----
(define <boolean> (enumeration false true))
(define <point> (record {x: Integer y: Integer}))
(define <ostype> (tuple element-type: <byte> count: 4))
(define <the-integer-5> (equals 5)) ; singleton type
----

== Protocols

=== Defining Protocols

----
bard> (define protocol CartesianPoints
       {x-coordinate (function CartesianPoint)
        y-coordinate (function CartesianPoint)
        distance (function CartesianPoint CartesianPoint)})
CartesianPoints

bard> (functions CartesianPoints)
[[x-coordinate . (function CartesianPoint)]
 [y-coordinate . (function CartesianPoint)]
 [distance . (function CartesianPoint CartesianPoint)]]

bard> (define <2d-point> (record {x: Integer y: Integer}))
<point>

bard> (define method (x-coordinate p)
       where: {p: <2d-point>}
       (.x p))
x-coordinate

bard> (def $p (make <2d-point> x: 100 y: 200))

bard> (.x $p)
100

bard> (instance? $p <2d-point>)
true

bard> (instance? $p CartesianPoint)
true

bard> (represents? <2d-point> CartesianPoint)
[[x-coordinate . (function CartesianPoint)]]

bard> (represents? <string> CartesianPoint)
nothing

bard> (type CartesianPoint)
<class>

bard> (type <2d-point>)
<record>

bard> (type <the-integer-5>)
<singleton>
----

=== Built-in Protocols

[cols=".<1m,.^3m",options="header",]
.Built-in protocols
|===
|Name      |Description
| Bard | System and runtime operations
| Comparing | Equality and comparison
| Converting | Constructing values of one type from values of another
| Creating | Constructing values
| Generators | Converting expressions and procedures to streams
| Iteration | Repeating computations and traversing structures
| Lists | Ordered sequences of values
| Macros | Macros defined by Bard and tools for defining macros
| Maps | Finite maps from keys to values
| Math | Arithmetic and other mathematical operations
| Messaging | Sending and receiving data across processes
| Names | Values used to name, label, and identify things
| Network | Operations on network resources
| Pairs | Pairs of values
| Printing | Rendering Bard values as text
| Processes | Creating and managing local and remote processes
| Protocols | Defining and operating on protocols
| Reading | Consuming and parsing data from streams and files
| Serializing | Converting Bard values to and from external data formats
| Streams | Values that produce or consume sequences of other values
| Taps | Converting values to streams
| Text | Text-processing tools
| Types | Operations on Bard types
|===

