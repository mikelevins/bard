= bard 0.7
mikel evins
:toc: preamble
:toclevels: 2

bard 0.7 is the seventh major iteration of the Bard programming language. Bard is a programming language designed mainly to make me happy in my work.

Bard is meant to be an old-fashioned Lisp: it fully embraces interactive programming and unrestricted malleability.

Version 0.7 also shoots for the kind of easy portability of source and object code that old-fashioned Smalltalk environments have. It compiles to platform-agnostic bytecode that runs on a portable virtual machine.

Bard is a functional-first language with immutable-first datatypes, protocol-oriented programming, and support for internet protocols and widely-used data formats.

Finally, Bard is intended to be a small language, no more complicated than necessary.

This document records my progress toward these goals.


== The Bard Runtime

Bard 0.7 is a virtual machine that executes portable bytecode. It compiles the Bard source language, which is made up of *s-expressions*, to bytecode, and executes the bytecode on the virtual machine. Bard bytecode, called *bardo*, is independent of any particular hardware platform, and the virtual machine is designed to be easy to port. It's written in Gambit Scheme and can be compiled for any platform that Gambit can target.

I plan to eventually support compiling bardo to native code, and to support execution of both bytecode and native code in the same runtime.

== What Bard Looks Like

Bard is a Lisp. Everything in Bard is an expression, and function calls are written as lists.

 Here's a short function that reads nonempty lines from a file:

....
(define method (read-samples path)
  :where {path <uri>}
  (filter (complement empty?)
          (tap :lines path)))
....

== Interactive Programming

Bard is an *interactive* language. It's designed to work by prompting you for expressions. You type expressions at the prompt, Bard reads and evaluates the expressions, performs whatever computation they require, and prints the resulting values.

....
bard.user> "Hello!"
"Hello!"

bard.user> (* 2 3)
6

bard.user> (bard.time:now)
#<bard.time:timestamp> "2020-12-26T04:31:01.985510Z"
....

Bard embraces an old-fashioned idea of Lisp programming in which the whole language is inspectable and malleable, all language and system features are available from the interactive prompt, and the assumption is that you'll write programs by starting the Bard system and changing it interactively, one expression at a time, until it becomes the program you want.

== Named Constants

The simplest expressions you can enter at the Bard prompt are values, and the simplest values to enter are the *named constants*.

There are four of them:

[cols="1m, 3",options="header",]
|===
|Name      |Description
|nothing   |The empty list, set, or map.
|true      |The Boolean true value.
|false     |The Boolean false value.
|undefined |The absence of any useful value
|===

== Literals

After the four named constants, the simplest expressions are *literals*. A *literal* is an expression that represents a value. Bard offers the following types of literals:

[cols=".<1m,.^3m,.>3",options="header",]
|===
|Type      |Examples                                   |Description
|Symbol    |method, bind, List                         |The names of functions, variables, and so on
|Keyword   |:where, :name, :if-exists                   |Keys in records and similar uses
|URI       |@"file:///tmp/db", @"https://bardcode.net" |Files and network resources
|Number    |0, 1, -2, 3/4, 5.6                         |Numeric value.
|Text      | "", "Some text"                           |Text strings.
|List      |[1 2 3]                                    |A sequence of values.
|Map       |{:name "Fred" :color "Orange"}             |A mapping from keys to values.
|Function  |(function foo Bar -> Baz)                  |A polymorphic procedure
|Method    |(^ [x] (+ x 1))                            |A monomorphic procedure
|===

You can create most of these kinds of values by typing them at the prompt.

....
bard.user> 41/19
41/19

bard.user> "Hello, world!"
"Hello, world!"

bard.user> [1 2 3 4 5]
[1 2 3 4 5]
....

=== Symbols

Symbols are a special case. They're used to name *variables*--that is, names that stand for values. If you type in a symbol that happens to be the name of a variable, then Bard returns the value of that variable.

....
bard.user> List
List

bard.user> *package*
bard.user
....

If you type in a symbol that has not been defined as a variable, then Bard tells you that its value is undefined.

....
bard.user> not-a-variable
undefined
....

If you want to refer to a symbol itself, and not to the value it stands for, you must tell Bard not to evaluate it. You can do that by *quoting* it.

....
bard.user> 'not-a-variable
not-a-variable
....

The quote tells Bard, "Don't evaluate this expression. Just return the expression itself."

Besides symbols, there are two other kinds of names: Keywords and URIs. When you refer to a keyword or a URI, its value is always itself. The only names that require special treatment are symbols.

== Variables

*Variables* are *names* that stand for *values*. For example, the named constants are variables.

Variables may be *mutable* or *immutable*. You can change the value of a *mutable* variable, but not that of an *immutable* one. The named constants are immutable variables.

A variable may be *special* or *lexical*.

A *special variable*'s name refers to the same variable no matter where it's referenced. If a piece of code in one procedure changes a special variable, then the code in all other procedures see the new value.

By contrast, the name of a *lexical variable* refers to the same variable only in the *lexical scope* where it's created. The same name can refer to a completely different variable in a different procedure, and setting the value of one has no effect on the value of the other.

=== Special Variables

You can create a special variable using a *defining form*, like `def`:

....
bard.user> (def *x* 1000)
*x*

bard.user> *x*
1000
....

You can change the value of `*x*` by *assigning* a new one to it:

....
bard.user> (set! *x* 1001)
1001

bard.user> *x*
1001
....

Besides `def`, there are several other defining forms that can create special variables.

=== Lexical Variables

You can create exical variables using *binding forms*. The most commonly-used binding form is `bind`:

....
bard.user> (bind [(x 10)]
             (+ x 1))
11
....



=== Definitions

*Definitions* are procedures that create special variables.

`def`
`define`


=== Lexical variables

It's generally not a good practice to make variables accessible everywhere. The more places a variable is referenced, the more places its value might be changed, and the more places you have to check when keeping track of the code that reads and writes it.

A *lexical variable* is a variable that is accessible only in a certain bounded body of code, called its *lexical environment*. Most variables should be lexical rather than special variables, because they're easier and safer to manage that way.

Bard offers several ways of creating lexical variables. The two most basic are the `bind` special form and *parameter bindings*.

=== The `bind` special form

The `bind` special form creates lexical variables. For example:

....
> (bind [(x 2)]
    (+ x 1))
3
....

In this example, `bind` creates a lexical variable named `x` and binds it to `2`. The body of the `bind` form then refers to that variable in the expression `(+ x 1)`, returning the sum.

`bind` can create more than one variable:

....
> (bind [(x 2)
         (y (+ x 1))]
    (+ x y))
5
....

Variables that appear later in the sequence of bindings can refer to those that appear earlier, as this example shows.

=== Parameter bindings

*Parameter bindings* are lexical variables that are created when an operation is called with arguments.

Consider a simple method that returns the greater of two numbers:

....
(^ [x y] (max x y))
....

This method creates the lexical variables `x` and `y`. In the body of the method, `x` and `y` take on the values of the two arguments passed to the method.

Let's capture the method in a special variable and call it:

....
> (def bigger (^ [x y] (max x y)))
(^ [x y] (max x y))
> (bigger 2 3)
3
....

When we apply `bigger` to 2 and 3, `x` is bound to the value `2` and `y` is bound to the value `3`. The method evaluates its body with the variables bound to those values and returns the greater number.

== Types

All Bard values have *types*. A Bard *type* is either a *structure* or a *class*.

*Structures* are concrete blueprints for constructing values. 

*Classes* are named collections of types.

Bard gives you tools for defining your own structures and classes.

A *structure* describes the data layout of a set of values. Bard defines a set of *built-in structures*, including concrete representations of all the types listed in the "Literals" section. It also defines a set of *procedures* that you can use to define your own structures.

Structures can be *instantiated*â€“that is, you can use structures to create values. Such values are called *instances* of the structures that created them.

A *class*, on the other hand, is an abstract type, a named collection of other types.  It has no internal structure, and no direct instances. If a value is an instance of a class, that's because the value's structure is a member of the class.

All of the types listed in the "Literals" section are classes. For example, `List` is a class. An example of a structure that belongs to the `List` class is `<vector>`. You can't instantiate `List` directly, but you can instantiate `<vector>`, and any instances you create are also instances of `List` by virtue of the fact that `<vector>` is a member of the `List` class.

For example:

....
bard.user> (def x (vector 1 2 3 4))
(1 2 3 4)

bard.user> (type x)
<vector>

bard.user> (instance? x <vector>)
true

bard.user> (instance? x List)
true
....

=== Default Structures

For each literal data syntax there is a *default structure* defined by the implementation. The *default structure* is the structure that Bard uses to construct instances from literal expressions if you don't specify a different one. When you type a literal in at the Bard prompt, the value you get back will be an instance of the default structure for that literal's class.

The default structures defined by Bard are as follows:

[cols=".<1m,.^3m",options="header",]
|===
|Type      |Default structure                                 
|Undefined |<undefined>
|Null      |<null>
|Boolean   |<bool>
|Integer   |<small-integer>, <big-integer>
|Decimal   |<double-float>
|Rational  |<ratio>
|Name      |<symbol>, <keyword>, <uri>
|Text      |<string>
|List      |<cons>
|Map       |<dict>
|Function  |<function>
|Method    |<bytecode-method>
|===

In some of these cases more than one default structure is listed. That's because in some cases the default structure depends on the value.

For example, both `1` and `99999999999999999999` are of type `Integer`, but the second one is too large to be represented by a `<small-integer>`, which is the default structure for integers of lesser magnitude. Bard uses `<big-integer>` as the value for the greater number.

Similarly, the default structure for `Name` is `<symbol>`, unless the
syntax of the literal indicates `<keyword>` or `<uri>`.

=== Mutability

*Mutable* variables and data structures are those whose values can be changed. *Immutable* ones cannot.

All of the basic built-in data types provide *immutable* implementations. Many of them also provide *mutable* implementations, but in general, good Bard style calls for the use of *immutable* structures unless there's a compelling reason to use a mutable variant.

There's often a performance penalty for using immutable structures, because you can't change their contents. If you need a version of an immutable structure with a different value in it somewhere then you must make a new copy.

Even so, it's often worth the cost. Because you can't change the contents of an immutable structure after it's created, it's immune to bugs caused by problems with concurrent updates.

In many cases the performance penalty for using immutable structures is less than you might expect, because new structures can share structure with existing ones, and because there are algorithms with good amortized complexity for creating updated copies of structures.

Bard provides mutable variables and structures for cases where they're really needed, but Bard style prefers the use of immutable data whenever it's practical.


=== Numbers

*Numbers* are numeric values including integers, ratios, and decimal numbers. Bard 0.7 defines several built in numeric structures. Following are several examples.

[cols="m,m,",options="header",]
|===
|Values     |Structure       |Notes
|0, 100, -2 |<small-integer> |Integers that can be conveniently represented by a machine word
|9999999999999999999 |<big-integer> |Unlimited-precision integers
|2/3 |<ratio> |Fractional number represented by ratios of integers
|0.1 |<double-float> |Decimal numbers represented as floating-point values
|===

=== Names

*Names* are values that Bard uses to label elements of the language like functions, variables, and special forms, or to represent certain kinds of name-like data, such as files and network resources. There are three kinds of names:

[cols="1,1m,1m,4",options="header",]
|===
|Kind |Examples |Structure |Notes
|Symbol|foo, Bar, <symbol> |<symbol> |Names used for variables, functions, and so on. Symbols are contained in packages.
|Keyword|:type, :Family |<keyword> |Names that always evaluate to themselves. Keywords are contained in the `bard.keyword` package.
|URI|@"file:///tmp/",@"https://barcode.net" |<uri> |Universal Resource Identifiers and URLs, URIs are contained in the `bard.uri` package.
|===

=== Lists

Lists are sequences of values that are addressable by index. There are several structures that provide different implementations of the `List` class with different performance characteristics. The `Listing` protocol provides numerous procedures that work on Lists.

Some List structures are mutable; others are immutable.

[cols="m,",options="header",]
|===
|Examples  |Notes
|[1 2 3]  | A list of integers
|[[1 2 3]["one" "two" "three"]]  | A list of lists
|"A list of Characters"  | Text strings are also lists (see "Text Strings," below)
|===

Bard always prints a list using parentheses rather than square brackets. We can see this when we enter lists at the Bard prompt:

....
> [1 2 3]
(1 2 3)
....

Square brackets provide a convenient way to write a list when you don't want it to be treated as a function call.

....
> (1 2 3)
ERROR: 1 is not a procedure!
....

You can tell Bard not to evaluate a List in parentheses using a *quote*:

....
> '(1 2 3)
(1 2 3)
....

...or you can use square brackets as a shorthand for the List constructor.

....
[1 2 3]
....

means the same thing as

....
(list 1 2 3)
....

The difference between quoting a list and using square brackets (or the `list` constructor) is that none of the elements of a quoted list are evaluated; all of the elements of a list in square brackets are evaluated.

Consider these three expressions:

....
bard.user> '(1 2 (+ 1 2) 4)
(1 2 (+ 1 2) 4)

bard.user> [1 2 (+ 1 2) 4]
(1 2 3 4)

bard.user> [1 2 [+ 1 2] 4]
(1 2 (#<primitive +> 1 2) 4)
....



=== Text Strings

Text strings, like `"Hello"`, are Lists of Characters. All of the procedures of the `Listing` protocol work on them, but they also participate in the `TextProcessing` protocol, which adds many procedures specialized for handling text.

Note that this does not mean that strings are implemented inefficiently as singly-linked-lists or some such data structure. Remember that `Text` and `List` are classes, not structures. Saying that a text string is a list of characters simply means that the structure that represents it supports the `Listing` protocol; it doesn't specify anything about its representation.

Like `List`, `Text` is a class, not a structure, and there may be several different structures that implement it.

=== Characters

Characters are the atomic elements of text strings. The class `Character` comprises the structures used to represent them.

[cols="1m,3",options="header",]
|===
|Examples  |Notes
|#\A, #\z, #\space  |Bard supports several different `Character` structures
|===

=== Maps

Maps are data structures that associate *keys* with *values*. The `Map` class comprises several such structures with different storage and performance characteristics.

Some maps are mutable; others are immutable.

[cols="2m,3",options="header",]
|===
|Examples |Notes
|{}, {:name "Fred" :age 35} |Bard supports several
mutable and immutable types of maps
|===

=== Functions

Functions are polymorphic procedures that examine their inputs, match them to methods, and apply the methods to the inputs.

....
bard.user> (def foo (function Bar -> Baz))
....

You can also write the above definition like this:

....
bard.user> (define function (foo Bar -> Baz))
....

The second form stands out a bit more in a file full of code, but explicit function definitions like this are somewhat uncommon because both `define method` and `define protocol` forms define functions implicitly, and they're much more commonly used.

Besides saying that `foo` is a function, the above expressions also say that `Bar` and `Baz` are classes whose members can be inputs and outputs of `foo`.

Defining a function doesn't say how it works or what values it accepts or produces. It only defines some abstract function and classes that may be given concrete meaning by *specializing* the function.

*Specializing* a function means defining a *method* that applies to some concrete set of input values. The next section describes specialization in more detail.

=== Methods

The special form named `^` ("caret" or "lambda") constructs a *method*. A method is a procedure that can be applied to some sequence of values to compute a result. Unlike functions, methods do not examine their inputs before choosing the code to apply to them. A method simply applies its body to its arguments.

Following is an expression that creates a method:

....
(^ [x] (* x x))
....

This nameless method accepts one parameter, called `x`, and multiplies it by itself.

Although you can construct methods this way and use them directly, the most common way to create and use them is by using the special form `define method` to *specialize* a function:

....
(define method (add x y)
  :where {:x <small-integer>
         :y <small-integer>}
  (+ x y))
....

`define method` creates a method and adds it to the named function--creating the function as well, if it doesn't already exist. It also adds the rule that defines the requirements that the arguments must meet in order for the method to apply to them. 

This definition says that `add` accepts two arguments, and they must be instances of the structure `<small-integer>`. If we pass arguments of any other number or type then this method is not applied.

We can add another method to the same function, matching a different set of structures:

....
(define method (add x y)
  :where {:x <string>
         :y <string>}
  (cat x y))
....

The `<small-integer>` version of `add` uses the addition procedure on its arguments. The `<string>` version instead uses `cat`, which concatenates the strings.

We can add more methods, matching any structures we like in any combination. The defined methods will be called when we pass parameters that match the constraints.

We can also specify other matching rules. For example, the following method matches only when the parameters are exactly 4 and 2:

....
(define method (add x y)
  :where {:x (exactly 4)
         :y (exactly 2)}
  (print "You have discovered the answer to life, the universe, and everything: 42!"))
....

The `with` clause defines the matching rule for the parameters. If it's a map, as in these examples, then the keys are parameter names and the values are tests that the parameters must satisfy. If the tests are just types, then the rule is satisfied when the value passed for each parameter belongs to the corresponding type.

`(exactly x)`, on the other hand,  is a test that returns true when a parameter is equal to `x`, so this method is matched only when `x` is `4` and `y` is `2`.

Other matching rules are also supported.


== Operations

An *operation* is an expression that calls a *procedure*.

Here are a few examples of operations:

....
(+ 2 3 4)

(bind [(x 1)
       (y 2)]
 (* x y))

(set! (.x pt) 100)
....

Bard expresses an operation as a List whose first element is a procedure, and whose remaining elements are the procedures' arguments. Argument expressions may themselves be operations.

Different types of procedures have different rules of evaluation for argument expressions. *Functions* and *methods* evaluate argument expressions before passing them to the procedure.

A *macro* expression passes the whole expression to the rule given by the macro's definition; that rule rewrites the expression before it's evaluated, and the rule determines whether and how the arguments are evaluated.

*Special forms* are built into the Bard runtime, and each one has its own rules of evaluation.

For example:

....
(def x (+ 2 3))
....

`def` defines a *special variable*. It evaluates its second argument, but not its first. The above example creates a special variable named `x` whose initial value is `5`.

....
(if nothing
  (/ 1 0)
  (print "No worries!"))
....

`if` evaluates its first argument. If the value is true then it evaluates its second argument; if not, it evaluates its third argument. In the above example, if `nothing` were true then the expression would signal a divide-by-zero error. Because it's not, it instead prints "No worries!". The division by zero is never evaluated.

== Naming Conventions

Bard uses some naming conventions that are not strictly enforced by the compiler, but which are strongly encouraged for the sake of clarity.

=== Constants

Constants are read-only variables. By convention, their names start and end with `+`.

....
+Pi+
+C+
+fine-structure-constant+
....

*Constants* are read-only variables.

=== Special Variables

*Special variable* are global variables--more or less. By convention, their names start and end with `*`.

....
*window*
*process-id*
*epoch*
....

=== Protocols

A *protocol* is named collection of related procedures and variables. You can think of a protocol as a set of tools for carrying out some activity. The convention is to choose a name that describes the activity, and to capitalize the name: `*Listing*`, for example, or `*Ordering*`.

....
Listing
Mapping
Streaming
....

=== Classes

A *class* is a named collection of *types*. Types, remember, may be either structures or classes, so classes may in principle be members of other classes, though it's more common for members of classes to be structures.

The convention is to name a class with a capitalized noun. The noun should reflect the role the type is intended to fill.

....
List
Map
Stream
....

=== Structures

A *structure* is a concrete description of how values are arranged to form a new type of value. Structures may be directly instantiated by allocating space to hold their constituent values and filling in the space with data.

By contrast, classes can't be instantiated in this way. Because a class is just a name for a set of other types, it can be instantiated only indirectly. The only way to make an instance of a class is to make an instance of one of it member structures.

For structures, the convention is to name them with nouns that describe their concrete representations, spell the nouns in lower case, and enclose the name in angle brackets ("<>").

....
<character>
<cons>
<null>
<small-integer>
....

=== Predicates

*Predicates* are procedures of one argument that return true or false.

The convention is to end the names of predicates with question marks ("?").

....
empty?
even?
number?
....

=== Accessors

An *accessor* is a procedure that returns the value of a field in a value. Bard creates accessors automatically when you define structures, but you can customize their names if you wish.

If a slot is *mutable* then the accessor may also be used with the `set!` special form to replace its value.

The convention is to start the name of an accessor with a dot (".").

....
.active?
.name
.width
....

=== Mutators

A *mutator* is a procedure that replacing the value in a slot, or that destructively rearranges the data in an object (for example, a sort that rearranges the the contents of an array in-place).

The convention is to end the names of mutators with exclamation points ("!").

....
replace!
reverse!
set!
.set-name!
....

== Structures

There are three kinds of structures:

- *records* are structures made of named slots.
- *tuples* are structures made of sequences of elements identified by indexes.
- *enumerations* are structures defined as one or more named values, optionally with one or more data parameters associated with the names.

You may optionally specify type constraints on the elements of structures.

This section describes how to define and instantiate structures, and how to operate on them.

=== Records

=== Tuples

=== Enumerations

== Protocols

Protocols define collections of related procedures and variables designed to support particular activities. Examples of Bard protocols include `Comparing`, `Converting`, `Creating`, `Listing`, `Mapping`, `Printing`, `TextProcessing`, and so on. You can think of a protocol as a collection of tools suited for some chosen purpose, and the naming convention reflects that usage.

Most Protocols are named with the suffix `-ing`, but not all are. `Macros` and `System` are two protocols that break this stylistic rule.

This section describes how to define and use protocols. The "Built-in Protocols" section below describes the protocols that Bard provides out of the box.

== Procedures

A *procedure* is a value that can be applied to some sequence of expressions to compute a result. Bard offers four types of procedures:

* *special forms* are procedures that are built into Bard. Each special form can follow its own rules of evaluation.
* *functions* are *polymorphic procedures:* a function examines the values of its arguments and chooses a suitable *method* to apply according to its *dispatch rule*.
* *methods* are *monomorphic procedures:* a method applies the expressions in the body of its definition to the values of its arguments, and returns the result.
* *macros* are rewrite rules. A macro definition is a procedure that accepts an expression and rewrites it to another expression. When execute a macro expression the whole expression is passed to the code in thee macro's definition. That code rewrites the macro call, then evaluates the rewritten expression. Writing macors is a way to extend the syntax of the language.

=== Special Forms

Users cannot define special forms.

=== Functions

=== Methods

=== Macros


== Returning multiple values

The special form `values` returns multiple values:

....
> (values 1 2 3)
1
2
3
....

The `bind` special form can bind variables to the multiple values returned by `values`:

....
> (bind [(x y z (values 1 2 3))]
    (* x y z))
6
....

If there are more variables than returned values, then the variables are bound to the returned values in order, and the extra variables are bound to `nothing`. If there are more values than variables, the extra values are ignored.

== Packages

Named objects in Bard are named by *symbols*. Symbols exist in *packages*. A *package* is a namespace containing a collection of symbols. 

A *fully-qualified symbol* is a symbol written with the name of the package that it belongs to, for example:

....
bard.core:bind
bard.core:define
bard.user:foo
....

=== Keywords

A special case is the `bard.keyword` package. In a fully-qualified name, the name of the `bard.keyword` package may be omitted.

In other words, writing

....
:foo
....

is exactly the same as writing

....
bard.keyword:foo
....

Symbols in the `bard.keyword` package are treateed specially: they always evaluate to themselves.

=== `\*package*`

Bard defines a special variable, `bard.core:*package*`, whose value is the *current package*. The *current package* is the package used to look up symbols whose names are not fully qualified.

For example, if `\*package*` is currently the package named `bard.core`, then `bind` is automatically interpreted to mean `bard.core:bind`.

Bard defines a `Packaging` protocol that provides a set of procedures and variables for working with packages.


== Assignment

== Flow of Control

== Conditions

== Built-in Protocols

=== Addressing

Operations on resource names and identifiers.

=== Comparing

Testing values for equality, equivalence, and sort order.

=== Converting

Constructing values of one type that are in some sense equivalent to values of another type. Alternatively, copying values from one type to another.

=== Creating

Constructing values from structures.

=== Listing

Operations on sequences of values.

=== Macros

Macros defined by Bard.

=== Mapping

Operations on mappings from keys to values.

=== Packaging

Operations on packages (namespaces).

=== Pairing

Operations on paired values.

=== Printing

Printing output.

=== Reading

Reading input.

=== Serializing

Converting values to a form that can be transported and stored outside the bard runtime, and converting values in such forms back into live Bard data in the runtime.

=== Streaming

Operations on objects that produce or consume values.

=== System

Tools for configuring, maintaining, and controlling Bard itself.

=== Tapping

Operations that convert values to streams.

=== TextProcessing

Operations on text strings.

=== Typing

Operations on types and operations on values that produce types.
