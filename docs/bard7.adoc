= bard 0.7
mikel evins
:toc: preamble
:toclevels: 1

bard 0.7 is the seventh major iteration of design and implementation of the Bard programming language.

Bard is intended to be an old-fashioned Lisp in the sense that it fully embraces interactive programming and unrestricted malleability. This version of the implementation also shoots for the kind of easy portability of source and object code represented by old-fashioned Smalltalk environments, using a compiler to a platform-agnostic bytecode format and a portable virtual machine.

Bard 0.7 also embraces more recent developments in programming-language design, including a functional-first language with immutable-first datatypes, protocol-oriented programming, and support for internet protocols and widely-used data formats.

Finally, Bard is intended to be a small language with a relatively simple surface.

This document records my progress toward these goals.

== Data

Bard 0.7 offers the following built-in basic datatypes:

[cols=".<1m,.^3m,.>3",options="header",]
|===
|Type name |Examples                                 |Description
|Anything  | 1, true, "hello"                        |Every possible value.
|Undefined |undefined                                |No useful value.
|Null      |nothing                                  |The empty collection.
|Boolean   |true, false                              |True and false. `nothing` is also logically false.
|Number    |0, 1, -2, 3/4, 5.6                       |Any numeric value.
|Text      | "", "Some text"                         |Text strings.
|List      |[1 2 3]                                  |A sequence of values.
|          |(+ 1 2 3)                                |Written this way, a List is treated as a function call
|Map       |{:name "Fred" :color "Orange"}           |A mapping from keys to values.
|Function  |(function foo Bar -> Baz)                |A polymorphic operator
|Method    |(^ [x] (+ x 1))                          |A monomorphic operator
|Structure |(record <point> {:x <float> :y <float>}) |A blueprint for constructing values.
|          |(tuple <ostype> [<byte> {:exactly 4}])   |
|          |(enum <primary-color> 'Red 'Green 'Blue) |
|===

== Types

A Bard *type* is either a *structure* or a *class*. *Structures* are concrete blueprints for constructing values. *Classes* are named collections of types.

A *structure* describes the structure of a family of values and the data that populate them. Bard defines a set of *built-in structures*, including concrete representations of all the types listed in the previous section. It also defines a set of *operators* that you can use to define your own structures.

A structure can be *instantiated*–that is, it can be used to create values. Values created from a structure are said to be *instances* of that structure, and they belong to the *type* that the structure represents.

A *class* is an abstract type, a name for a collection of other types.  It does not specify any internal structure or any taxonomic relationship to any other type. A class might be *empty*, with no members and no instances.

Most classes are defined to fulfill one or more roles in a *protocol*.

A *protocol* is a named set of *operators* and *variables*.  Operators accept input values and produce output values. A protocol can declare classes for those inputs and outputs. Until other types are made members of those classes, the classes are empty.

The most common way to make a type into an member of a class is by *specializing* a protocol function. If a function has a method that is specialized for a type on some parameter, then that type becomes a member of that parameter's class.

For example, suppose I define a function like this:

....
(function foo Bar -> Baz)
....

`foo` is now a function that takes one argument of type `Bar` and returns one value of type `Baz`. `Bar` and `Baz` are now classes. If these names were never used before in another function or class definition then they are empty–they have no members and no instances.

I can make the structure `<small-integer>` into a member of the class `Bar` by writing a method that specializes `foo` on it:

....
(define method (foo bar)
  with {bar <small-integer>}
  ...)
....

The `with` clause applies a *constraint* to the argument `bar`: its value must be an instance of `<small-integer>`.

To be more precise: `<small-integer>` is the constraint that `bar` must satisfy. If the constraint is a type, then the value of `bar` must be an instance of that type in order for this method to match the function call. Other constraints are also possible. For example, the constraint `(exactly 101)` means that `bar` has to be equal to 101, and the integer 101 (and only the integer 101) becomes a member of the `Bar` class.

`<small-integer>` is now a member of the `Bar` class. If I call `foo` with an instance of `<small-integer>`, like so:

....
(foo 15)
....

then Bard finds my method and applies it.

== Operators

An *operator* is a value that can be applied to some sequence of expressions to compute a result. There are four kinds of operators:

* *special forms* are built into the Bard system. Each special form can follow its own rules of evaluation.
* *functions* are polymorphic operators that evaluate their arguments, examine the results, and choose a *method* to apply according to the matching rules given by `define method` forms.
* *methods* are monomorphic operators that apply bard expressions to their input parameters to compute results. Methods are commonly applied by functions, but may also be referenced and applied directly.
* *macros* are rewrite rules. When you call a macro, the rule given by the macro's definition rewrites the call into a new expression and then evaluates that. Macros are generally used to add new syntax to Bard.

== The Bard Runtime

Bard 0.7 is a virtual machine that executes portable bytecode. It supports compiling Bard source code in the form of S-expressions to a bytecode format called *bardo*.

I plan to eventually support compiling bardo to native code, and to support execution of both bytecode and native code in the same runtime.

== Lexical Syntax

Bard's lexical syntax provides ways to write literal values of most of its built-in datatypes. For example:

[cols="1m,1m,4",options="header",]
|===
|Syntax    | Class |Description
|nothing   | Null  |The empty collection
|3.1415926 | Float |A floating-point number
|[1 2 3]   | List  |A list of integers
|===

The table gives the *class* of each value, but not the *structure*. When you write the lexical syntax for a value, Bard constructs and returns an instance of the *default structure* for that type. For example, the default structure for the `List` type is `<cons>`, so writing `[1 2 3]` returns a `<cons>`.

What if you want a different structure? You can write:

....
#:<vector> '(1 2 3)
....

which tells Bard you want it to return a `vector` instead. The syntax `#:<vector>` is shorthand for

....
(as <vector> [1 2 3])
....

Bard may rewrite this expression as a direct call to the `vector` constructor:

....
(vector 1 2 3)
....

Alternatively, you can of course also call the constructor yourself.

When you write a literal value, Bard constructs an instance of the default structure for the expression's class. If you want to ensure that the value belongs to some specific structure, then you must say so explicitly, as in the example above.

=== Named Constants

*Named constants* are *names* that are defined in all lexical contexts, and that always refer to the same value. Four of them are defined by the Bard language:

[cols="m,",options="header",]
|===
|Name      |Description
|nothing   |The empty list, set, or map.
|true      |The Boolean true value.
|false     |The Boolean false value.
|undefined |The absence of any useful value
|===

=== Numbers

*Numbers* are numeric values including integers, ratios, and decimal numbers. Bard 0.7 defines several built in numeric structures.

[cols="m,m,",options="header",]
|===
|Values     |Structure       |Notes
|0, 100, -2 |<small-integer> |Integers that can be conveniently represented by a machine word
|9999999999999999999 |<big-integer> |Unlimited-precision integers
|2/3 |<ratio> |Fractional number represented by ratios of integers
|0.1 |<float> |Decimal numbers represented as floating-point values
|===

=== Names

*Names* are values that Bard uses to label elements of the language like functions, variables, and special forms, or to represent certain kinds of name-like data, such as files and network resources. There are three kinds of names:

[cols="1,1m,1m,4",options="header",]
|===
|Kind |Examples |Structure |Notes
|Symbol|foo, Bar, <symbol> |<symbol> |Names used for variables, functions, and so on
|Keyword|:type, :Family |<keyword> |Names that always evaluate to themselves
|URI|@"file:///tmp/",@"https://barcode.net" |<uri> |Universal Resource Identifiers and URLs
|===

=== Lists

Lists are sequences of values that are addressable by index. `List` is a class, not a structure, and its members include several different structures that represent sequences of values. The `Listing` protocol provides numerous operators that work on Lists.

Some List structures are mutable; others are immutable.

[cols="m,",options="header",]
|===
|Examples  |Notes
|[1 2 3]  | A List of integers
|[[1 2 3]["one" "two" "three"]]  | A List of Lists
|"A list of Characters"  | Text strings are also Lists (see "Text Strings," below)
|===

=== Text Strings

Text strings, like `"Hello"`, are Lists of Characters. All of the operators of the `Listing` protocol work on them, but they also participate in the `TextProcessing` protocol, which adds many operators specialized for handling text.

Like `List`, `Text` is a class, not a structure, and there may be several different structures that implement it.

=== Characters

Characters are the atomic elements of text strings. The class `Character` comprises the structures used to represent them.

[cols="1m,3",options="header",]
|===
|Examples  |Notes
|#\A, #\z, #\space  |Bard supports several different `Character` structures
|===

=== Maps

Maps are data structures that associate *keys* with *values*. The `Map` class comprises several such structures with different storage and performance characteristics.

Some maps are mutable; others are immutable.

[cols="2m,3",options="header",]
|===
|Examples |Notes
|{}, {:name "Fred" :age 35} |Bard supports several
mutable and immutable types of maps
|===

=== Functions

Functions are operators that select methods to apply based on an examination of the values of their arguments. You can create a function using the `function` special form, but until you add *methods* to it, it cannot actually compute anything.

Following is an expression that creates a named function and its input and output classes:

....
(function foo Bar -> Baz)
....

=== Methods

The special form named `^` ("caret" or "lambda") constructs a *method*, also known as a *monomophic function*. A method is a procedure that can be applied to some sequence of values to compute a result.

Following is an expression that creates a method that squares its input:

....
(^ [x] (* x x))
....


Although you can construct methods this way and use them directly, the most common way to create and use them is with the special form `define method`:

....
(define method (add x y)
  with {x <small-integer> y <small-integer>}
  (+ x y))
....

`define method` creates a method and adds it to the named function, along with a matching rule that specifies the requirements that the function's arguments must meet in order for the method to apply to them. In this example, the defined method applies only when `x` and `y` are both instances of `<small-integer>`.

We can add another method to the same function, matching a different structure:

....
(define method (add x y)
  with {x <string> y <string>}
  (cat x y))
....

While the `<small-integer>` version of `add` uses the addition operator on its arguments, the `<string>` version instead uses `cat`, which concatenates the strings.

You may match any structures you like, and Bard also supports constraints other than type constraints. For example:

....
(define method (add x y)
  with {x (exactly 4)
        y (exactly 2)}
  (print "You have discovered the answer to life, the universe, and everything: 42!"))
....

== Naming Conventions

Bard uses some naming conventions that are not strictly enforced by the compiler, but which are strongly encouraged for the sake of clarity.

=== Constants

....
+Pi+
+C+
+fine-structure-constant+
....

*Constants* are read-only variables.

=== Special Variables

....
*window*
*process-id*
*epoch*
....

A *special variable* is a variable that is defined in all lexical contexts, in every package where the variable's name is visible.  Informally, you can think of special variables as global variables, though, strictly speaking, they're not necessarily global. A special variable's name isn't necessary lexically visible in all packages, and in packages where the name isn't visible, the value isn't accessible.

In addition, a special variable's value is unique to each thread of execution. If you spawn a new thread in which a special variable is visible then the new thread can change the special variable's value without affecting the value seen by other threads.

Finally, *binding forms* like `bind` can create bindings that *shadow* a special variable. When you *shadow* a special variable, you've created a local binding whose value may be different from the value in the enclosing environment. That new binding doesn't change the value that the special variable has in the enclosing environment; instead, it creates a new variable with the same name, defined only in the local environment.

=== Protocols

A *protocol* is named catalog of related operators and variables. Conceptually, a protocols is a collection of tools for carrying out some activity. The convention is to choose a name that describes the activity: `*Listing*`, for example, or `*Ordering*`.

....
Listing
Mapping
Streaming
....

=== Classes

A *class* is a named collection of *types*. Types, remember, may be either structures or classes, so classes may be members of other classes.

The convention is to name a class with a capitalized noun. The noun should reflect the way the type is intended to be used.

....
List
Map
Stream
....

=== Structures

A *structure* is a concrete description of how values are combined to form a new type of value. Structures are the only types that may be directly instantiated; classes may have instances only indirectly, by virtue of including structures as members; no classes have direct instances.

For structures, the convention is to name them with nouns that describe their concrete representation, spell the nouns in lower case, and enclose the name in angle brackets ("<>").

....
<character>
<cons>
<null>
<small-integer>
....

=== Predicates

*Predicates* are functions and methods of one argument that return true or false.

The convention is to end the name of predicates with question marks ("?").

....
empty?
even?
number?
....

=== Accessors

An *accessor* is a function that returns the value of a slot in an object. If a slot is *mutable* then the accessor may also be used to replace the value.

The convention is to start the name of an accessor with a dot (".").

....
.active?
.name
.width
....

=== Mutators

A *mutator* is a function that destructively modifies the value in a slot, replacing the old value with a new one, or that destructively rearranges the data in an object (for example, a sort that rearranges the the contents of an array in-place).

The convention is to end the names of mutators with exclamation points ("!").

....
replace!
reverse!
set!
.set-name!
....

== Structures

A *structure* is a concrete representation of how to assemble a value from simpler values. There are three kinds of structures:

- *records* are structures made of named slots.
- *tuples* are structure made of sequences of elements that may be fetched by index
- *enumerations* are structures defined as one or more named values, optionally with one or more data parameters associated with the names.

This section describes how to define and instantiate structures, and how to operate on them.

=== Records

=== Tuples

=== Enumerations

== Protocols



== Operators

=== Special Forms

=== Syntax Forms

A *syntax form* is just a special form whose evaluation rules give it a special syntax, different from the normal function-call syntax.

=== Functions

=== Methods

=== Macros

== Function calls

== Returning multiple values

== Binding variables

== Packages

== Defining Protocols and Operators

== Defining Structures

== Assignment

== Flow of Control

== Built-in Protocols

=== Addressing

Operations on resource names and identifiers.

=== Comparing

Testing values for equality, equivalence, and sort order.

=== Converting

Constructing values of one type that are in some sense equivalent to values of another type. Alternatively, copying values from one type to another.

=== Creating

Constructing values from structures.

=== Listing

Operations on sequences of values.

=== Macros

Macros defined by Bard.

=== Mapping

Operations on mappings from keys to values.

=== Pairing

Operations on paired values.

=== Printing

Printing output.

=== Reading

Reading input.

=== Serializing

Converting values to a form that can be transported and stored outside the bard runtime, and converting values in such forms back into live Bard data in the runtime.

=== Streaming

Operations on objects that produce or consume values.

=== Tapping

Operations that convert values to streams.

=== TextProcessing

Operations on text strings.

=== Typing

Operations on types and operations on values that produce types.
