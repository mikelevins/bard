Bard Bottom-up

1. Values

   nothing
   true
   false
   small-integers
   big-integers
   single-floats
   double-floats
   ratios
   names
   strings     
   bitvectors
   bytevectors
   sequences
   maps
   methods
   functions
   types
   categories
   domains

2. Methods

   Monomorphic lambdas, eg:

   (define square (^ (x)(* x x)))

3. Types

   A type is a designator for a set of concrete value
   representations. Bard provides a set of type definitions that
   correspond to the basic built-in types, and a mechanism for
   defining new user-defined types.

3.1 Built-in types

   <anything>
   <nothing>
   <true>
   <false>
   <small-integer>
   <big-integer>
   <single-float>
   <double-float>
   <ratio>
   <name>
   <unicode-string>     
   <bitvector>
   <bytevector>
   <sequence>
   <map>
   <method>
   <function>
   <type>
   <category>
   <domain>

3.2 User-defined types

  A user of Bard can define a new type using the define-type form:

  (define-type <pair> car cdr)

  A more complicated form enables the user to specify various things
  about the fields of the type:

  (define-type <pair> 
    (car type: <anything> reader: car writer: nothing allocation: instance)
    (cdr type: <anything> reader: cdr writer: nothing allocation: instance))

4. Domains

  A domain describes subtype/supertype relationships between
  types, and how functions choose methods when they are applied.

  (define-domain Table
    resolution: +Default-Resolution+))

  The example expression defines a domain named Table, which uses
  Bard's default method-resolution strategy (called "C3"). The
  resolution clause is required only if the new domain has a
  resolution strategy other than the default, so we could have defined
  Table like this:

  (define-domain Table)

  This version means the same thing as the original one.

  Once a domain is defined, protocols that use it can be defined.

  (define-protocol (Table Access)
    (value-at Table Key) -> Value)

  A protocol is simply a set of generic-function definitions. The
  functions defined by a protocol use the protocol's domain. The above
  example defines the Table Access protocol (or, alternatively, the
  Access protocol in the Table domain).

  A domain can accomodate any number of protocols, and you can write
  any number of define-protocol forms using the same domain. In a
  later define-protocol form that references a protocol that was
  defined earlier, new functions are added to the defined protocol or,
  if previously-defined function names appear again, the functions
  mentioned are redefined.

  In the above example, Table Access protocol consists of a single
  generic function, value-at, which accepts Table and Key arguments
  and returns a Value.

  Table, Key, and Value are type variables that stand for categories
  defined by the domain. Before we can write a method for the value-at
  function, we have to define the types that can take the places of
  those variables.

  (define-category <unicode-string> (Key)
    domain: Table)

  (define-category <name> (Key)
    domain: Table)

  (define-category <map> (Table)
    domain: Table)

  (define-category <anything> (Value)
    domain: Table)


  These definitions tell Bard that in the Table domain a Key may be
  either a <unicode-string> or a <name>, a Table may be a <map>, and a
  Value may be any valid Bard value (<anything> is a language-defined
  type whose members include all valid Bard values). With those
  relationships established, we can define methods on the functions
  defined by the domain's protocol.

  In the above examples, each concrete type is declared to be a member
  of a category defined in the Table domain. The category appears in a
  list because you can declare a type to belong to more than one
  category. For example:

  (define-category <name> (Value Key)
    domain: Table)

  This definition means that <name> is a subtype of both Value and
  Key, as defined in the Table domain. That in turn means that you can
  define a method on either Value or Key, and that method will be
  selected if its function is applied to a <name>.

  What if methods of a function are defined on both Value and Key, but
  not on <name>? Which method is selected? The answer depends on the
  function's domain, but in the default domain the Value method is
  selected because Value is listed before Key in the category
  definition for <name>. Bard's default domain uses the C3 algorithm
  for selecting methods.

5. Functions

   Once a domain and a protocol have been declared, we can define
   methods on the functions defined by the protocol:

   (define-method (value-at (m <map>) (nm <name>))
     (m nm))
  
  The above example defines a method for value-at in which the <map>
  type matches the Table category, and the <name> type matches the Key
  category. This will work after the expressions above because our
  category definitions established that <map> is a member of Table and
  <name> is a member of Key.

  We could alternatively write a more general method, specialized on
  categories rather than concrete types:

  (define-method (value-at (t Table) (k Key))
    (get m nm))
  
  This will work just as well, as long as some function get exists,
  and is defined for some types that are defined as members of Table
  and Key.

