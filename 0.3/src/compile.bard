;;;; ***********************************************************************
;;;; FILE IDENTIFICATION
;;;;
;;;; Name:          compile.bard
;;;; Project:       Bard
;;;; Purpose:       bard compiler in bard, targeting the bard vm
;;;; Author:        mikel evins
;;;; Copyright:     2012 by mikel evins
;;;;
;;;; ***********************************************************************

(define-function (contains-variable? (env <null>)(expr <symbol>)) false)

(define-function (contains-variable? (env <pair>)(expr <symbol>))
  (if (= expr (left (first env)))
      true
      (contains-variable? (rest env) expr)))

(define-function (gen opcode & args)
  (list (add-first opcode args)))

(define-function (gen-label)(gensym))

(define-function (gen-seq & args)
  (if (empty? args)
      []
      (append (first args)
              (apply gen-seq (rest args)))))

(define-function (self-evaluating? expr) true)
(define-function (self-evaluating? (expr <symbol>)) false)
(define-function (self-evaluating? (expr <pair>)) false)

(define-function (compile-self-evaluating expr)
  (gen 'CONST expr))

(define-function (compile-variable-reference expr env)
  (if (contains-variable? env expr)
      (gen 'LREF expr)
      (gen 'GREF expr)))

(define compile-^ (method (expr env)(error "Not yet implemented")))

(define-function (compile-begin-aux exprs env) 
  (cond
   ((empty? exprs)(compile-self-evaluating nothing))
   ((= 1 (length exprs))(compile (first exprs) env))
   (else: (gen-seq (compile (first exprs) env)
                   (compile-begin-aux (rest exprs) env)))))

(define compile-begin (method (expr env)(compile-begin-aux (rest expr) env)))

(define compile-cond (method (expr env)(error "Not yet implemented")))
(define compile-define (method (expr env)(error "Not yet implemented")))
(define compile-ensure (method (expr env)(error "Not yet implemented")))

(define compile-if (method (expr env)
                           (let ((test-form (element expr 1))
                                 (testcode (compile test-form env))
                                 (then-form (element expr 2))
                                 (thencode (compile then-form env))
                                 (else-form (if (> (length expr)
                                                   3)
                                                (element expr 3)
                                                nothing))
                                 (elsecode (compile else-form env)))
                             (let ((L1 (gen-label))
                                   (L2 (gen-label)))
                               (gen-seq testcode
                                        (gen 'FGO L1)
                                        thencode
                                        (gen 'GO L2)
                                        [L1]
                                        elsecode
                                        [L2])))))

(define compile-let (method (expr env)(error "Not yet implemented")))
(define compile-loop (method (expr env)(error "Not yet implemented")))
(define compile-match (method (expr env)(error "Not yet implemented")))
(define compile-quasiquote (method (expr env)(error "Not yet implemented")))

(define compile-quote (method (expr env)(gen 'CONST (element expr 1))))

(define compile-set! (method (expr env)(error "Not yet implemented")))
(define compile-setter (method (expr env)(error "Not yet implemented")))
(define compile-unless (method (expr env)(error "Not yet implemented")))
(define compile-unquote (method (expr env)(error "Not yet implemented")))
(define compile-unquote-splicing (method (expr env)(error "Not yet implemented")))
(define compile-values (method (expr env)(error "Not yet implemented")))
(define compile-when (method (expr env)(error "Not yet implemented")))
(define compile-with-exit (method (expr env)(error "Not yet implemented")))

(define +special-forms+ 
  { '^ compile-^
   'begin compile-begin
   'cond compile-cond
   'define compile-define
   'ensure compile-ensure
   'if compile-if
   'let compile-let
   'loop compile-loop
   'match compile-match
   'quasiquote compile-quasiquote
   'quote compile-quote
   'set! compile-set!
   'setter compile-setter
   'unless compile-unless
   'unquote compile-unquote
   'unquote-splicing compile-unquote-splicing
   'values compile-values
   'when compile-when
   'with-exit compile-with-exit})

(define-function (special-form? expr) false)

(define-function (special-form? (expr <pair>))
  (and (something? (get +special-forms+ (left expr)))
       true))

(define-function (compile-special-form (expr <pair>) env)
  (let ((comp (get +special-forms+ (left expr))))
    (comp expr env)))

(define macroexpand-and (method (expr)(error "Not yet implemented")))
(define macroexpand-not (method (expr)(error "Not yet implemented")))
(define macroexpand-or (method (expr)(error "Not yet implemented")))

(define +macro-forms+ 
  {'and macroexpand-and
   'not macroexpand-not
   'or macroexpand-or})

(define-function (macro-form? expr) false)

(define-function (macro-form? (expr <pair>))
  (and (something? (get +macro-forms+ (left expr)))
       true))

(define-function (macroexpand (expr <pair>))
  (let ((expand (get +macro-forms+ (left expr))))
    (expand expr)))

(define +primitives+ 
  ['%fx+ '%fx- '%fx* '%fx/])

(define-function (primitive? expr) false)

(define-function (primitive? (expr <symbol>))
  (and (not (empty? (filter (method (p)(= p expr)) 
                            +primitives+)))
       true))

(define-function (compile-primitive-funcall op argexprs env)
  (gen-seq (compile-list argexprs env)
           (gen 'PRIM op (length argexprs))))

(define-function (applicable-datum? d) false)
(define-function (applicable-datum? <string>) true)
(define-function (applicable-datum? <frame>) true)
(define-function (applicable-datum? <pair>) false)

(define-function (compile-list (exprs <null>) env) [])

(define-function (compile-list (exprs <pair>) env)
  (gen-seq (compile (left exprs) env)
           (compile-list (right exprs) env)))

(define-function (compile-application-form (expr <pair>) env)
  (let ((fexpr (left expr))
        (argexprs (right expr)))
    (if (primitive? fexpr)
        (compile-primitive-funcall fexpr argexprs env)
        (let ((op (compile fexpr env)))
          (if (applicable-datum? op)
              (if (= 1 (length argexprs))
                  (compile `(get ,op ,(left argexprs)) env)
                  (error ["Too many arguments in application of datum: " argexprs]))
              (gen-seq (compile-list argexprs env)
                       (compile fexpr env)
                       (gen 'CALL (length argexprs))))))))

(define-function (compile expr env)
  (cond
   ((self-evaluating? expr)(compile-self-evaluating expr))
   ((symbol? expr)(compile-variable-reference expr env))
   ((special-form? expr)(compile-special-form expr env))
   ((macro-form? expr)(compile (macroexpand expr) env))
   (else: (compile-application-form expr env))))
