Thoughts on method dispatch

Consider a function add:

  (fn (add Number Number) ->  Number)

...and several methods:

  (define method (add x y)                          :: [Anything Anything]
    (list x y))

  (define method (add x (y List))                   :: [Anything List]
    (add-first x y))

  (define method (add (x <character>) (y Text))     :: [<character> Text]
    (add-first x y))

  (define method (add (x Number) (y Number))        :: [Number Number]
    (+ x y))

  (define method (add (x <fixnum>) (y <fixnum>))    :: [<fixnum> <fixnum>]
    (prim:fx+ x y))



Now consider the computed type-precedence-lists of arguments in a few
function calls. Types with defined specializations for add in the
position where they appear are marked with a '*'. Combinations of
types that uniquely identify a defined method are written (T1,T2)::<list of type tuples>

(add 2 3)
     2 :: [<fixnum>* Integer Number* Atom Anything*]
     3 :: [<fixnum>* Integer Number* Atom Anything*]
(2,3) :: (<fixnum>,<fixnum>) (Number,Number) (Anything,Anything)

(add 'Foo [])
     'Foo :: [<symbol> Symbol Name List Text Ordered Atom Collection Anything*]
     [] :: [<pair> Pair Tuple List* Ordered Collection Anything*]
('Foo,[]):: (Anything,List) (Anything,Anything)

(add #\x "Foo")
     #\x :: [<character>* Atom Anything*]
     "Foo" :: [<string> Text* List* Ordered Collection Anything*]
(#\x,"Foo"):: (<character>,Text) (Anything,Anything)

(add 2 2/3)
     2 :: [<fixnum>* Integer Number* Atom Anything*]
     2/3 :: [<ratnum> Ratio Number* Atom Anything*]
(2,2/3):: (Number,Number) (Anything,Anything)


In dispatching, the goal is to efficiently do the following:
- obtain a correctly-sorted type list for each input value
- find the leftmost type tuple for the inputs for which a
  defined method exists.
- maybe: enable a protocol to locally override the type precedence
  lists of its classes

We can maintain a standard base graph of classes:

(define class Anything ())                | Anything
(define class Undefined (Anything))       | Undefined->Anything
(define class Atom (Anything))            | Atom->Anything
(define class Bit (Atom))                 | Bit->Atom->Anything
(define class Word (Atom))                | Word->Atom->Anything
(define class Character (Atom))           | Character->Atom->Anything
(define class Boolean (Atom))             | Boolean->Atom->Anything
(define class True (Boolean))             | True->Boolean->Atom->Anything
(define class False (Boolean))            | False->Boolean->Atom->Anything
(define class Actor (Atom))               | Actor->Atom->Anything
(define class Callable (Atom))            | Callable->Atom->Anything
(define class Function (Callable))        | Function->Callable->Atom->Anything
(define class Method (Callable))          | Method->Callable->Atom->Anything
(define class Collection (Anything))      | Collection->Anything
(define class Nothing (Collection Atom))  | Nothing->Collection->Atom->Anything
(define class Keyed (Collection))         | Keyed->Collection->Anything
(define class Ordered (Keyed))            | Ordered->Keyed->Collection->Anything
(define class Stream (Ordered))           | Stream->Ordered->Keyed->Collection->Anything
(define class Tuple (Ordered))            | Tuple->Ordered->Keyed->Collection->Anything
(define class Pair (Tuple))               | Pair->Tuple->Ordered->Keyed->Collection->Anything
(define class List (Tuple))               | List->Tuple->Ordered->Keyed->Collection->Anything
(define class Text (List))                | Text->List->Tuple->Ordered->Keyed->Collection->Anything
(define class Name (Atom Text))           | Name->Atom->Text->List->Tuple->Ordered->Keyed->Collection->Anything
(define class Symbol (Name))              | Symbol->Name->Atom->Text->List->Tuple->Ordered->Keyed->Collection->Anything
(define class Keyword (Name))             | Keyword->Name->Atom->Text->List->Tuple->Ordered->Keyed->Collection->Anything
(define class URL (Name))                 | URL->Name->Atom->Text->List->Tuple->Ordered->Keyed->Collection->Anything
(define class Magnitude (Atom))           | Magnitude->Atom->Anything
(define class Infinity (Magnitude))       | Infinity->Magnitude->Atom->Anything
(define class Infinitesimal (Magnitude))  | Infinitesimal->Magnitude->Atom->Anything
(define class Number (Magnitude))         | Number->Magnitude->Atom->Anything
(define class Integer (Number))           | Integer->Number->Magnitude->Atom->Anything
(define class Fraction (Number))          | Fraction->Number->Magnitude->Atom->Anything
(define class Ratio (Fraction))           | Ratio->Number->Magnitude->Atom->Anything
(define class Float (Fraction))           | Float->Number->Magnitude->Atom->Anything

This graph cannot be static because a user can define new protocols
and classes. When that happens, new classes may be inserted into the
graph at arbitrary places. Inserting a new class cannot alter the
definitions or precedence lists of existing classes, but a programmer
can subsequently alter the graph by redefining existing classes to add
the new classes to their precedence lists.

We can use the c3 algorithm to efficiently compute precedence lists when adding new classes.

By defining methods, a programmer can make a schema a member of a
class. For example, suppose a protocol exists that uses the Integer
class. By defining a method for the protocol that specializes an
Integer parameter on <fixnum>, a programmer can implicitly assert that
<fixnum> is a member of Integer. That assertion yields this precedence
list:


  <fixnum>->Integer->Number->Magnitude->Atom->Anything

There are many of these in the base Bard image, because the built-in
schemas participate in numerous built-in protocols.

There is one more complication: singletons.

A singleton is a value treated as a type for dispatch purposes. When
user code refers to a singleton, a singleton object is created and
interned. Subsequent references to the singleton return the interned
singleton object.

If a method is specialized on a singleton--let's say on (singleton
3)--then we get this precedence list:

  (singleton 3)-><fixnum>->Integer->Number->Magnitude->Atom->Anything

A method may be specialized on any of these types. In general,
functions may have any number of arguments, and a method may
specialize on any tuple of types drawn from the precedence lists of
their arguments.

To dispatch, we must obtain an up-to-date precedence list for each
input value at the time of the function call. We must then find all
the defined methods that specialize on tuples of types that appear in
the respective precedence lists. Once we've found them, we must sort
them so that they appear in precedence order (using the c3 algorithm).

We can then apply the leftmost method; any other methods are
maintained in case of a next-method call.

Bard can maintain a whole-system graph of known types, including
singletons (theoretically, every possible value is a singleton, but we
need only maintain singletons that have actually been referred to in
method definitions). The graph must be updated when methods and
protocols are defined or redefined.

When a function is applied, it's given a list of arguments. We can
obtain the types of the arguments using an O(1) function provided by
the Bard runtime. The type will be a singleton object if the value has
been defined as a singleton; it will be a schema, otherwise.

Conceptually, we dispatch the function by:

1. obtaining the precedence list for each argument

2. check whether a method is defined for the tuple of types for the
   arguments. If so, call the method.

3. if such a method is not defined, substitute the next element of the
   first argument's precedence list and repeat. We continue this
   process, examining each argument in turn, ntil all types have been
   exhausted.

There are a few special cases that can eliminate dispatching work:

1. If there is a single defined method whose argument types are all
   Anything, we do not dispatch at all; we simply execute this method.

2. If there is a method cache for the function, and it's not empty,
   then we look up the tuple of argument types in the cache. If we
   find a hit, we execute it. Such method caches must be cleared when
   new methods are defined on the function, and when there's a change
   in the protocols to which the method belongs. The cache must store
   all applicable methods in c3 order, so that next-method will work.

3. If there is a single defined method, we dispatch simply, by
   checking whether the inputs match the single method's argument
   types (directly or indirectly). If so, we execute the method; if
   not we execute no-applicable-method.

If none of these conditions obtains then we have to search the whole
collection of defined methods.

Here's a call to add, with precedence lists illustrated:

                  Anything
                  Collection
                  Ordered
     Anything     List
     Atom         Text
     <character>  <string>
(add #\x          "Foo")

The actual defined methods specified above are specialized on
(<character>,Text) and (Anything,Anything). The goal is to efficiently
find those two methods and present them in the proper order.

So here's the scoop:

1. Types are identified by integers, that can be quickly computed from
   the values themselves, so storing types in tables and looking them up
   is fast.

2. Singletons are types and have integer tags. They work essentially
   like symbols: a singleton is interned when it's referenced. (I
   think I can support multiple kinds of singletons, so that matching
   them can use eq?, eqv?, equal?, or maybe even a user-defined
   comparison.)

3. We maintain a global table of precedence lists for all defined
   types. It gets updated when affected types and protocols change.

4. Each function has a set of data structures that are used to make
   dispatch as fast as possible:

   1. First we check the method cache to see if there's a method chain
      stored for the specific concrete-types tuple of the input
      arguments.

   2. Next we check the unspecialized-method? flag. It's true when
      there's just one method and its argument types are all Anything.
      We can store the method itself as the value of the flag.
      In that case, as long as we got the right number of arguments
      we can just jump straight to that method.

   3. Next we check the single-method? flag. It's true when there's
      just one method defined, but the argument types include
      something other than Anything. Again, we can store that method
      as the value of the flag. In that case, we can just check to
      make sure the input types match the method's argument types and
      jump to it if they do.

   4. None of the shortcuts panned out, so we have to compute a full
      c3-style dispatch. To make that faster, we have some data stored
      on the function. The function keeps a table of arities. For each
      arity it maintains a sorted list of explicitly-mentioned
      type-tags for each argument position. We start by filtering the
      input-argument types to remove all types that are not mentioned.
      If any position ends up empty, then there is no applicable
      method.

      If all positions still have types left, then there are
      applicable methods. We collect those methods, sort them
      according to c3, and stash the resulting method chain in the
      function's method cache. 

      Then we apply the best (leftmost) method.

