
;;; Bard's built-in classes defined

(define class Accessor [Procedure])

(define class Actor [Atom])

(define class AdjustableArray [Array]
  adjust! (->  -> )
  adjustable? (->  -> ))

(define class AdjustableVector [Vector]
  adjust! (->  -> )  
  adjustable? (->  -> )  
  fill-pointer (->  -> )  
  vector-pop! (->  -> )  
  vector-push! (->  -> ))

(define class Anything []
  as (-> Type Anything -> Anything)
  copy (-> Anything {} -> Anything)
  equal? (-> Anything Anything * -> Boolean)
  equivalent? (-> Anything Anything * -> Boolean)
  identical? (-> Anything Anything * -> Boolean)
  identity (-> Anything -> Anything))

(define class Array [Collection]
  array-dimension (->  -> )  
  array-dimension-limit (->  -> )  
  array-dimensions (->  -> )  
  array-element-type (->  -> )  
  array-has-fill-pointer? (->  -> )  
  array-rank (->  -> )  
  array-rank-limit (->  -> )  
  array-row-major-index (->  -> )  
  array-total-size (->  -> )  
  array? (->  -> )  
  element (->  -> )  
  row-major-ref (->  -> ))

(define class Atom [Anything])

(define class Boolean [Atom]
  atom? (-> Anything -> Boolean)
  not (-> Anything -> Boolean))

(define class Character [Atom]
  alphabetic-character? (-> Character -> Boolean)
  alphanumeric-character? (-> Character -> Boolean)
  capitalize (-> Character -> Character)
  capitalized? (-> Character -> Boolean)
  character->code (-> Character -> Integer)
  character-name (-> Character -> Name)
  character? (-> Anything -> Boolean)
  code->character (-> Integer -> Character)
  digit-character? (-> Character -> Boolean)
  downcase (-> Character -> Character)
  downcase? (-> Character -> Boolean)
  graphic-character? (-> Character -> Boolean)
  name->character (-> Name -> Character)
  numeric-character? (-> Character -> Boolean)
  standard-character? (-> Character -> Boolean)
  upcase (-> Character -> Character)
  upcase? (-> Character -> Boolean)
  whitespace-character? (-> Character -> Boolean))

(define class Class [Type]
  class-of (-> Anything -> Class)
  class? (-> Anything -> Boolean))

(define class Collection [Anything]
  count (-> Collection -> Integer)
  empty? (-> Collection -> Boolean)
  every? (-> Procedure Collection -> Boolean)
  member? (-> Anything Collection { :test Procedure } -> Boolean)
  mutable? (-> Collection -> Boolean)
  remove (-> Anything Collection { :test Procedure } -> Collection))

(define class Complex [Number])

(define class Condition [Atom]
  abort (->  -> )  
  all-restarts (->  -> )  
  assert (->  -> )  
  break (->  -> )  
  continue (->  -> )  
  define-condition (->  -> )  
  error (->  -> )  
  find-restart (->  -> )  
  handler-bind (->  -> )  
  handler-case (->  -> )  
  ignore-errors (->  -> )  
  ignore-warnings (->  -> )  
  invoke-restart (->  -> )  
  restart-bind (->  -> )  
  restart-case (->  -> )  
  signal (->  -> )  
  warn (->  -> ))

(define class EndOfFile [Name])

(define class Error [Condition])

(define class Float [Real])

(define class Function [Procedure]
  add-method! (-> Function List Method -> Function)
  all-applicable-methods (-> Function List -> Function)
  find-method (-> Function List -> Method)
  next-method (-> Function List -> Method)
  next-method? (-> Function List -> Boolean)
  no-applicable-method (-> Function List -> )
  remove-method! (-> Function List -> Function)
  function? (-> Anything -> Boolean))

(define class Gatherer [Stream]
  gather (->  -> )  
  gathering (->  -> )  
  finish-output (->  -> )  
  newline (->  -> )  
  next (->  -> )  
  result (->  -> )  
  write (->  -> ))

(define class Generator [Stream]
  coalesce (-> Function List * -> Generator)
  range-from (-> Integer {} -> Generator)
  repeat (-> Anything -> Generator)

  catenate (->  -> )  
  characters (->  -> )  
  choose (->  -> )  
  choose-if (->  -> )  
  chunk (->  -> )  
  clear-input (->  -> )  
  collect (->  -> )  
  collect-alist (->  -> )  
  collect-and (->  -> )  
  collect-append (->  -> )  
  collect-eighth (->  -> )  
  collect-element (->  -> )  
  collect-fifth (->  -> )  
  collect-first (->  -> )  
  collect-fourth (->  -> )  
  collect-image (->  -> )  
  collect-last (->  -> )  
  collect-length (->  -> )  
  collect-max (->  -> )  
  collect-min (->  -> )  
  collect-ninth (->  -> )  
  collect-or (->  -> )  
  collect-plist (->  -> )  
  collect-reduce (->  -> )  
  collect-second (->  -> )  
  collect-seventh (->  -> )  
  collect-sixth (->  -> )  
  collect-stream (->  -> )  
  collect-sum (->  -> )  
  collect-table (->  -> )  
  collect-third (->  -> )  
  collecting (->  -> )  
  cotruncate (->  -> )  
  expand (->  -> )  
  generate (->  -> )  
  iterate (->  -> )  
  latch (->  -> )  
  length (->  -> )  
  lines (->  -> )  
  mapping (->  -> )  
  mask (->  -> )  
  mingle (->  -> )  
  objects (->  -> )  
  positions (->  -> )  
  previous (->  -> )  
  read (->  -> )  
  read-line (->  -> )  
  resume (->  -> )  
  scan (->  -> )  
  scan-alist (->  -> )  
  scan-image (->  -> )  
  scan-list (->  -> )  
  scan-map (->  -> )  
  scan-multiple (->  -> )  
  scan-names (->  -> )  
  scan-plist (->  -> )  
  scan-range (->  -> )  
  scan-stream (->  -> )  
  scan-table (->  -> )  
  scan-tails (->  -> )  
  subseries (->  -> )  
  unread (->  -> )  
  until (->  -> )  
  until-if (->  -> )  
  yield (->  -> ))

(define class Getter [Accessor])

(define class HashTable [MutableTable]
  hash (-> Anything -> Anything)
  hashtable-test (-> Table -> Procedure)
  hashtable? (-> Anything -> Boolean)
  rehash-threshold (-> Table -> Number))

(define class HomogeneousVector [Vector])

(define class Integer [Rational])

(define class Keyword [Name])

(define class List [Collection]
  add-last (-> List Anything -> List)
  acons (-> Anything Anything List -> List)
  adjoin (-> Anything List -> List)
  any (-> List -> Anything)
  append (-> List List * -> List)
  assoc (-> Anything List -> Pair)
  by (-> Integer List -> List)
  count-if (-> Procedure List -> Integer)
  drop (-> Integer List -> List)
  drop-while (-> Procedure List -> List)
  eighth (-> List -> Anything)
  element (-> List Integer -> Anything)
  fifth (-> List -> Anything)
  filter (-> Procedure List -> Anything)
  find (-> Procedure List -> Anything)
  first (-> List -> Anything)
  fourth (-> List -> Anything)
  head (-> List -> Anything)
  image (-> Procedure List -> List)
  indexes (-> List -> List)
  insert (-> List Integer Anything -> List)
  interleave (-> List List -> List)
  interpose (-> Anything List -> List)
  join (-> List Anything -> List)
  last (-> List -> Anything)
  list? (-> Anything -> Boolean)
  ninth (-> List -> Anything)
  not-any? (-> Procedure List -> Boolean)
  not-every? (-> Procedure List -> Boolean)
  partition (-> Procedure List -> List List)
  penult (-> List -> Anything)
  pop (-> List -> Anything)
  pop! (-> List -> Anything)
  position-if (-> Procedure List -> Integer)
  prefix-match? (-> List List -> Boolean)
  push (-> Anything List -> List)
  push! (-> Anything List -> List)
  pushnew (-> Anything List -> List)
  pushnew! (-> Anything List -> List)
  range (-> Integer Integer {} -> List)
  reduce (-> Procedure Anything List -> Anything)
  rest (-> List -> List)
  reverse (-> List -> List)
  second (-> List -> Anything)
  select (-> List List -> List)
  seventh (-> List -> Anything)
  shuffle (-> List -> List)
  sixth (-> List -> Anything)
  some? (-> Procedure List -> Boolean)
  sort (-> List Procedure -> List)
  split (-> List Procedure -> List)
  sublist (-> List Integer Integer -> List)
  suffix-match? (-> List List -> Boolean)
  tail (-> List -> List)
  tails (-> List -> List)
  take (-> Integer List -> List)
  take-by (-> Integer Integer List -> List)
  take-while (-> Procedure List -> List)
  tenth (-> List -> Anything)
  third (-> List -> Anything)
  trim (-> List List -> List)
  unique (-> List Procedure -> List)
  unzip (-> List -> List List)
  zip (-> List List -> List))

(define class Macro [Procedure])

(define class Method [Procedure]
  method? (-> Anything -> Boolean))

(define class MutableTable [Table]
  put! (-> MutableTable Anything Anything -> MutableTable)
  remove! (-> Anything MutableTable { :test Procedure } -> MutableTable))

(define class Name [Atom]
  bound? (-> Name -> Boolean)
  make-unbound! (-> Name -> Name)
  as-namestring (->  -> )  
  as-url-string (->  -> )  
  author (->  -> )  
  delete! (->  -> )  
  device (->  -> )  
  directory (->  -> )  
  directory? (->  -> )  
  ensure-directories-exist! (->  -> )  
  gensym (->  -> )  
  host (->  -> )  
  keyword? (->  -> )  
  merge-pathnames (->  -> )  
  modified (->  -> )  
  name (->  -> )  
  package-of (->  -> )  
  pathname (->  -> )  
  pathname? (->  -> )  
  port (->  -> )  
  probe (->  -> )  
  query (->  -> )  
  rename! (->  -> )  
  resource-name? (->  -> )  
  scheme (->  -> )  
  symbol? (->  -> )  
  true-name (->  -> )  
  type (->  -> )  
  url? (->  -> )  
  version (->  -> ))

(define class Nothing [*] ; Nothing is a subclass of all classes
  )

(define class Number [Atom]
  * (->  -> )  
  + (->  -> )  
  +PI+ (->  -> )  
  - (->  -> )  
  / (->  -> )  
  /=  (->  -> )  
  1+ (->  -> )  
  1- (->  -> )  
  <  (->  -> )  
  <=  (->  -> )  
  = (->  -> )  
  >  (->  -> )  
  >=  (->  -> )  
  abs (->  -> )  
  acos (->  -> )  
  acosh (->  -> )  
  ash (->  -> )  
  asin (->  -> )  
  asinh (->  -> )  
  atan (->  -> )  
  atanh (->  -> )  
  boole (->  -> )  
  ceiling (->  -> )  
  complex? (->  -> )  
  conjugate (->  -> )  
  cos (->  -> )  
  cosh (->  -> )  
  dec! (->  -> )  
  denominator (->  -> )  
  even? (->  -> )  
  exp (->  -> )  
  expt (->  -> )  
  float (->  -> )  
  float? (->  -> )  
  floor (->  -> )  
  gcd (->  -> )  
  imaginary-part (->  -> )  
  inc! (->  -> )  
  integer-length (->  -> )  
  integer? (->  -> )  
  lcm (->  -> )  
  log (->  -> )  
  logand  (->  -> )  
  logandc1  (->  -> )  
  logandc2  (->  -> )  
  logbit? (->  -> )  
  logcount (->  -> )  
  logeqv  (->  -> )  
  logior  (->  -> )  
  lognand  (->  -> )  
  lognor  (->  -> )  
  lognot  (->  -> )  
  logorc1  (->  -> )  
  logorc2  (->  -> )  
  logtest (->  -> )  
  logxor (->  -> )  
  max (->  -> )  
  min (->  -> )  
  mod (->  -> )  
  negative? (->  -> )  
  number? (->  -> )  
  numerator (->  -> )  
  odd? (->  -> )  
  phase (->  -> )  
  positive? (->  -> )  
  random (->  -> )  
  random-state? (->  -> )  
  rational (->  -> )  
  rational? (->  -> )  
  real-part (->  -> )  
  real? (->  -> )  
  rem (->  -> )  
  round (->  -> )  
  sin (->  -> )  
  sinh (->  -> )  
  sqrt (->  -> )  
  tan (->  -> )  
  tanh (->  -> )  
  truncate (->  -> )  
  zero? (->  -> ))

(define class Package [MutableTable]
  all-names (->  -> )  
  all-packages (->  -> )  
  define-package (->  -> )  
  delete-package! (->  -> )  
  export (->  -> )  
  find-name (->  -> )  
  find-package (->  -> )  
  import (->  -> )  
  in-package (->  -> )  
  intern (->  -> )  
  package-exports (->  -> )  
  package-imports (->  -> )  
  package-name (->  -> )  
  package-used-by (->  -> )  
  package-uses (->  -> )  
  package? (->  -> )  
  rename-package! (->  -> )  
  unexport (->  -> )  
  unintern (->  -> )  
  unuse-package (->  -> )  
  use-package (->  -> ))

(define class Pair [List]
  left (-> Pair -> Anything)
  pair (-> Anything Anything -> Pair)
  pair? (-> Anything -> Boolean)
  right (-> Pair -> Anything))

(define class Pathname [ResourceName])

(define class Procedure [Atom]
  apply (-> Procedure List -> Anything)
  complement (-> Procedure -> Procedure)
  constantly (-> Anything -> Procedure))

(define class RandomState [Atom])

(define class Ratio [Rational])

(define class Rational [Real])

(define class ReadTable [MutableTable])

(define class Real [Number])

(define class Record [Structure])

(define class ResourceLocator [ResourceName])

(define class ResourceName [Name])

(define class Set [List])

(define class Setter [Accessor])

(define class Singleton [Type])

(define class Stream [Collection]
  accept (->  -> )  
  close (->  -> )  
  connect (->  -> )  
  cursor (->  -> ) ; position for next read or write
  input? (->  -> )  
  listen (->  -> )  
  open (->  -> )  
  open? (->  -> )  
  output? (->  -> )  
  standard-error (->  -> )  
  standard-input (->  -> )  
  standard-output (->  -> )  
  stream? (->  -> ))

(define class Structure [Type]
  initialize (-> Structure {} -> Structure)
  slot-bound? (-> Structure Name -> Boolean)
  slot-exists? (-> Structure Name -> Boolean))

(define class Symbol [Name])

(define class Table [Collection]
  contains-key? (-> Table Anything { :test Procedure } -> Boolean)
  contains-value? (-> Table Anything { :test Procedure } -> Boolean)
  do-entries (-> Procedure Table -> Anything)
  do-keys (-> Procedure Table -> Anything)
  drop-all-keys (-> Table -> Table)
  get (-> Table Anything -> Anything)
  image (-> Procedure Table -> Table)
  keys (-> Table -> List)
  merge (-> Table Table * -> Table)
  put (-> Table Anything Anything -> Table)
  readtable? (-> Anything -> Boolean)
  table? (-> Table ->)
  tree-table? (-> Anything -> Boolean)
  vals (-> Table -> List))

(define class Text [HomogeneousVector]
  text?)

(define class Tuple [Structure])

(define class Type [Atom]
  make (-> Type {} -> Anything)
  instance-of? (-> Anything Type -> Boolean)
  subtype? (-> Type Type -> Boolean))

(define class TypeSynonym [Type])

(define class Undefined [Anything])

(define class Union [Structure])

(define class Vector [Array List]
  vector (->  -> )  
  vector? (->  -> ))

(define class Warning [Condition])

(define class Word [Integer])
