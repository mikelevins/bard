
;;; Bard's built-in classes defined

(define class Accessor [Procedure])

(define class Actor [Atom])

(define class AdjustableArray [Array])

(define class AdjustableVector [Vector])

(define class Anything []
  as (-> Type Anything -> Anything)
  copy (-> Anything {} -> Anything)
  equal? (-> Anything Anything * -> Boolean)
  equivalent? (-> Anything Anything * -> Boolean)
  identical? (-> Anything Anything * -> Boolean)
  identity (-> Anything -> Anything))

(define class Array [Collection])

(define class Atom [Anything])

(define class Boolean [Atom]
  atom? (-> Anything -> Boolean)
  not (-> Anything -> Boolean))

(define class Character [Atom]
  alphabetic-character? (-> Character -> Boolean)
  alphanumeric-character? (-> Character -> Boolean)
  capitalize (-> Character -> Character)
  capitalized? (-> Character -> Boolean)
  character->code (-> Character -> Integer)
  character-name (-> Character -> Name)
  character? (-> Anything -> Boolean)
  code->character (-> Integer -> Character)
  digit-character? (-> Character -> Boolean)
  downcase (-> Character -> Character)
  downcase? (-> Character -> Boolean)
  graphic-character? (-> Character -> Boolean)
  name->character (-> Name -> Character)
  numeric-character? (-> Character -> Boolean)
  standard-character? (-> Character -> Boolean)
  upcase (-> Character -> Character)
  upcase? (-> Character -> Boolean)
  whitespace-character? (-> Character -> Boolean))

(define class Class [Type]
  class-of (-> Anything -> Class)
  class? (-> Anything -> Boolean))

(define class Collection [Anything]
  count (-> Collection -> Integer)
  empty? (-> Collection -> Boolean)
  every? (-> Procedure Collection -> Boolean)
  member? (-> Anything Collection { :test Procedure } -> Boolean)
  mutable? (-> Collection -> Boolean)
  remove (-> Anything Collection { :test Procedure } -> Collection))

(define class Complex [Number])

(define class Condition [Atom])

(define class EndOfFile [Name])

(define class Error [Condition])

(define class Float [Real])

(define class Function [Procedure]
  add-method! (-> Function List Method -> Function)
  all-applicable-methods (-> Function List -> Function)
  find-method (-> Function List -> Method)
  next-method (-> Function List -> Method)
  next-method? (-> Function List -> Boolean)
  no-applicable-method (-> Function List -> )
  remove-method! (-> Function List -> Function)
  function? (-> Anything -> Boolean))

(define class Gatherer [Stream])

(define class Generator [Stream]
  coalesce (-> Function List * -> Generator)
  range-from (-> Integer {} -> Generator)
  repeat (-> Anything -> Generator))

(define class Getter [Accessor])

(define class HashTable [MutableTable]
  hash (-> Anything -> Anything)
  hashtable-test (-> Table -> Procedure)
  hashtable? (-> Anything -> Boolean)
  rehash-threshold (-> Table -> Number))

(define class HomogeneousVector [Vector])

(define class Integer [Rational])

(define class Keyword [Name])

(define class List [Collection]
  add-last (-> List Anything -> List)
  acons (-> Anything Anything List -> List)
  adjoin (-> Anything List -> List)
  any (-> List -> Anything)
  append (-> List List * -> List)
  assoc (-> Anything List -> Pair)
  by (-> Integer List -> List)
  count-if (-> Procedure List -> Integer)
  drop (-> Integer List -> List)
  drop-while (-> Procedure List -> List)
  eighth (-> List -> Anything)
  element (-> List Integer -> Anything)
  fifth (-> List -> Anything)
  filter (-> Procedure List -> Anything)
  find (-> Procedure List -> Anything)
  first (-> List -> Anything)
  fourth (-> List -> Anything)
  head (-> List -> Anything)
  image (-> Procedure List -> List)
  indexes (-> List -> List)
  insert (-> List Integer Anything -> List)
  interleave (-> List List -> List)
  interpose (-> Anything List -> List)
  join (-> List Anything -> List)
  last (-> List -> Anything)
  list? (-> Anything -> Boolean)
  ninth (-> List -> Anything)
  not-any? (-> Procedure List -> Boolean)
  not-every? (-> Procedure List -> Boolean)
  partition (-> Procedure List -> List List)
  penult (-> List -> Anything)
  pop (-> List -> Anything)
  pop! (-> List -> Anything)
  position-if (-> Procedure List -> Integer)
  prefix-match? (-> List List -> Boolean)
  push (-> Anything List -> List)
  push! (-> Anything List -> List)
  pushnew (-> Anything List -> List)
  pushnew! (-> Anything List -> List)
  range (-> Integer Integer {} -> List)
  reduce (-> Procedure Anything List -> Anything)
  rest (-> List -> List)
  reverse (-> List -> List)
  second (-> List -> Anything)
  select (-> List List -> List)
  seventh (-> List -> Anything)
  shuffle (-> List -> List)
  sixth (-> List -> Anything)
  some? (-> Procedure List -> Boolean)
  sort (-> List Procedure -> List)
  split (-> List Procedure -> List)
  sublist (-> List Integer Integer -> List)
  suffix-match? (-> List List -> Boolean)
  tail (-> List -> List)
  tails (-> List -> List)
  take (-> Integer List -> List)
  take-by (-> Integer Integer List -> List)
  take-while (-> Procedure List -> List)
  tenth (-> List -> Anything)
  third (-> List -> Anything)
  trim (-> List List -> List)
  unique (-> List Procedure -> List)
  unzip (-> List -> List List)
  zip (-> List List -> List))

(define class Macro [Procedure])

(define class Method [Procedure]
  method? (-> Anything -> Boolean))

(define class MutableTable [Table]
  put! (-> MutableTable Anything Anything -> MutableTable)
  remove! (-> Anything MutableTable { :test Procedure } -> MutableTable))

(define class Name [Atom]
  bound? (-> Name -> Boolean)
  make-unbound! (-> Name -> Name))

(define class Nothing [*] ; Nothing is a subclass of all classes
  )

(define class Number [Atom])

(define class Package [MutableTable])

(define class Pair [List]
  left (-> Pair -> Anything)
  pair (-> Anything Anything -> Pair)
  pair? (-> Anything -> Boolean)
  right (-> Pair -> Anything))

(define class Pathname [ResourceName])

(define class Procedure [Atom]
  apply (-> Procedure List -> Anything)
  complement (-> Procedure -> Procedure)
  constantly (-> Anything -> Procedure))

(define class RandomState [Atom])

(define class Ratio [Rational])

(define class Rational [Real])

(define class ReadTable [MutableTable])

(define class Real [Number])

(define class Record [Structure])

(define class ResourceLocator [ResourceName])

(define class ResourceName [Name])

(define class Set [List])

(define class Setter [Accessor])

(define class Singleton [Type])

(define class Stream [Collection])

(define class Structure [Type]
  initialize (-> Structure {} -> Structure)
  slot-bound? (-> Structure Name -> Boolean)
  slot-exists? (-> Structure Name -> Boolean))

(define class Symbol [Name])

(define class Table [Collection]
  contains-key? (-> Table Anything { :test Procedure } -> Boolean)
  contains-value? (-> Table Anything { :test Procedure } -> Boolean)
  do-entries (-> Procedure Table -> Anything)
  do-keys (-> Procedure Table -> Anything)
  drop-all-keys (-> Table -> Table)
  get (-> Table Anything -> Anything)
  image (-> Procedure Table -> Table)
  keys (-> Table -> List)
  merge (-> Table Table * -> Table)
  put (-> Table Anything Anything -> Table)
  readtable? (-> Anything -> Boolean)
  table? (-> Table ->)
  tree-table? (-> Anything -> Boolean)
  vals (-> Table -> List))

(define class Text [HomogeneousVector])

(define class Tuple [Structure])

(define class Type [Atom]
  make (-> Type {} -> Anything)
  instance-of? (-> Anything Type -> Boolean)
  subtype? (-> Type Type -> Boolean))

(define class TypeSynonym [Type])

(define class Undefined [Anything])

(define class Union [Structure])

(define class Vector [Array List])

(define class Warning [Condition])

(define class Word [Integer])
