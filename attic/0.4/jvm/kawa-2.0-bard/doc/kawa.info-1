This is kawa.info, produced by makeinfo version 5.2 from kawa.texi.

START-INFO-DIR-ENTRY
* kawa: (kawa).         The Kawa Scheme language
END-INFO-DIR-ENTRY


File: kawa.info,  Node: Top,  Next: Installation,  Prev: (dir),  Up: (dir)

The Kawa Scheme language
************************

Kawa is a general-purpose programming language that runs on the Java
platform.  It aims to combine:
   • the benefits of dynamic scripting languages (non-verbose code with
     less boiler-plate, fast and easy start-up, a REPL
     (http://en.wikipedia.org/wiki/Read-eval-print_loop), no required
     compilation step); with
   • the benefits of traditional compiled languages (fast execution,
     static error detection, modularity, zero-overhead Java platform
     integration).
   It is an extension of the long-established Scheme
(http://www.schemers.org/) language, which is in the Lisp family of
programming languages.  Kawa has many *note useful features: Features.

   Kawa is also a useful *note framework: Framework. for implementing
other programming languages on the Java platform.  It has has many
useful utility classes.

   This documents version 2.0, updated 2 December 2014.  See the summary
of recent changes (http://www.gnu.org/software/kawa/news.html).

   The Kawa home page (which is currently just an on-line version of
this document) is <http://www.gnu.org/software/kawa/>.

   The (quite incomplete) Kawa tutorial (tutorial/index.html) can be
useful to get stated; it also also links to some other more in-depth
(but not Kawa-specific) Scheme tutorials.

   For copyright information on the software and documentation, see
*note License::.

   Various people and orgnizations *note have contributed to Kawa:
Acknowledgements.

   This package has nothing to do with the defunct Kawa commercial Java
IDE.

* Menu:

* Features::
* Community::
* Installation::         Building and installing Kawa
* Tutorial::             Kawa Scheme Tutorial
* Running::              Invoking, Running, and Using Kawa
* Syntax::
* Program structure::
* Multiple values::
* Symbols and namespaces::
* Procedures::
* Numbers::              Quantities and Numbers
* Characters and text::
* Data structures::
* Eval and Environments::
* Debugging::
* Input-Output::         Input, output, and file handling
* Types::
* Objects Classes and Modules::
* XML tools::            XML, HTML, and the web
* Miscellaneous::
* FAQs::                 Frequently Asked Questions
* Framework::            The Kawa language framework
* License::
* Overall Index::	 Index of functions, macros, concepts, and more.


File: kawa.info,  Node: Features,  Next: Community,  Up: Top

1 Features
**********

Runs on the Java platform, with no native code needed.

   Extends the Scheme language
(http://en.wikipedia.org/wiki/Scheme_%28programming_language%29),
following the R7RS (http://r7rs.org/) specification from 2013.  Scheme
has many implementations, and is much used in research and teaching.

   Programs run fast
(http://per.bothner.com/blog/2010/Kawa-in-shootout/) - roughly as fast
as Java programs, and much faster than other “scripting languages”.
This is due to a sophisticated compiler, compile-time transformations,
type inference, and optional type declarations.

   Full convenient and efficient access to the huge set of Java
libraries means you can access objects, methods, fields, and classes
without run-time overhead.

   Start-up times are fast.  You don’t have to wait for a lot of
initialization.  Even if you start with source code, the parser and
compiler are fast.

   *note Scripts:: are simple Kawa source files that can run as an
application or command.  These are simple to write, start start, and run
efficiently, since they’re automatically compiled before execution.

   Alternatively, you can embed Kawa as a *note scripting language for
Java applications: Evaluating Scheme expressions from Java.

   Deployment is easy and flexible.  You just need the Kawa jar file.

   *note Macros:: and *note custom named literals: Named quasi-literals.
make it easy to extend the syntax, and implement Domain-Specific
Languages.

   Kawa provides the usual read-eval-print loop, as well as batch modes.

   Kawa has builtin pretty-printer support, and fancy formatting.

   Kawa supports class-definition facilities, and separately-compiled
modules.

   You can *note allocate and initialize objects: Allocating objects.
with a compact “builder” syntax.  It works out-of-the-box (with no
run-time overhead) on many classes and APIs, but can be customized if
need be.

   *note JavaFX programming: Building JavaFX applications. is simpler.

   You can *note run Kawa programs on Android: Building for Android, and
there is special handing to make *note constructing View objects:
Android view construction. easier.

   Flexible shell-like functionality, including *note process
literals::.

   *note Web page scripts: Server-side scripts. are easy to write and
install with *note self-configuring web servers: Self-configuring page
scripts. and optionally using *note servlets: Servlets. and *note XML
literals::.

   Kawa implements the full numeric tower, including infinite-precision
rational numbers and complex numbers.  It also supports *note
Quantities:: with units, such as ‘3cm’.

   A *note lazy value: Lazy evaluation. wraps an expression which is
evaluated only when it is needed.

   Kawa provides a *note framework: Framework. for implementing other
programming languages, and comes with incomplete support for CommonLisp,
Emacs Lisp, and EcmaScript, and XQuery
(http://www.gnu.org/software/qexo/).

* Menu:

* Implemented SRFIs::
* Compatibility::        Compatibility with standards


File: kawa.info,  Node: Implemented SRFIs,  Next: Compatibility,  Up: Features

1.1 Implemented SRFIs
=====================

Kawa implements the following semi-standard SRFIs (Scheme Request for
Implementation (http://srfi.schemers.org/)):
   • SRFI 0 (http://srfi.schemers.org/srfi-0/srfi-0.html): Feature-based
     conditional expansion construct, using ‘cond-expand’ - *note Syntax
     and conditional compilation::.
   • SRFI 1 (http://srfi.schemers.org/srfi-1/srfi-1.html): List Library,
     if ‘(require 'list-lib)’ - *note SRFI-1::.
   • SRFI 2 (http://srfi.schemers.org/srfi-2/srfi-2.html): AND-LET*: an
     AND with local bindings, a guarded LET* special form.
   • SRFI 4 (http://srfi.schemers.org/srfi-4/srfi-4.html): Homogeneous
     numeric vector datatypes - *note Uniform vectors::.
   • SRFI 6 (http://srfi.schemers.org/srfi-6/srfi-6.html): Basic String
     Ports - *note Ports::.
   • SRFI 8 (http://srfi.schemers.org/srfi-8/srfi-8.html): ‘receive’:
     Binding to multiple values - *note Multiple values::.
   • SRFI 9 (http://srfi.schemers.org/srfi-9/srfi-9.html): Defining
     Record Types, using ‘define-record-type’ - *note Record types::.
   • SRFI 10 (http://srfi.schemers.org/srfi-10/srfi-10.html): ‘#,’
     external form for special named types.  This is deprecated for
     various reasons, including that it conflicts with syntax-case
     ‘unsyntax’.  Better to use srfi-108 *note Named quasi-literals::.
   • SRFI 11 (http://srfi.schemers.org/srfi-11/srfi-11.html): Syntax for
     receiving multiple values, using ‘let-values’ and ‘let*-value’ -
     *note Multiple values::.
   • SRFI 13 (http://srfi.schemers.org/srfi-13/srfi-13.html): String
     Library.  Needs some polishing.
   • SRFI 14 (http://srfi.schemers.org/srfi-14/srfi-14.html):
     Character-set Library - *note Character sets::.
   • SRFI 16 (http://srfi.schemers.org/srfi-16/srfi-16.html): Syntax for
     procedures of variable arity, using ‘case-lambda’
     (http://srfi.schemers.org/srfi-16/srfi-16.html).
   • SRFI 17 (http://srfi.schemers.org/srfi-17/srfi-17.html):
     Generalized ‘set!’ - *note Locations::.
   • SRFI 23 (http://srfi.schemers.org/srfi-23/srfi-23.html): Error
     reporting mechanism, using ‘error’ - *note Exceptions::.
   • SRFI 25 (http://srfi.schemers.org/srfi-25/srfi-25.html):
     Multi-dimensional Array Primitives - *note Arrays::.
   • SRFI 26 (http://srfi.schemers.org/srfi-26/srfi-26.html): Notation
     for Specializing Parameters without Currying - *note Procedures::.
   • SRFI 28 (http://srfi.schemers.org/srfi-28/srfi-28.html): Basic
     Format Strings - *note Format::.
   • SRFI 30 (http://srfi.schemers.org/srfi-30/srfi-30.html): Nested
     Multi-line Comments.
   • SRFI 37 (http://srfi.schemers.org/srfi-37/srfi-37.html):
     ‘args-fold’ - a program argument processor
     (http://srfi.schemers.org/srfi-37/srfi-37.html), if ‘(require
     'args-fold)’.
   • SRFI 38 (http://srfi.schemers.org/srfi-38/srfi-38.html): External
     Representation for Data With Shared Structure.  The
     ‘read-with-shared-structure’ is missing, but subsumed by ‘read’.
   • SRFI 39 (http://srfi.schemers.org/srfi-39/srfi-39.html): *Note
     Parameter objects::.
   • SRFI 41 (http://srfi.schemers.org/srfi-41/srfi-41.html): Streams -
     *note Streams::.
   • SRFI 45 (http://srfi.schemers.org/srfi-45/srfi-45.html): Primitives
     for Expressing Iterative Lazy Algorithms - *note Lazy evaluation::.
   • SRFI 60 (http://srfi.schemers.org/srfi-60/srfi-60.html): Integers
     as Bits.  - *note Logical Number Operations::.
   • SRFI 62 (http://srfi.schemers.org/srfi-62/srfi-62.html):
     S-expression comments.
   • SRFI 64 (http://srfi.schemers.org/srfi-64/srfi-64.html): A Scheme
     API for test suites.
   • SRFI 69 (http://srfi.schemers.org/srfi-69/srfi-69.html): Basic hash
     tables - *note Hash tables::.
   • SRFI 87 (http://srfi.schemers.org/srfi-87/srfi-87.html): ‘=>’ in
     ‘case’ clauses.
   • SRFI 88 (http://srfi.schemers.org/srfi-88/srfi-88.html): Keyword
     objects - *note Keywords::.
   • SRFI 95 (http://srfi.schemers.org/srfi-95/srfi-95.html): Sorting
     and Merging.
   • SRFI 97 (http://srfi.schemers.org/srfi-97/srfi-97.html): Names for
     SRFI Libraries.
   • SRFI 98 (http://srfi.schemers.org/srfi-98/srfi-98.html): An
     interface to access environment variables
   • SRFI 101 (http://srfi.schemers.org/srfi-101/srfi-101.html): Purely
     Functional Random-Access Pairs and Lists - *note SRFI-101::.
   • SRFI 107 (http://srfi.schemers.org/srfi-107/): XML reader syntax -
     *note XML literals::.
   • SRFI 108 (http://srfi.schemers.org/srfi-108/): Named quasi-literal
     constructors - *note Named quasi-literals::.
   • SRFI-109 (http://srfi.schemers.org/srfi-109/srfi-109.html):
     Extended string quasi-literals - *note string quasi-literals::.


File: kawa.info,  Node: Compatibility,  Prev: Implemented SRFIs,  Up: Features

1.2 Compatibility with standards
================================

Kawa implements all the required and optional features of R7RS, with the
following exceptions.

   The entire "numeric tower" is implemented.  However, some
transcendental function only work on reals.  Integral function do not
necessarily work on inexact (floating-point) integers.  (The whole idea
of "inexact integer" in R5RS seems rather pointless ...)

   Also, ‘call-with-current-continuation’ is only "upwards" (?).  I.e.
once a continuation has been exited, it cannot be invoked.  These
restricted continuations can be used to implement catch/throw (such as
the examples in R4RS), but not co-routines or backtracking.

   Kawa now does general tail-call elimination, but only if you use the
flag ‘--full-tail-calls’.  (Currently, the ‘eval’ function itself is not
fully tail-recursive, in violation of R5RS.) The ‘--full-tail-calls’
flag is not on by default, partly because it is noticably slower (though
I have not measured how much), and partly I think it is more useful for
Kawa to be compilatible with standard Java calling conventions and
tools.  Code compiled with ‘--full-tail-calls’ can call code compiled
without it and vice versa.

   Even without ‘--full-tail-calls’, if the compiler can prove that the
procedure being called is the current function, then the tail call will
be replaced by a jump.  This includes must “obvious” cases of calls to
the current function named using ‘define’ or ‘letrec’, and many cases of
mutual tail-recursion (including state-machines using ‘letrec’).

   The ‘equal?’ predicate does not handle infinite (self-referential)
data structures.  (Checking for cycles is difficult to implement
efficiently.)

   By default, symbols are case sensitive.

   Kawa implements most of the features of the expression language of
DSSSL, the Scheme-derived ISO-standard Document Style Semantics and
Specification Language for SGML. Of the core expression language, the
only features missing are character properties, ‘external-procedure’,
the time-relationed procedures, and character name escapes in string
literals.  From the full expression language, Kawa additionally is
missing ‘format-number’, ‘format-number-list’, and language objects.
Quantities, keyword values, and the expanded ‘lambda’ form (with
optional and keyword parameters) are supported.


File: kawa.info,  Node: Community,  Next: Installation,  Prev: Features,  Up: Top

2 The Kawa Community
********************

* Menu:

* Reporting bugs::       Where to report bugs
* Mailing lists::        Where to discuss changes, etc
* Acknowledgements::     Acknowledgements and thanks
* Support::              Technical support for Kawa
* Projects::             Projects using Kawa
* Ideas and tasks::      Ideas and tasks for contributing to Kawa


File: kawa.info,  Node: Reporting bugs,  Next: Mailing lists,  Up: Community

2.1 Reporting bugs
==================

To report a bug or feature request for Kawa (including Qexo or JEmacs),
it is best to use the bug-submission page
(http://savannah.gnu.org/bugs/?func=additem&group=kawa).  You can browse
and comment on existing bug reports using the Kawa Bugzilla page
(http://savannah.gnu.org/bugs/?group=kawa).

   When a bug report is created or modified, mail is automatically sent
to the <bug-kawa@gnu.org> list.  You can subscribe, unsubscribe, or
browse the archives through the ‘bug-kawa’ web interface
(http://mail.gnu.org/mailman/listinfo/bug-kawa).


File: kawa.info,  Node: Mailing lists,  Next: Acknowledgements,  Prev: Reporting bugs,  Up: Community

2.2 General Kawa email and discussion
=====================================

The general Kawa email list is <kawa@sourceware.org>.  This mailing list
is used for announcements, questions, patches, and general discussion
relating to Kawa.  If you wish to subscribe, send a blank message
request to <kawa-subscribe@sourceware.org>.  To unsubscribe, send a
blank message to <kawa-unsubscribe@sourceware.org>.  (If your mail is
forwarded and you’re not sure which email address you’re subscribed as
send mail to the address following ‘mailto:’ in the ‘List-Unsubscribe’
line in the headers of the messages you get from the list.)

   You can browse the archive of past messages
(http://sourceware.org/ml/kawa/).

   There are separate mailing lists for Qexo
(http://mail.gnu.org/mailman/listinfo/qexo-general) and JEmacs
(http://lists.sourceforge.net/mailman/listinfo/jemacs-info).


File: kawa.info,  Node: Acknowledgements,  Next: Support,  Prev: Mailing lists,  Up: Community

2.3 Acknowledgements and thanks
===============================

The author and project leader of Kawa is Per Bothner
(http://per.bothner.com/) <per@bothner.com>.

   Kawa is a re-write of Kawa 0.2, which was a Scheme interpreter
written by R. Alexander Milowski <alex@milowski.com>.

   Thanks to Cygnus Solutions (now part of Red Hat) for sponsoring the
initial development of Kawa, and then transferring their ownership
interest to Per.

Financial support
.................

Ean Schuessler and Brainfood (http://www.brainfood.com/) provided
financial support and encouragement.

   Thanks to Chris Dean, Dean Ferreyra, and others at Merced Systems
(http://www.mercedsystems.com/) for financial support and other
contributions.

   Google (http://google.com/) through their Summer of Code
(http://code.google.com/soc/) project sponsored Charles Turner during
Summer 2011 and 2012, and sponsored Andrea Bernardini Summer 2014.

   Thomas Kirk and AT&T provided financial support, and useful bug
reports.

Various contributions
.....................

Jakub Jankiewicz (http://jcubic.pl/) contributed the Kawa logo.

   Helmut Eller provided SLIME support, syntaxutils.scm, and many bug
reports.

   Daniel Bonniot for multiple small improvements to gnu.bytecode and
gnu.expr.

   Jamison Hope for multiple contributions, including quaternion
support, the SRFI-14 implementation, and Google Summer of Code
mentoring.

   Jim White for Ant support and other improvements.

   Bruce R. Lewis implemented *note KRL: KRL. and made other
contributions.

   Geoff Berry: Handle Exceptions attribute.  Other improvements.

   Shad Gregory improved JEmacs.

   Al Petrofsky improved gnu.math printing and added some IntNum
methods.

   Marco Vezzoli: SRFI-1 tailoring for Kawa.

   Albert Ting - old GuiConsole code.

   Christian Surlykke ported JEmacs to use SWT.

   Geoff Berry for various gnu.bytecode improvements.

   Ivelin Ivanov and Tom Reilly for servlet support.

   Anthony Green for Fedora packaging.

   Charles Turner for pretty-printer improvements, improvements in the
Common Lips support, and other changes.

   Andrea Bernardini optimized the implementation of ‘case’.

   Julien Rousseau and Marius Kjeldahl contributed to Android support.

Small fixes and improvements
............................

Patrick Barta; Joseph Bowbeer; Dominique Boucher; Alexander Bunkenburg;
Harold Carr; Emmanuel Castro; Álvaro Castro-Castilla; Heather Downs;
Francisco Vides Fernández; Nic Ferrier; Oliver Flasch; Weiqi Gao; Luke
Gorrie; Mario Domenech Goulart; Zvi Har’E; Jeff Haynes; Ethan Herdrick;
Joerg-Cyril Hoehle; Elliott Hughes; Mike Kenne; Brian Jones; Gerardo
Jorvilleur; Simon Josefsson (JEmacs menu); Thomas Kirk; Jay Krell;
Edouard Parmelan; Walter C. Pelissero; Rafael Jesus Alcantara Perez;
Lynn Quam; Marcus Otto; Terje Pedersen (some XQuery functions); Matthias
Radestock; Ola Rinta-Koski; Andreas Schlapbach; Robert D. Skeels; Benny
Tsai; Vladimir Tsichevski; Matthieu Vachon; Phil Walker; Knut Wannheden;
Chris Wegrzyn.

Bug reports and test cases
..........................

Seth Alves; Khairul Azhar; Bob Bane; Hans Boehm; Brian D. Carlstrom;
Luis Casillas; Ken Dickey (format tests); Helge Dietert; Allan Erskine;
Marc Feeley (polytype.scm); Margus Freudenthal; Weiqi Gao; Andrea
Girotto; Norman Hard; Gerardo Horvilleur; Yaroslav Kavenchuk; Felix S
Klock II; Francois Leygues; Mirko Luedde; Leonardo Valeri Manera; Kjetil
S. Matheussen; Alex Mitchell; Alex Moiseenko Edouard Parmelan; Walter C.
Pelissero; Stephen L. Peters; François Pinard; Bill Robinson; Dan
Stanger (Eaton Vance); Hallvard Traetteberg; Taylor Venable; Alessandro
Vernet; Tony White John Whittaker; Robert Yokota.

Code ported from other packages
...............................

Kawa includes Free Software originally written for other purposes, but
incorporated into Kawa, perhaps with some porting.  A partial list:

   Dorai Sitaram wrote pregexp.

   The ‘rationalize’ algorithm is by Alan Bawden and Marc Feeley.

   Lars T Hansen wrote SRFI-11 (let-values, let*-values macros).

   Olin Shivers wrote the SRFI-1 list-processing library, and the
SRFI-13 reference impementation.

   John David Stone wrote SRFI-8 (receive macro)

   Jussi Piitulainen wrote the SRFI-25 specification and tests.

   Richard Kelsey and Michael Sperber wrote SRFI-34.

   Anthony Carrico wrote the SRFI-37 reference implementation.

   Panu Kalliokoski wrote the SRFI-69 reference implementation.

   Donovan Kolbly wrote the srfi-64 “meta” testsuite.  Alex Shinn
improved SRFI-64 portability.

   Philip L. Bewig wrote the SRFI-41 (streams) specification and
reference implementation.

   Simon Tatham wrote listsort.

   Aubrey Jaffer wrote much of SLIB, some of which has been imported
into gnu.kawa.slib.  He also wrote some tests we’re using.


File: kawa.info,  Node: Support,  Next: Projects,  Prev: Acknowledgements,  Up: Community

2.4 Technical Support for Kawa
==============================

If you have a project that depends on Kawa or one of its component
packages, you might do well get get paid priority support from Kawa’s
author.

   The base price is $2400 for one year.  This entitles you to basic
support by email or phone.  Per <per@bothner.com> will answer techical
questions about Kawa or its implementation, investigate bug reports, and
suggest work-arounds.  I may (at my discretion) provide fixes and
enhancements (patches) for simple problems.  Reponse for support
requests received using the day (California time) will normally be
within a few hours.

   All support requests must come through a single designated contact
person.  If Kawa is important to your business, you probably want at
least two contact people, doubling the price.

   If the support contract is cancelled (by either party), remaining
time will be prorated and refunded.

   Per is also available for development projects.


File: kawa.info,  Node: Projects,  Next: Ideas and tasks,  Prev: Support,  Up: Community

2.5 Projects using Kawa
=======================

MIT App Inventor (http://appinventor.mit.edu/) for Android (formerly
Google App Inventor) uses Kawa to translate its visual blocks language.

   The HypeDyn (http://www.narrativeandplay.org/hypedyn/) hypertext
fiction authoring tool is written in Kawa.  HypeDyn (pronounced "hyped
in") is a procedural hypertext fiction authoring tool for people who
want to create text-based interactive stories that adapt to reader
choice.  HypeDyn is free to download and open source, and runs on Linux,
MacOS and Windows.  This is a research project carried out at the
Department of Communications and New Media, National University of
Singapore.

   Nü Echo (http://www.nuecho.com) develops high-performance speech
enabled applications.  Nü Echo uses Kawa for the development of
innovative speech application development tools, like a complete grammar
IDE (http://www.nuecho.com/en/services/grammar.shtml).

   Merced Systems, Inc.  (http://www.mercedsystems.com/) uses Kawa
extensively in their contact center performance management product
Merced Peformance Suite.  Kawa Scheme is used for all development and
has allowed Merced to realize the large productivity gains that come
with using Scheme while still maintaining tight integration with a large
number of Java libraries.

   JEmacs is included in the Kawa distribution.  It is a project to
re-implement Emacs, allowing a mix of Java.  Scheme, and Emacs Lisp.  It
has its own home-page (http://jemacs.sourceforge.net/).

   BRL ("the Beautiful Report Language") is a database-oriented language
to embed in HTML and other markup.  BRL (http://brl.sourceforge.net/)
allows you to embed Scheme in a an HTML file on a web server.

   The SchemeWay Project (http://schemeway.sourceforge.net) is a set of
Eclipse (http://www.eclipse.org) plug-ins for professional Scheme
programming.  The first plugin released, SchemeScript, is a
fully-featured Scheme editor customizable in Scheme.  It embeds the Kawa
Scheme system and has many features that ease Kawa Scheme programming
(like code completion on variable names, class and method names,
namespaces, etc).

   The Health Media Research Laboratory, part of the Comprehensive
Cancer Center at the University of Michigan, is using Kawa as an
integral part of its core tailoring technologies.  Java programs using
Kawa libraries are used to administer customized web-based surveys,
generate tailored feedback, validate data, and "characterize," or
transform, data.  Kawa code is embedded directly in XML-formatted
surveys and data dictionaries.  Performance and ease of implementation
has far exceeded expectations.  For more information contact Paul R.
Potts, Technical Director, Health Media Research Lab,
‘<potts@umich.edu>’.

   Mike Dillon (‘mdillon@gjt.org’) did the preliminary work of creating
a Kawa plugin for jEdit.  It is called SchemeShell and provides a REPL
inside of the jEdit console for executing expressions in Kawa (much as
the BeanShell plugin does with the BeanShell scripting language).  It is
currently available only via CVS from:
     CVSROOT=:pserver:anonymous@cvs.jedit.sourceforge.net:/cvsroot/jedit
     MODULE=plugins/SchemeShell

   STMicroelectronics (‘marco.vezzoli@st.com’) uses Kawa in a prototypal
intranet 3tier information retrival system as a communication protocol
between server and clients and to do server agents programming.


File: kawa.info,  Node: Ideas and tasks,  Prev: Projects,  Up: Community

2.6 Ideas and tasks for contributing to Kawa
============================================

Kawa (like other Free Software projects) has no lack of tasks and
projects to work on.  Here are some ideas.

2.6.1 Compiler should use class-file reading instead of reflection
------------------------------------------------------------------

The Kawa compiler currently uses reflection to determine properties
(such as exported function definitions) from referenced classes.  It
would be better to read class files.  This should not be too difficult,
since the ‘gnu.bytecode’ library abstracts over class information read
by reflection or class reading.

2.6.2 Mutually dependent Java and Scheme modules
------------------------------------------------

We’d like a command for compiling compile a list of Java and Scheme
source files thar may have mutual dependencies.  A good way to do this
is to hook into ‘javac’, which is quite extensible and pluggable.

   One could do something like:
  1. Read the "header" of each Kawa source file, to determine the name
     of the generated main class.
  2. Enter these class names into the javac tables as “uncompleted”
     classes.
  3. Start compiling the Java files.  When this requires the members of
     the of the Kawa classes, switch to the Kawa files.  From javac,
     treat these as pre-compiled .class files.  I.e.  we treat the Kawa
     compiler as a black box that produces Symbols in the same way as
     reading class files.  At this point we should only need to the
     initial “scan” phase on Kawa.
  4. If necessary, finish compiling remaining Kawa files.

   This approach may not immediately provide as robust mixed-language
support as ideal, but it is more amenable to incremental improvement
that a standalone stub-generator.

   This project is good if you know or want to learn how ‘javac’ works.

2.6.3 Make use of Java-7 MethodHandles
--------------------------------------

Java 7 supports MethodHandles which are meant to provide better
performance (ultimately) for dynamic languages.  See JSR 292
(http://jcp.org/en/jsr/detail?id=292) and the Da Vinci Machine Project
(http://openjdk.java.net/projects/mlvm/).  MethodHandles will be used to
compile lambdas in Java 8.  Kawa can already be compiled to use
Methodhandles, but only in one unimportant way.  There much more to be
done.  For example we can start by optimizing arithmetic when the types
are unknown at compile-time.  They could make implementing generic
functions (multimethods) more efficient.  At some point we want to
compile lambdas in the same way as the Java 8 preview does.  This can
potenitally be more efficient than Kawa’s current mechanism.

2.6.4 R6RS and R7RS libraries and syntax
----------------------------------------

Kawa supports most of the functionality of R6RS and R7RS. However,
various R6R7 or (more importantly) R7RS features are missing, and should
be added.  For example, both R6RS or R7RS library definition syntax are
unimplemented.  In a related matter, Kawa supports most of the
functionality of ‘syntax-case’, but some pieces are missing, and no
doubt some of it is incorrect.  Adding the missing pieces and testing
for correctness of corner cases is needed.  Andre van Tonder’s R6RS
expander
(http://lists.r6rs.org/pipermail/r6rs-discuss/2007-October/003387.html)
may be helpful.

   It would be useful to extend the ‘import’ form (and also the
‘require’ form when no explicit filename is given) to search a “source
path” for a matching source file, automatically compiling it as needed
(as done in the ‘require’ form when an explicit filename is given).  In
interactive mode, if the module is already loaded, check if it is
updated - if not recompile and re-load it.

2.6.5 Parameterized types
-------------------------

Kawa has some limited support for parameterized types, but it’s not used
much.  Improve type inferencing.  Support definition of parameterized
classes.  Better used of parameterized types for sequence class.
Support wildcards.  (It might be better to have wild-carding be
associated with declarations, as in Scala, rather than uses.)

2.6.6 Function types
--------------------

Kawa doesn’t have true function types: Parameter and result types are
only handled for “known” functions.  Adding first-class function types
would be a major task, possibly depending on improvements in *note
Parameterized types: task-parameterized-types.

2.6.7 Full continuations
------------------------

Add support for full continuations, which is the major feature missing
for Kawa to qualify as a “true Scheme”.  One way to implement
continuations is to add a add that converts the abstract syntax tree to
continuation-pass-style, and then exhand the existing full-tail-call
support to manage a stack.  There are other ways to solve the problem.
This may benefit from *note Faster tailcalls: task-faster-tailcalls.

2.6.8 Faster tailcalls
----------------------

Make ‘--full-tailcalls’ run faster.  This may depend on (or incorporate)
*note TreeList-optimization: task-TreeList-optimization.

2.6.9 TreeList-optimization
---------------------------

The TreeList
(http://www.gnu.org/software/kawa/api/gnu/lists/TreeList.html) class is
a data structure for “flattened” trees.  It is used for XML-style nodes,
for multiple values, and for the full-tail-call API. The basic concept
is fine, but it could do with some re-thinking to make make
random-access indexing fast.  Also, support for updating is
insufficient.  (This needs someone into designing and hacking on
low-level data-structures, along with lots of profiling and testing.)

2.6.10 Asynchronous evaluation
------------------------------

C# recently added ‘asynch’ and ‘await’ keywords for asynchronous
programming (http://msdn.microsoft.com/en-us/vstudio/gg316360).  Kawa’s
recently improved support for lazy programming seems like a good
framework for equivalent functionality: Instead of an ‘asynch’ method
that returns a ‘Task<T>’ the Kawa programmer would write a function that
returns a ‘lazy[T]’.  This involves some design work, and modifying the
compiler to rewrite the function body as needed.

   This is related to full continuations, as the re-writing is similar.

2.6.11 REPL console and other REPL improvement
----------------------------------------------

Improvements to the read-eval-print console.  In addition to a
traditional Swing console, it would be useful to support using a web
browser as a a remote terminal, possibly using web-sockets.  (This
allows “printing” HTML-expressions, which can be a useful way to learn
and experiment with web technologies.)  See here
(http://per.bothner.com/blog/2007/ReplPane/) for an article on the
existing Swing REPL, along with some to-do items.  Being able to hide
and show different parts of the output might be nice.  Being able to
link from error messages to source might be nice.  Better handling of
redefinitions is discussed here in the context of JavaXF Script
(http://per.bothner.com/blog/2009/REPL-for-JavaFX/); this is a general
REPL issue, mostly independent of the GUI for it.

   An interesting possibility is to use the IPython
(http://ipython.org/) framework.  There are existing ports for Scala:
either IScala (https://github.com/mattpap/IScala) or Scala Notebook
(https://github.com/Bridgewater/scala-notebook).

2.6.12 XQuery-1.1-functionality
-------------------------------

It would be nice to update the XQuery (Qexo) support to XQuery 1.1
(http://www.w3.org/TR/xquery-30/).

2.6.13 XQuery-updates
---------------------

It would be nice to support XQuery updates
(http://www.w3.org/TR/xquery-update-10/).  This depends on *note
TreeList-optimization: task-TreeList-optimization.

2.6.14 Common Lisp support
--------------------------

Kawa supports a small subset of the Common Lisp language, but it
supports a much larger subset of core Common Lisp concepts and data
structure, some designed with Common Lisp functionality in mind.
Examples include packages, arrays, expanded function declarations, type
specifications, and format.  A lot could be done to improve the Common
Lisp support with modest effort.  Some Common Lisp features could also
be useful for Scheme: Documentation strings (or markup) as Java
annotations, better MOP-like introspection, and generic methods a la
defmethod (i.e.  with multiple definition statements, possibly in
separate files, as opposed to the current make-procedure) all come to
mind.  Being able to run some existing Common Lisp code bases with at
most modest changes should be the goal.  One such package to start with
might be a existing test framework
(http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html),
perhaps FivaAM (http://common-lisp.net/project/bese/FiveAM.html).  Full
Common Lisp compatibility is nice, but let’s walk before we can run.

2.6.15 JEmacs improvements
--------------------------

A lot of work is needed to make JEmacs (http://jemacs.sourceforge.net/)
useful.  One could try to import a useful package and see what works and
what fails.  Or one may look at basic editing primitives.  Enhancements
may be needed to core Emacs Lisp language primitives (enhancing *note
Common Lisp support: task-common-lisp. may help), or to the display
engine.

   Emacs now supports lexical bindings
(http://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html)
- we should do the same.

2.6.16 Improved IDE integration
-------------------------------

There is some Kawa support for Eclipse (Schemeway), and possibly other
IDEs (NetBeans, IntelliJ). But many improvements are desirable.  *note
REPL improvements: task-REPL-improvements. may be a component of this.

2.6.16.1 Plugin for NetBeans IDE
................................

Kawa-Scheme support for the NetBeans IDE would be useful.  One could
perhaps build on the Clojure plugin.

2.6.16.2 Plugin for Eclipse IDE
...............................

Kawa-Scheme support for the Eclipse IDE would be useful.  Probably makes
sense to enhance SchemeWay (http://sourceforge.net/projects/schemeway/).
It may also make sense to build on the Dynamic Languages Toolkit
(http://www.eclipse.org/dltk/), possibly making use of Schemeide
(http://schemeide.sourceforge.net/), though DLTk seems more oriented
towards interpreted non-JVM-based languages.

2.6.16.3 Improve Emacs integration
..................................

SLIME (http://en.wikipedia.org/wiki/SLIME) is an Emacs mode that
provides IDE-like functionality.  It supports Kawa.

   JDEE (http://jdee.sourceforge.net/) is a Java development
environment, so might have better hooks to the JVM and Java debugging
architecture.

   CEDET (http://cedet.sourceforge.net/) is a more general framework of
development tools.

2.6.16.4 Implement ‘javax.tools’ and code-range support in Kawa compiler
........................................................................

Kawa currently records the line and column position of syntactic
elements.  For an IDE it is desirable to have both start and end
position of an element, for example so it can put a squiggly line under
an erroneous form.

2.6.17 Output formatting and pretty printing
--------------------------------------------

It would be nice to integrate the pretty-printer with the REPL, so that
window re-sizing re-breaks the output lines.  It would be nice to
enhance the pretty-printer to handle variable-width fonts and other
“rich” text.  Figuring out how to make the output formatter more
flexible, more efficient, and more customizable are also desirable.

2.6.18 Hop-style web programming
--------------------------------

Hop (http://hop.inria.fr/) is an interesting design for integrating
server-side and client-side programming using a Scheme dialect.  These
ideas seem like they would port quite well to Kawa.

2.6.19 String localization
--------------------------

Support localization by extending the SRFI_109
(http://srfi.schemers.org/srfi-109/srfi-109.html) syntax, in the manner
of (and compatible with) GNU gettext
(http://www.gnu.org/software/gettext/).  I.e.  optionally specify a
localization key (to use as an index in the translation database); if
there is no key specified, default to using the literal parts of the
string.

2.6.20 Data binding
-------------------

Implement a “bind” mechanism similar to that of JavaFX Script
(http://docs.oracle.com/javafx/1.3/tutorials/core/dataBinding/).  The
idea is when you initialize a variable or field, instead of initializing
it to a fixed value, you bind it to an expression depending on other
variables.  We install “listeners” on those variables, so when those
variables change, we update the bound variable.  This feature is useful
in many application, but the initial focus could be GUI programming and
perhaps web programming.

2.6.21 Better dynamic reload
----------------------------

Kawa does a lot of optimizations and inlining.  This conflicts with
being able to “reload” a module into an already-running interactive
environment.

   We could add an option to load a module in “reloadable” mode.  Kawa
already patches an old function object (a ‘ModuleMethod’) so existing
references to the function get automatically updated.  However, there
are problems if the “signature” of the function changes - for example if
the return type (declared or inferred) becomes more general.  In those
cases the best thing is to re-compile any code that depends on the
modified function.

   Reloading a module that defines a class is even trickier, at least if
there are existing instances that should work as the updated class.  We
can handle the special case where only method bodies change: In
reloadable mode, each method body is compiled to a separate function,
the actual body indirects to the function.  We must also recognize that
we compiling a new version of the same class, which requires a textual
comparison between the old and new versions, or a structural comparison
between the old class and the new code.

   When it comes to top-level variables, an issue is when to re-evaluate
the initializing expression.  It is reasonable to do so if and only if
the expression is modified, which again requires a textual comparison.


File: kawa.info,  Node: Installation,  Next: Tutorial,  Prev: Community,  Up: Top

3 Getting and installing Kawa
*****************************

* Menu:

* Getting Kawa::
* Running Java::                Getting and running Java
* Binary distribution::         Installing and using the binary distribution
* Source distribution::         Installing and using the source distribution


File: kawa.info,  Node: Getting Kawa,  Next: Running Java,  Up: Installation

3.1 Getting Kawa
================

You can compile Kawa from the source distribution.  Alternatively, you
can install the pre-compiled binary distribution.

   You can get Kawa sources and binaries from the Kawa ftp site
<ftp://ftp.gnu.org/pub/gnu/kawa/>, or from a mirror site
(http://www.gnu.org/order/ftp.html).

   The latest release of the Kawa source code is
<ftp://ftp.gnu.org/pub/gnu/kawa/kawa-2.0.tar.gz>.  (To unpack ‘.tar.gz’
files Windows users can use 7-Zip (http://www.7-zip.org/), which is Free
Software.)

   A ready-to-run ‘.jar’ archive of the pre-compiled classes is in
<ftp://ftp.gnu.org/pub/gnu/kawa/kawa-2.0.jar>.

3.1.1 Getting the development sources using SVN
-----------------------------------------------

The Kawa sources are managed using a Subversion (svn)
(http://subversion.apache.org/) repository.  If you want the very latest
version grab an svn client (http://subversion.apache.org/download/), and
then check out the source using this command:
     svn -q checkout svn://sourceware.org/svn/kawa/trunk kawa

   Some corporate firewalls may block outgoing Subversion connections.
If that case you should be able to access the Kawa Subversion repository
using HTTP. (If you need to use an HTTP proxy, you can edit
‘http-proxy-host’ and ‘http-proxy-port’ in ‘~/.subversion/servers’ as
described here (http://subversion.apache.org/faq.html#proxy).)  Use this
command instead:
     svn -q checkout http://sourceware.org/svn/kawa/trunk kawa

   Once you have it checked out, you can keep it up-to-date with ‘svn
update’.

   You can also browse the svn archive
(http://sourceware.org/viewvc/kawa/) via viewvc.


File: kawa.info,  Node: Running Java,  Next: Binary distribution,  Prev: Getting Kawa,  Up: Installation

3.2 Getting and running Java
============================

Before installing Kawa, you will need a working Java system.  The
released Kawa jar file assumes Java 7 or newer.  You need to build Kawa
from source if you have Java 5, Java 6, or are targeting Android.
(Older versions of Kawa have been reported to work with JDK from 1.1,
Kaffe, Symantec Cafe, J++, and GCJ, but these are no longer supported.)

   The discussion below assumes you are using the Java Developer’s Kit
(JDK) from Oracle.  You can download free copies of JDK 8
(http://www.oracle.com/technetwork/java/javase/downloads/index.html) for
various platforms.

   If you want to run Kawa on a Macintosh, see
<http://rdsathene.org/scheme/mackawa.html>.

   The program ‘java’ is the Java interpreter.  The program ‘javac’ is
the Java compiler, and is needed if you want to compile the source
release yourself.  Both programs must be in your ‘PATH’.  If you have
the JDK in directory ‘$JAVA_HOME’, and you are using a Bourne-shell
compatible shell (/bin/sh, ksh, bash, and some others) you can set
‘PATH’ thus:
     PATH=$JAVA_HOME/bin:$PATH
     export PATH


File: kawa.info,  Node: Binary distribution,  Next: Source distribution,  Prev: Running Java,  Up: Installation

3.3 Installing and using the binary distribution
================================================

The binary release includes only the binary compiled ‘.class’ versions
of the same ‘.java’ source files in the source release.  It does not
include any documentation, so you probably want the source release in
addition to the binary release.  The purpose of the binary release is
just to save you the time and trouble of compiling the sources.

   The binary release requires Java 7 or later.  If you have an older
Java implementation, or build for a mobile environment like Android,
then you will need to get the source distribution.

   The binary release comes as a ‘.jar’ archive ‘kawa-2.0.jar’.  Copy
this archive to some suitable location, such as
‘/usr/local/lib/kawa.jar’.

   Then, before you can actually run Kawa, you need to set ‘CLASSPATH’
so it includes the Kawa archive.  On Unix, using a Bourne-style shell:
     CLASSPATH=/usr/local/lib/kawa.jar
     export CLASSPATH

   On Windows you need to set ‘classpath’ in a DOS console.  For
example:
     set classpath=\kawa\kawa-2.0.jar

   Then to run Kawa do:
     java kawa.repl

   To run Kawa in a fresh window, you can do:
     java kawa.repl -w


File: kawa.info,  Node: Source distribution,  Prev: Binary distribution,  Up: Installation

3.4 Installing and using the source distribution
================================================

The Kawa release normally comes as a gzip-compressed tar file named
‘kawa-2.0.tar.gz’.  Two methods are supporting for compiling the Kawa
sources; choose whichever is most convenient for you.

   One method uses the traditional GNU ‘configure’ script, followed by
running ‘make’.  This works well on Unix-like systems, such as
GNU/Linux.  You can also use this method on Microsoft Windows, as long
as use <http://www.cygwin.org/. Cygwin>.

   The other method uses the ‘ant’ command, a Java-based build system
released by Apache’s Jakarta project.  This uses an ‘build.xml’ file in
place of ‘Makefile’s, and works on non-Unix systems such as Microsoft
Windows.  However, the ‘ant’ method does not support all the features of
the ‘configure’+‘make’ method.

3.4.1 Build Kawa using ‘configure’ and ‘make’
---------------------------------------------

In your build directory do:
     tar xzf kawa-2.0.tar.gz
     cd kawa-2.0

   Then you must configure the sources.  This you can do the same way
you configure most other GNU software.  Normally you can just run the
configure script with no arguments:

     ./configure

   This will specify that a later ‘make install’ will install the
compiled ‘.class’ files into ‘/usr/local/share/java’.  If you want them
to be installed someplace else, such as ‘$PREFIX/share/java’, then
specify that when you run configure:
     ./configure --prefix $PREFIX

   If you have the GNU ‘readline’ library installed, you might try
adding the ‘--enable-kawa-frontend’ flag.  This will build the ‘kawa’
front-end program, which provides input-line editing and an input
history.  You can get ‘readline’ from archives of GNU programs,
including <ftp://www.gnu.org/>.

   If you have Swing installed, and want to use JEmacs (Emacs in Java),
also pass the ‘--with-swing’ flag to ‘configure’.

   If you have installed Kawa before, make sure your ‘CLASSPATH’ does
not include old versions of Kawa, or other classes that may conflict
with the new ones.

   As distributed, the Kawa source code requires Java 7.  If you only
have Java 6 or Java 5, use the ‘--with-have-source’ option:
     ./configure --with-java-source=5

   Kawa no longer supports older verisons of Java (JDK 1.4 or older).
It might be possible to use a tool like Retroweaver
(http://retroweaver.sourceforge.net/) on the Kawa ‘.jar’ to fix up Java
5 dependencies.  Contact the Kawa author if you want to be a tester for
this.

   Then you need to compile all the .java source files.  Just run make:
     make
   This assumes that ‘java’ and ‘javac’ are the java interpreter and
compiler, respectively.  For example, if you are using the Kaffe Java
interpreter, you need to instead say:
     make JAVA=kaffe

   It has been reported that parallel make doesn’t work, so don’t use
the ‘-j2’ or above options.

   If you configured with ‘--enable-kawa-frontend’, you may need to
specify ‘READLINE_INCLUDE_PATH’ or ‘READINE_LIB_PATH’.  For example on
OS/X you need to do:
     make READLINE_INCLUDE_PATH=-I/usr/local/unix/readline/include \
          READLINE_LIB_PATH=-L/usr/local/unix/readline/lib

   You can now test the system by running Kawa in place:
     java kawa.repl

   or you can run the test suite:
     make check

   or you can install the compiled files:
     make install

   This will install your classes into ‘$PREFIX/share/java’ (and its
sub-directories).  Here ‘$PREFIX’ is the directory you specified to
configure with the ‘--prefix’ option, or ‘/usr/local’ if you did not
specify a ‘--prefix’ option.

   To use the installed files, you need to set ‘CLASSPATH’ so that
‘$PREFIX/share/java/kawa.jar’ is in the path:
     CLASSPATH=$PREFIX/share/java/kawa.jar
     export CLASSPATH
   This is done automatically if you use the ‘kawa’ script.

3.4.2 Build Kawa using ‘ant’
----------------------------

Kawa now includes an Ant buildfile (‘build.xml’).  Ant
(http://ant.apache.org) is a part of the Apache Jakarta project.  If you
don’t hava Ant installed, get it from
<http://ant.apache.org/bindownload.cgi>.  The build is entirely Java
based and works equally well on *nix, Windows, and presumably most any
other operating system.

   Once Ant has been installed and configured (you may need to set the
‘JAVA_HOME’, and ‘ANT_HOME’ environment variables), you should be able
to change to the directory containing the ‘build.xml’ file, and invoke
the ‘ant’ command.  With the default settings, a successful build will
result in a ‘kawa-2.0.jar’ in the current directory.

   There are a few Ant "targets" of interest (they can be supplied on
the Ant command line):

‘all’
     This is the default, it does ‘classes’ and ‘jar’.
‘classes’
     Compiles all the files into ‘*.class’ files into the directory
     specified by the ‘build.dir’ property.
‘jar’
     Builds a jar into into the directory specified by the ‘dist.dir’
     property.
‘runw’
     Run Kawa in a GUI window.
‘clean’
     Deletes all files generated by the build, including the jar.

   There is not yet a ‘test’ target for running the testsuite.

   The are various "properties" that control what ‘ant’ does.  You can
override the on the command line or by editing the ‘build.properties’
file in the same directory as ‘build.xml’.  For example the ‘build.dir’
directory tells ‘ant’ where to build temporary files, and where to leave
the resulting ‘.jar’ file.  For example, to leave the generated files in
the sub-directory named ‘BUILD’ do:
     ant -Dbuild.dir=BUILD
   A sample ‘build.properties’ is provided and it contains comments
explaining many of the options.

   Here are a few general properties that help to customize your build:
‘build.dir’
     Path to put the temporary files used for building.
‘dist.dir’
     Path to put the resulting jar file.
‘version.local’
     A suffix to add to the version label for your customized version.
‘debug’
     Whether (true/false) the Javac "-g" option is enabled.
‘optimize’
     Whether (true/false) the Javac "-O" option is enabled.

   Here are some Kawa-specific ones (all ‘true’/‘false’):
‘with-collections’, ‘with-references’, ‘with-awt’, ‘with-swing’,
‘enable-jemacs’, and ‘enable-servlet’> See the sample ‘build.properties’
for more information on these.

   If you change any of the build properties, you will generally want to
do an ‘ant clean’ before building again as the build is often not able
to notice that kind of change.  In the case of changing a directory
path, you would want to do the ‘clean’ before changing the path.

   A special note for NetBeans users: For some reason the build-tools
target which compiles an Ant task won’t compile with the classpath
provided by NetBeans.  You may do ‘ant build-tools’ from the command
line outside of NetBeans, in which case you will not want to use the
‘clean’ target as that will delete the tool files as well.  You can use
the ‘clean-build’ and/or ‘clean-dist’ targets as appropriate.
Alternatively you can add ‘ant.jar’ to the ‘build-tools’ classpath by
copying or linking it into a ‘lib/ext’ directory in Kawa’s source
directory (the one containing the ‘build.xml’ file).

3.4.3 Building Kawa under MS-Windows
------------------------------------

Using the ‘ant’ method is recommended for building Kawa under Microsoft
Windows.  You may get an error message "‘Out of environment space’."
See <http://support.microsoft.com/support/kb/articles/Q230/2/05.ASP> for
a solution.  Alternatively you can run the class
‘org.apache.tools.ant.Main’ directly from the Ant jar.

   The Kawa ‘configure’ and ‘make’ process assumes a Unix-like
environment.  The free Cygwin (http://sourceware.org/cygwin/)
environment can be used for building Kawa: The Kawa configure script
recognizes Cygwin, and modifies the classpath to use Windows-style path
separators.  (At the time of writing there were still some path issues
with running the testsuite.)

   MinGW (http://www.mingw.org/) may also work but has not been tested.


File: kawa.info,  Node: Tutorial,  Next: Running,  Prev: Installation,  Up: Top

4 Kawa Scheme Tutorial
**********************

_This is obviously incomplete, but it may be useful, especially if
you’re starting with Kawa from scratch._  If you’re new to Scheme you
might also check out one of these tutorials: Takafumi Shido’s Yet
Another Scheme Tutorial (http://www.shido.info/lisp/idx_scm_e.html);
Dorai Sitaram’s Teach Yourself Scheme in Fixnum Days
(http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html); or
Paul Wilson’s An Introduction to Scheme and its Implementation
(ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html).

* Menu:

* Tutorial - Introduction::      Introduction
* Tutorial - Booleans::          Booleans
* Tutorial - Numbers::           Numbers
* Tutorial - Functions::         Functions
* Tutorial - Variables::         Variables
* Tutorial - Sequences::         Lists and sequences
* Tutorial - Types::             Types and declarations
* Tutorial - Classes::           Classes


File: kawa.info,  Node: Tutorial - Introduction,  Next: Tutorial - Booleans,  Up: Tutorial

4.1 Introduction
================

You’ve heard about all the hot scripting languages – you might even be
tired of hearing about them.  But Kawa offers you something different
than the scripting-language du-jour can.  You may be interested in one
that runs on the Java virtual machine, either because you have to
interact with other Java tools, or because you like having access to all
the Java packages out there.  Or maybe you don’t care about Java, but
you care about performance.  If so, let me tell you about Kawa, which is
actually one of the very oldest language implementations running on the
Java Virtual Machine, dating back to 1996.

   The Kawa language is a dialect/implementation of the Scheme language.
(The Kawa project also supports other languages, including XQuery
(http://www.w3.org/XML/Query) and Emacs Lisp
(http://jemacs.sourceforge.net), as well as tools for implementing mew
programming languages, but we won’t cover that in this tutorial.)

   Scheme (http://www.schemers.org/) is an established language with
many implementations
(http://community.schemewiki.org/?scheme-faq-standards#implementations),
a standard (http://www.schemers.org/Documents/Standards/) specification
(the traditional R5RS
(http://www.schemers.org/Documents/Standards/R5RS/), R6RS
(http://www.r6rs.org/) which was ratified in 2007, and R7RS
(http://www.r7rs.org/) which was ratified in 2013), and is used by
universities for both teaching and research.  Scheme also has a
reputation for being difficult to learn, with a weird parenthesis-heavy
syntax, and hard-to-understand concepts like continuations
(http://en.wikipedia.org/wiki/Continuation).  Luckily, you don’t need to
understand continuations!  (Kawa doesn’t fully implement them anyway.)

   The following assumes that Kawa is already installed on your
computer; if not see these *note installation instructions:
Installation.  Running the ‘kawa’ command in interactive mode is a good
way start learning Kawa:
     $ kawa
     #|kawa:1|#
   If you don’t have ‘kawa’ but you have a Kawa “jar” and you have Java
installed you can instead do:

     $ java -jar kawa-VERSION-NUMBER.jar
     #|kawa:1|#

   The prompt string has the form of a Scheme comment, to make it easier
to cut-and-paste.  Kawa is expecting you type type in an expression or
command, which it will evaluate and print out the result.  For example a
quoted string is a simple expression that evaluates to a string value,
which will print as itself, before printing the next prompt:

     #|kawa:1|# "Hello, world!"
     Hello, world!
     #|kawa:2|#

   The most noticable difference from most other programming languages
is that Scheme uses “prefix” notation for function calls.  For example
Kawa has a function ‘max’ which returns the largest value of the
arguments.  Instead of ‘max(5, 7, 3)’ you write ‘(max 5 7 3)’:

     (max 5 7 3) ⇒ 7

   (We use the ‘⇒’ symbol above to indicate that the expression ‘(max 5
7 3)’ evaluates to the value ‘7’.)

   The prefix notation may feel a bit weird, but you quickly get used to
it, and it has some advantages.  One is consistency: What are special
infix operators in most languages in most languages are just regular
functions in Scheme.  For example addition is just a regular ordinary
function call, and ‘+’ is just a regular function name:
     (+ 2.5 1.2) ⇒ 3.7

   The same prefix notation is used for special operations like
assignments:
     #|kawa:1|# (set! sqrt-of-2 (sqrt 2))
     #|kawa:2|# sqrt-of-2
     1.4142135623730951


File: kawa.info,  Node: Tutorial - Booleans,  Next: Tutorial - Numbers,  Prev: Tutorial - Introduction,  Up: Tutorial

4.2 Booleans
============

Scheme uses the syntax ‘#t’> and ‘#f’ for Boolean true and false value.
For example the “less-than” function is named ‘<’.  Its result is true
if the first argument is less than the second (or if there are more than
two arguments: that they are in increasing order):
     (< 3 4) ⇒ #t
     (< -3 -4) ⇒ #f
     (< 2 3 5 7 11)) ⇒ #t

   The ‘if’ special form takes two or three sub-expressions: It
evaluates the first expression.  If that is true it evaluates the second
expression; otherwise it evaluates the third expression, if provided:
     (if (< 3 4) (+ 5 5) (+ 5 6)) ⇒ 10

   We call ‘if’ a special form rather than a function, because for a
function all the arguments are evaluated before the function is called,
but in a special form that is not neceassarily the case.

   In addition to ‘#t’ any value except ‘#f’ counts as “true” when
evaluating the first expression of an ‘if’:

     (if 0 (+ 5 5) (+ 5 6)) ⇒ 11

   You can use ‘and’, ‘or’, and not ‘and’ to create complex boolean
expressions.  Of these ‘and’ and ‘or’ are special forms that only
evaluate as many of the sub-expressions as needed.
     (if (not (and (>= i 0) (<= i 9)))
         (display "error"))

   You can use ‘cond’ form as an alternative to ‘if’:
     (cond ((< 3 3) 'greater)
           ((> 3 3) 'less)
           (else ’equal))       ⇒ equal


File: kawa.info,  Node: Tutorial - Numbers,  Next: Tutorial - Functions,  Prev: Tutorial - Booleans,  Up: Tutorial

4.3 Numbers
===========

Exact integers and fractions
----------------------------

Kawa has the usual syntax for decimal integers.  Addition, subtraction,
and mutliplication are written using the usual ‘+’, ‘-’, and ‘*’, but
these are all prefix functions that take a variable number of arguments:

     (+ 1 2 3) ⇒ 6
     (- 10 3 4) ⇒ (- (- 10 3) 4)  ⇒ 3
     (* 2 -6)  ⇒ -12

   Kawa has arbitrary-precision integers.

   Let us implement the factorial
(http://en.wikipedia.org/wiki/Factorial) function.  Type in the
following (we’ll look at the syntax shortly):
     #|kawa:1|# (define (factorial x)
     #|(---:2|#   (if (< x 1) 1
     #|(---:3|#     (* x (factorial (- x 1)))))

   (The prompt changes to indicate a continuation line.)  This binds the
name ‘factorial’ to new function, with formal parameter ‘x’.  This new
function is immediately compiled to Java bytecodes, and later a JIT
compiler may compile it to native code.

   A few tests:
     #|kawa:4|# (list (factorial 3) (factorial 4))
     (6 24)
     #|kawa:5|# (factorial 30)
     265252859812191058636308480000000

Floating-point real numbers
---------------------------

Complex numbers
---------------

Units and dimensions
--------------------


File: kawa.info,  Node: Tutorial - Functions,  Next: Tutorial - Variables,  Prev: Tutorial - Numbers,  Up: Tutorial

4.4 Functions
=============

To declare a new function use ‘define’, which has the following form:
     (define (FUNCTION-NAME PARAMETER-NAMES) BODY)

   This creates a new function named FUNCTION-NAME, which takes
PARAMETER-NAMES as parameters.  When the function is called, the
PARAMETER-NAMES are initialized with the actual arguments.  Then BODY is
evaluated, and that becomes the result of the call.

   For example in the ‘factorial’ function we looked at recently, the
FUNCTION-NAME is ‘factorial’, and the PARAMETER-NAMES is ‘x’:

     (define (factorial x)
       (if (< x 1) 1
       (* x (factorial (- x 1)))))

Anonymous functions
-------------------

A "lambda expression" has the following form:
     (lambda (PARAMETER-NAMES) BODY)

Optional and rest parameters
----------------------------

You can declare a function that takes optional argument, or variable
number of arguments.  You can also use keyword parameters.  *note Read
more here.: Extended formals.


File: kawa.info,  Node: Tutorial - Variables,  Next: Tutorial - Sequences,  Prev: Tutorial - Functions,  Up: Tutorial

4.5 Variables
=============

You can declare a variable using a ‘define’ form.  This takes a variable
name, and an expression.  It declares a new variable with the given
name, and assigned the value of the expression to the variable.
     #|kawa:1|# (define binary-kilo 1024)
     #|kawa:2|# (define binary-mega (* binary-kilo binary-kilo))
     #|kawa:3|# binary-mega
     1048576
   A ‘define’ typed into the command-line defines a top-level variable.

   You can also declare local variables.  TODO.


File: kawa.info,  Node: Tutorial - Sequences,  Next: Tutorial - Types,  Prev: Tutorial - Variables,  Up: Tutorial

4.6 Lists and sequences
=======================

A "list" is a sequence of values, which is implemented as a chain of
linked "pairs".  You can create a constant list by quoting a
parenthesized list:
     '(3 4 (10 20 30) "a string")
   A "vector" is a sequence is whose elements are indexed by integers.
A vector uses less space than a list of the same length, and is
generally more efficient than a list.  Lists and vectors are examples of
"sequences", as are strings, and some other data types.  Sequences have
certain common operations ...


File: kawa.info,  Node: Tutorial - Types,  Next: Tutorial - Classes,  Prev: Tutorial - Sequences,  Up: Tutorial

4.7 Types and declarations
==========================

A "type" is a named value for a set of objects with related properties.
For example ‘vector’ is the type for standard Scheme vectors.  You can
use a type to specify that a variable can only have values of the
specified types:

     #|kawa:5|# (define v ::vector #(3 4 5))
     #|kawa:6|# v
     #(3 4 5)
     #|kawa:7|# (set! v 12)
     /dev/stdin:7:1: warning - cannot convert literal (of type gnu.math.IntNum) to vector
     Value (12) for variable 'v' has wrong type (gnu.math.IntNum) (gnu.math.IntNum cannot be cast to gnu.lists.FVector)
     	at atInteractiveLevel$7.run(stdin:7)
     	at gnu.expr.ModuleExp.evalModule(ModuleExp.java:302)
     	at kawa.Shell.run(Shell.java:275)
     	at kawa.Shell.run(Shell.java:186)
     	at kawa.Shell.run(Shell.java:167)
     	at kawa.repl.main(repl.java:870)
     Caused by: java.lang.ClassCastException: gnu.math.IntNum cannot be cast to gnu.lists.FVector
     	... 6 more

   Using a type specification catches errors, and matches your programs
more readable.  It also can allow the Kawa compiler to generate code
that runs faster.

   You can use a type to check that a value is an instance of the type,
using either the ‘instance?’ function:

     (instance? #(3 4 5) vector) ⇒ #t
     (instance? '(3 4 5) vector) ⇒ #f

   As a convenience, you can use a type-name followed by a “‘?’”:
     (TYPE? VAL) == (instance? VAL TYPE)

   You can “call” a type as if it were a function.  That constructs a
new instance of the type.
     ((EXAMPLE NEEDED))

   A fully-qualified Java class is a type name.  So are the names of
Java primitive types.  So are Java array types.  ((EXAMPLES NEEDED))

   A type is true run-time value:

     (define mytypes (list vector list string))
     (instance? #(3 4 5) (car mytypes) ⇒ #t

   The ‘define-alias’ form is useful for defining shorter names for
types, like a generalization of Java’s ‘import’ statement:

     (define-alias jframe javax.swing.JFrame)


File: kawa.info,  Node: Tutorial - Classes,  Prev: Tutorial - Types,  Up: Tutorial

4.8 Classes
===========


File: kawa.info,  Node: Running,  Next: Syntax,  Prev: Tutorial,  Up: Top

5 How to start up and run Kawa
******************************

The easiest way to start up Kawa is to run the ‘kawa’ program.  This
finds your java interpreter, and sets up ‘CLASSPATH’ correctly.  If you
have installed Kawa such ‘$PREFIX/bin’ is in your ‘$PATH’, just do:
     kawa
   However, ‘kawa’ only works if you have a Unix-like environment.  On
some platforms, ‘kawa’ is a program that uses the GNU ‘readline’ library
to provide input line editing.

   To run Kawa manually, you must start a Java Virtual Machine.  How you
do this depends on the Java implementation.  For Sun’s JDK s and some
other implementations, you must have the Java evaluator (usually named
‘java’) in your ‘PATH’.  You must also make sure that the
‘kawa/repl.class’ file, the rest of the Kawa packages, and the standard
Java packages can be found by searching CLASSPATH. *Note Running Java::.

   Then you do:
     java kawa.repl

   In either case, you will then get the ‘#|kawa:1|#’ prompt, which
means you are in the Kawa read-eval-print-loop.  If you type a Scheme
expression, Kawa will evaluate it.  Kawa will then print the result (if
there is a non-"void" result).

* Menu:

* Options::      Command-line arguments
* Scripts::      Running Command Scripts
* New-Window::   Running a Command Interpreter in a new Window
* Exiting::      Exiting Kawa
* Compiling::    Compiling to byte-code


File: kawa.info,  Node: Options,  Next: Scripts,  Prev: Running,  Up: Running

5.1 Command-line arguments
==========================

You can pass various flags to Kawa, for example:
     kawa -e '(display (+ 12 4))(newline)'
   or:
     java kawa.repl -e '(display (+ 12 4))(newline)'
   Either causes Kawa to print ‘16’, and then exit.

   At startup, Kawa executes an init file from the user’s home
directory.  The init file is named ‘.kawarc.scm’ on Unix-like systems
(those for which the file separator is ‘'/'’), and ‘kawarc.scm’ on other
systems.  This is done before the read-eval-print loop or before the
first ‘-f’ or ‘-c’ argument.  (It is not run for a ‘-e’ command, to
allow you to set options to override the defaults.)

   If there are no command-line arguments following the options, then
Kawa enters an interactive read-eval-print loop, but only if none of the
‘-c’, ‘-e’, ‘-f’, ‘-s’, ‘-C’, or ‘--’ options were specified.

   If there are command-line arguments after processing options, then
the first remaining argument names either a file that is read and
evaluated, or a compiled class.  In the former case, the whole file is
read and compiled as a module before being loaded (unlike the ‘-f’ flag
which reads and evaluates the file command by command.)  If the argument
is the fully-qualited name of a class, then the class is loaded, an
instance allocated, and its ‘run’ method invoked.  If the class was
compiled from a Kawa Scheme module, then invoking ‘run’ has the effect
of evaluating the module body.

5.1.1 General options
---------------------

‘-e EXPR’
     Kawa evaluates EXPR, which contains one or more Scheme expressions.
     Does not cause the ‘~/.kawarc.scm’ init file to be run.
‘-c EXPR’
     Same as ‘-e EXPR’, except that it does cause the ‘~/.kawarc.scm’
     init file to be run.
‘-f FILENAME-OR-URL’
     Kawa reads and evaluates expressions from the file named by
     FILENAME-OR-URL.  If the latter is ‘-’, standard input is read
     (with no prompting).  Otherwise, it is equivalent to evaluating
     ‘(load "FILENAME-OR-URL")’.  The FILENAME-OR-URL is interpreted as
     a URL if it is absolute - it starts with a "URI scheme" like
     ‘http:’.
‘-s’
‘--’
     The remaining arguments (if any) are passed to
     ‘command-line-arguments’ and (the ‘cdr’ of) ‘(command-line’), and
     an interactive read-eval-print loop is started.  This uses the same
     "console" as where you started up Kawa; use ‘-w’ to get a new
     window.
‘--script FILENAME-OR-URL’
‘--scriptN FILENAME-OR-URL’
     The global variable ‘command-line-arguments’ is set to the
     remaining arguments (if any).  Kawa reads and evaluates expressions
     from the file named by FILENAME-OR-URL.  If ‘script’ is followed by
     an integer N, then N lines are skipped first.

     Skipping some initial lines is useful if you want to have a
     non-Kawa preamble before the actual Kawa code.  One use for this is
     for Kawa shell scripts (*note Scripts::).

‘-w’
     Creates a new top-level window, and runs an interactive
     read-eval-print in the new window.  See *note New-Window::.  Same
     as ‘-e (scheme-window #t)’.  You can specify multiple ‘-w’ options,
     and also use ‘-s’.
‘--help’
     Prints out some help.
‘--version’
     Prints out the Kawa version number, and then exits.
‘--server PORTNUM’
     Start a server listening from connections on the specified PORTNUM.
     Each connection using the Telnet protocol causes a new
     read-eval-print-loop to started.  This option allows you to connect
     using any Telnet client program to a remote "Kawa server".

5.1.2 Options for language selection
------------------------------------

‘--scheme’
     Set the default language to Scheme.  (This is the default unless
     you select another language, or you name a file with a known
     extension on the command-line.)
‘--r5rs’
‘--r6rs’
‘--r7rs’
     Provide better compatibility with the specified Scheme standards.
     (This is a work-in-progress.)  For example ‘--r6rs’ aims to disable
     Kawa extensions that conflict with R6RS. It does not aim to disable
     all extensions, only incompatible extensions.  So far these
     extensions disable the colon operator and keyword literals, as well
     as the use of initial ‘@’ as a splicing operator.  Selecting
     ‘--r5rs’ makes symbols by default case-insensitive.
‘--elisp’
‘--emacs’
‘--emacs-lisp’
     Set the default language to Emacs Lisp.  (The implementation is
     quite incomplete.)
‘--lisp’
‘--clisp’
‘--clisp’
‘--commonlisp’
‘--common-lisp’
     Set the default language to CommonLisp.  (The implementation is
     _very_ incomplete.)
‘--krl’
     Set the default language to KRL. See *note KRL::.
‘--brl’
     Set the default language to KRL, in BRL-compatibility mode.  See
     *note KRL::.
‘--xquery’
     Set the default language to the draft XML Query language.  See the
     Kawa-XQuery page (http://www.gnu.org/software/qexo/) for more
     information.
‘--xslt’
     Set the default language to XSLT (XML Stylesheet Language
     Transformations).  (The implementation is _very_ incomplete.)  See
     the Kawa-XSLT page (http://www.gnu.org/software/qexo/xslt.html) for
     more information.
‘--pedantic’
     Try to follow the approprate language specification to the letter,
     even in corner cases, and even if it means giving up some Kawa
     convenience features.  This flags so far only affects the XQuery
     parser, but that will hopefully change.

5.1.3 Options for warnings and errors
-------------------------------------

‘--warn-undefined-variable’
     Emit a warning if the code references a variable which is neither
     in lexical scope nor in the compile-time dynamic (global)
     environment.  This is useful for catching typos.  (A
     ‘define-variable’ form can be used to silence warnings.  It
     declares to the compiler that a variable is to be resolved
     dynamically.)  This defaults to on; to turn it off use the
     ‘--no-warn-undefined-variable’ flag.
‘--warn-unknown-member’
     Emit a warning if the code references a named member (field or
     method) for which there is no match in the compile-time type of the
     receiver.  This defaults to on; to turn it off use the
     ‘--no-warn-unknown-member’ flag.
‘--warn-invoke-unknown-method’
     Emit a warning if the ‘invoke’ function calls a named method for
     which there is no matching method in the compile-time type of the
     receiver.  This defaults to the value of ‘--warn-unknown-member’,
     to turn it off use the ‘--no-warn-invoke-unknown-method’ flag.
‘--warn-unused’
     Emit a warning if a variable is unused or code never executed.
     This defaults to on; to turn it off use the ‘--no-warn-unused’
     flag.
‘--warn-unreachable’
     Emit a warning if the code can never be executed.  This defaults to
     on; to turn it off use the ‘--no-warn-unreachable’ flag.
‘--warn-void-used’
     Emit a warning if an expression depends on an expression that is
     void (always has zero values), including call to ‘void’ functions
     and method.  Also warn if an expression depends on a conditional
     (‘if’) that has no “else” clause.  Examples include using the value
     of ‘set-car!’ as an argument to a function, or to initialize a
     variable.  This defaults to on; to turn it off use the
     ‘--no-warn-void-used’ flag.
‘--warn-as-error’
     Treat a compilation warning as if it were an error and halt
     compilation.

   An option can be followed by a value, as in
‘--warn-invoke-unknown-method=no’.  For boolean options, the values
‘yes’, ‘true’, ‘on’, or ‘1’ enable the option, while ‘no’, ‘false’,
‘off’, or ‘0’ disable it.  You can also negate an option by prefixing it
with ‘no-’: The option ‘--no-warn-unknown-member’ is the same as
‘--warn-unknown-member=no’.

   These options can also be used in the module source, using
‘module-compile-options’ or ‘with-compile-options’.  (In that case they
override the options on the command line.)

5.1.4 Options for setting variables
-----------------------------------

‘NAME=VALUE’
     Set the global variable with the specified NAME to the given VALUE.
     The type of the VALUE is currently unspecified; the plan is for it
     to be like XQuery’s "untyped atomic" which can be coerced as
     needed.
‘{NAMESPACE-URI}LOCAL-NAME=VALUE’
     Set the global variable with the specified namespace uri and
     namespace-local name to the given value.

   These options are processed when invoking the ‘kawa’ application
(i.e.  the ‘kawa.repl’ application).  If you want a Kawa application
compiled with ‘--main’ to process these these assignments, call the
‘process-command-line-assignments’ utility function.

5.1.5 Options for controlling output formatting
-----------------------------------------------

‘--output-format FORMAT’
‘--format FORMAT’
     Change the default output format to that specified by FORMAT.  See
     *note Named output formats:: for more information and a list.

‘out:base=INTEGER’
     The number base (radix) to use by default when printing rational
     numbers.  Must be an integer between 2 and 36, and the default is
     of course 10.  For example the option ‘out:base=16’ produces
     hexadecimal output.  Equivalent to setting the ‘*print-base*’
     variable.
‘out:radix=no|yes’
     If true, prints an indicator of the radix used when printing
     rational numbers.  The default is ‘no’.  Equivalent to setting the
     ‘*print-radix*’ variable.
‘out:doctype-system=SYSTEM-IDENTIFIER’
     If ‘out:doctype-system’ is specified then a ‘DOCTYPE’ declaration
     is written before writing a top-level XML element, using the
     specified SYSTEM-IDENTIFIER.
‘out:doctype-public=PUBLIC-IDENTIFIER’
     Ignored unless ‘out:doctype-system’ is also specified, in which
     case the PUBLIC-IDENTIFIER is written as the public identifiers of
     the ‘DOCTYPE’ declaration.
‘out:xml-indent=KIND’
     Controls whether extra line breaks and indentation are added when
     printing XML. If KIND is ‘always’ or ‘yes’ then newlines and
     appropriate indentation are added before and after each element.
     If KIND is ‘pretty’ then the pretty-printer is used to only add new
     lines when an element otherwise won’t fit on a single line.  If
     KIND is ‘no’ (the default) then no extra line breaks or indentation
     are added.
‘out:line-length=COLUMNS’
‘out:right-margin=COLUMNS’
     Specifies the maximum number of number of columns in a line when
     the pretty-printer decides where to break a line.  (The two options
     are equivalent.)

5.1.6 Options for compiling and optimizing
------------------------------------------

‘--target VERSION’
     The VERSION can be a JDK or Java specification version: ‘5’, ‘6’,
     or ‘7’.  The JDK versions ‘1.5’ and ‘1.6’ are equivalent to ‘5’ or
     ‘6’, respectively.  Specify a JVM (classfile) version to target.
     This is useful if (for example) you use Java 6, but want to create
     ‘.class’ files that can run on Java 5.  In that case specify
     ‘--target 5’.

   The following options control which calling conventions are used:
‘--full-tailcalls’
     Use a calling convention that supports proper tail recursion.
‘--no-full-tailcalls’
     Use a calling convention that does not support proper tail
     recursion.  Self-tail-recursion (i.e.  a recursive call to the
     current function) is still implemented correctly, assuming that the
     called function is known at compile time.
‘--no-inline’
     Disable inlining of known functions and methods.  The generated
     code runs slower, but you can more reliably trace procedures.
     Normally Kawa will assume that a procedure ‘fn’ declared using a
     ‘(define (fn args) body)’ form is constant, assuming it isn’t
     modified in the current module.  However, it is possible some other
     module might modify the binding of ‘fn’.  You can use the
     ‘--no-inline’ to disable the assumption that ‘fn’ is constant.

   The default is currently ‘--no-full-tailcalls’ because it is usually
faster.  It is also closer to the Java call model, so may be better for
people primarily interested in using Kawa for scripting Java systems.

   Both calling conventions can co-exist: Code compiled with
‘--full-tailcalls’ can call code compiled with ‘--no-full-tailcalls’ and
vice versa.

   These options can also be used in the module source, using
‘module-compile-options’ or ‘with-compile-options’.  (In that case they
override the options on the command line.)

   The options ‘-C’, ‘-d’, ‘-T’, ‘-P’, ‘--main’ ‘--applet’, and
‘--servlet’ are used to compile a Scheme file; see *note Files
compilation::.  The options ‘--module-static’, ‘--module-nonstatic’,
‘--no-module-static’, and ‘--module-static-run’ control how a module is
mapped to a Java class; see *note static-or-non-modules::.  The option
‘--connect PORTNUM’ is only used by the ‘kawa’ front-end program.

5.1.7 Options for debugging
---------------------------

The following options are useful if you want to debug or understand how
Kawa works.
‘--debug-dump-zip’
     Normally, when Kawa loads a source file, or evaluates a non-trivial
     expression, it generates new internal Java classes but does not
     write them out.  This option asks it to write out generated classes
     in a ‘.zip’ archive whose name has the prefix ‘kawa-zip-dump-’.
‘--debug-print-expr’
     Kawa translates source language forms into an internal ‘Expression’
     data structure.  This option causes that data structure to be
     written out in a readable format to the standard output.
‘--debug-print-final-expr’
     Similar to the previous option, but prints out the ‘Expression’
     after various transformations and optimizations have been done, and
     just before code generation.
‘--debug-syntax-pattern-match’
     Prints logging importation to standard error when a ‘syntax-rules’
     or ‘syntax-case’ pattern matches.
‘--debug-error-prints-stack-trace’
     Prints a stack trace with any error found during compilation.
‘--debug-warning-prints-stack-trace’
     Prints a stack trace with any warning found during compilation.

5.1.8 Options for web servers
-----------------------------

JDK 6 (or later) includes a complete web server library.

‘--http-auto-handler CONTEXT-PATH APPDIR’
     Register a web application handler that uses files in the directory
     APPDIR to handle HTTP (web) requests containing the given
     CONTEXT-PATH.  That is it handles requests that start with
     ‘http://localhost:PORTCONTEXT-PATH’.  (This assumes the
     CONTEXT-PATH starts with a ‘/’.)  *Note Self-configuring page
     scripts::.
‘--http-start PORT’
     Start the web server, listing on the specified PORT.

5.1.9 Options for the JVM
-------------------------

The ‘kawa’ front-end can pass options to the ‘java’ launcher, using ‘-J’
or ‘-D’ options.  These must be given _before_ any other arguments.  For
example:
     kawa -J-Xms48m -Dkawa.command.name=foo foo.scm --
   is equivalent to (ignoring classpath issues):
     java -Xms48m -Dkawa.command.name=foo kawa.repl foo.scm --

‘-JJVM-OPTION’
     Passes the JVM-OPTION to the ‘java’ command, before the class-name
     (‘kawa.repl’) and Kawa options.
‘-DVARIABLE-NAME=VARIABLE-VALUE’
     Sets the JVM property VARIABLE-NAME to VARIABLE-VALUE.  Equivalent
     to ‘-J-DVARIABLE-NAME=VARIABLE-VALUE’.


File: kawa.info,  Node: Scripts,  Next: New-Window,  Prev: Options,  Up: Running

5.2 Running Command Scripts
===========================

If you write a Kawa application it is convenient to be able to execute
it directly (from the command line or clicking an icon, say), without
have to explicitly run ‘kawa’ or ‘java’.  On Unix-like systems the
easiest way to do this is to write a small shell script that runs your
Kawa application.

   For modest-sized applications it is convenient if the shell script
and the Kawa code can be in the same file.  Unix-like systems support a
mechanism where a "script" can specify a program that should execute it.
The convention is that the first line of the file should start with the
two characters ‘#!’ followed by the absolute path of the program that
should process (interpret) the script.

   (Windows has "batch files", which are similar.)

   This is convention works well for script languages that use ‘#’ to
indicate the start of a comment, since the interpreter will
automatically ignore the line specifying the interpreter filename.
Scheme, however uses ‘#’ as a multi-purpose prefix, and Kawa
specifically uses ‘#!’ as a prefix for various *note Special named
constants:: such as ‘#!optional’.

   Kawa does recognize the three-character sequence ‘#!/’ at the
beginning of a file as special, and ignores it.  Here is an example:
     #!/usr/local/bin/kawa
     (format #t "The command-line was:~{ ~w~}~%" (command-line))

   If you copy this text to a file named ‘/home/me/bin/scm-echo’, set
the execute permission, and make sure it in your ‘PATH’, then you can
execute it just by naming it on command line:
     $ chmod +x /home/me/bin/scm-echo
     $ PATH=/home/me/bin:$PATH
     $ scm-env a b
     The command-line was: "/home/me/bin/scm-echo" "a" "b"
   The system kernel will automatically execute ‘kawa’, passing it the
filename as an argument.

   Note that the full path-name of the ‘kawa’ interpreter must be
hard-wired into the script.  This means you may have to edit the script
depending on where Kawa is installed on your system.  Another possible
problem is that the interpreter must be an actual program, not a shell
script.  Depending on how you configure and install Kawa, ‘kawa’ can be
a real program or a script.  You can avoid both problems by the ‘env’
program, available on most modern Unix-like systems:

     #!/usr/bin/env kawa
     (format #t "The command-line was:~{ ~w~}~%" (command-line))

   This works the same way, but assumes ‘kawa’ is in the command ‘PATH’.

5.2.1 Setting kawa options in the script
----------------------------------------

If you need to specify extra arguments to ‘kawa’, you can run arbitrary
shell command inside Scheme block comments.  Here is an example:
     #!/bin/sh
     #|
     exec kawa out:base=16 out:radix=yes "$0" "$*"
     |#
     (format #t "The command-line is:~{ ~w~}.~%" (command-line))
     (display "It has ")
     (display (apply + (map string-length (command-line))))
     (display " characters.")
     (newline)

   The trick is to hide the shell code from Kawa inside a ‘#|...|#’
block-comment.  The start of the block comment is a line starting with a
‘#’, so it is treated as a comment by the shell.  You can then invoke
‘kawa’ (or ‘java’ directly) as you prefer, setting up class-path and
jars as needed, and passing whatever arguments you want.  (The shell
replaces the ‘"$0"’ by the name the script, and replaces the ‘"$@"’ by
the remaining arguments passed to the script.)  You need to make sure
the shell finishes before it reaches the end of the block comment or the
Scheme code, which would confuse it.  The example uses ‘exec’, which
tells the shell to _replace_ itself by KAWA; an alternative is to use
the shell ‘exit’ command.

   If you copy the above file to ‘/tmp/sch-echo’ and make that file
executate, you can run it directly:
     $ /tmp/scm-echo "a b" "c d"
     The command-line is: "/tmp/scm-echo" "a b c d".
     It has #x14 characters.

   When the Kawa reader sees the initial ‘#/’ it sets the command name
to the file name, so it can be used by a future call to
‘(command-name)’.  If you want to override this you can use the
‘-Dkawa.command.name=NAME’ option.

   Using comments this way has the advantage that you have the option of
running the script “manually” if you prefer:
     $ kawa /tmp/scm-echo out:base=8 "x y"
     The command-line is: "/tmp/scm-echo" "out:base=8" "x y".
     It has 26 characters.

5.2.2 Other ways to pass options using meta-arg or –script
----------------------------------------------------------

An argument consisting of just a ‘\’ (backslash) causes Kawa to read the
_second_ line looking for options.  (Quotes and backslahes work like in
the shell.)  These replace the backslash in the command line.

   This is a less verbose mechanism, but it requires an absolute path to
‘kawa’, due to shell limitations.

     #!/usr/bin/kawa \
       --scheme --full-tailcalls
     (format #t "The command-line is:~{ ~w~}.~%" (command-line))

   In this case the efective command line received by Kawa will be
‘--scheme’, ‘--full-tailcalls’, followed by the script filename,
followed by other arguments specified when running the script.

   The backslash used this way originated in scsh (http://www.scsh.net)
where it is called the "meta-arg".  (Unlike scsh, Kawa’s ‘#!’ is not a
block comment, but a rest-of-line, though the backslash causes the
following line to also be skipped.)

   An alternative method is to use the ‘--script2’ option, which tells
Kawa to execute the script after ignoring the initial two lines.  For
example:

     #!/bin/sh
     exec kawa --commonlisp out:base=16 --script2 "$0" "$@"
     (setq xx 20) (display xx) (newline)

   This slightly more compact than using block-comments as shown
earlier, but it has the disadvantage that you can’t explicitly use
‘kawa’ or ‘java’ to run the script unless you make sure to pass it the
‘--script2’ option.

5.2.3 Scripts for compiled code
-------------------------------

If you compile your Kawa application to class files (or better: a ‘jar’
file), you probably still want to write a small shell script to set
things up.  Here is one method:

     #!/bin/sh
     export CLASSPATH=/my/path
     exec kawa -Dkawa.command.name="$0" foo "$@"

   Using the ‘kawa’ front-end is a convenience, since it automatically
sets up the paths for the Kawa classes, and (if enabled) if provides
readline support for the default input port.

   Setting the ‘kawa.command.name’ property to ‘"$0"’ (the filename used
to invoke the script) enables ‘(command-line’) to use the script name as
the command name.

   You can invoke ‘java’ directly, which is necessary when running a
‘jar’ file:

     #!/bin/sh
     exec java -cp /path/to/kawa -Dkawa.command.name="$0" foo.jar "$@"


File: kawa.info,  Node: New-Window,  Next: Exiting,  Prev: Scripts,  Up: Running

5.3 Running a Command Interpreter in a new Window
=================================================

An alternative interface runs the Java read-eval-print-loop inside a new
window.  This is in some ways nicer.  One reason is that it provides
better editing.  (Mouse selection, arrow keys, and “standard” control
keys should all work.)

   You can also create new windows.  They can either have different
top-level environments or they can share environments.  To try it, do:
     java kawa.repl -w


File: kawa.info,  Node: Exiting,  Prev: New-Window,  Up: Running

5.4 Exiting Kawa
================

Kawa normally keeps running as long as there is an active
read-eval-print loop still awaiting input or there is an unfinished
other computation (such as requested by a ‘-e’ of ‘-f’ option).

   To close a read-eval-print-loop, you can type the special literal
‘#!eof’ at top level.  This is recognized as end-of-file.
Unfortunately, due to thread-related complications, just typing an
end-of-file character (normally ctrl/D until Unix), will not work.

   If the read-eval-print-loop is in a new window, you can select
‘Close’ from the ‘File’ menu.

   To exit the entire Kawa session, call the ‘exit’ procedure (with 0 or
1 integer arguments).


File: kawa.info,  Node: Compiling,  Up: Running

5.5 Compiling to byte-code
==========================

All Scheme functions and source files are invisibly compiled into
internal Java byte-codes.  (A traditional interpreter is used for
macro-expansion.  Kawa used to also interpret “simple” expressions in
interactive mode, but always compiling makes things more consistent, and
allows for better stack traces on errors.)

   To save speed when loading large Scheme source files, you probably
want to pre-compile them and save them on your local disk.  There are
two ways to do this.

   You can compile a Scheme source file to a single archive file.  You
do this using the ‘compile-file’ function.  The result is a single file
that you can move around and ‘load’ just like the ‘.scm’ source file.
You just specify the name of the archive file to the ‘load’ procedure.
Currently, the archive is a "zip" archive and has extension ".zip"; a
future release will probably use "Java Archive" (jar) files.  The
advantage of compiling to an archive is that it is simple and
transparent.  A minor disadvantage is that it causes the Java "verifier"
to be run when functions are loaded from it, which takes a little extra
time.

   Alternatively, you can compile a Scheme source file to a collection
of ‘.class’ files.  You then use the standard Java class loading
mechanism to load the code.  The Java "verifier" does not need to get
run, which makes loading a little faster.  The compiled class files do
have to be installed somewhere in the ‘CLASSPATH’.

* Menu:

* Files compilation::           Compiling to a set of .class files
* Archive compilation::         Compiling to an archive file
* Compiling using Ant::
* Application compilation::     Compiling to a standalone application
* Applet compilation::          Compiling to an applet
* Compiling to executable::     Compiling to a native executable


File: kawa.info,  Node: Files compilation,  Next: Archive compilation,  Up: Compiling

5.5.1 Compiling to a set of .class files
----------------------------------------

Invoking ‘kawa’ (or ‘java kawa.repl’) with the ‘-C’ flag will compile a
‘.scm’ source file into one or more ‘.class’ files:
     kawa --main -C myprog.scm

   You run it as follows:
     kawa [-d OUTDIRECTORY] [-P PREFIX] [-T TOPNAME] [--main | --applet | --servlet] -C INFILE ...

   Note the ‘-C’ must come last, because ‘Kawa’ processes the arguments
and options in order,

   Here:
‘-C INFILE ...’
     The Scheme source files we want to compile.
‘-d OUTDIRECTORY’
     The directory under which the resulting ‘.class’ files will be.
     The default is the current directory.
‘-P PREFIX’
     A string to prepend to the generated class names.  The default is
     the empty string.
‘-T TOPNAME’
     The name of the "top" class - i.e.  the one that contains the code
     for the top-level expressions and definitions.  The default is
     generated from the INFILE and PREFIX.
‘--main’
     Generate a ‘main’ method so that the resulting "top" class can be
     used as a stand-alone application.  *Note Application
     compilation::.
‘--applet’
     The resulting class inherits from ‘java.applet.Applet’, and can be
     used as an applet.  *Note Applet compilation::.
‘--servlet’
     The resulting class implements ‘javax.servlet.http.HttpServlet’,
     and can be used as an servlet in a servlet container like Tomcat.

   When you actually want to load the classes, the OUTDIRECTORY must be
in your ‘CLASSPATH’.  You can use the ‘require’ syntax or the ‘load’
function to load the code, by specifying the top-level class, either as
a file name (relative to OUTDIRECTORY) or a class name.  E.g.  if you
did:
     kawa -d /usr/local/share/java -P my.lib. -T foo -C foosrc.scm
   you can use either:
     (require my.lib.foo)
   or:
     (load "my.lib.foo")
   Using ‘require’ is preferred as it imports the definitions from
‘my.lib.foo’ into the compile-time environment, while ‘load’ only
imports the definitions into run-time environment.

   If you are compiling a Scheme source file (say ‘foosrc.scm’) that
uses macros defined in some other file (say ‘macs.scm’), you need to
make sure the definitions are visible to the compiler.  One way to do
that is with the ‘-f’:
     kawa -f macs.scm -C foosrc.scm

   Many of the options *note described earlier: Options. are relevant
when compiling.  Commonly used options include language selection, the
‘--warn-xxx’ options, and ‘--full-tailcalls’.


File: kawa.info,  Node: Archive compilation,  Next: Compiling using Ant,  Prev: Files compilation,  Up: Compiling

5.5.2 Compiling to an archive file
----------------------------------

 -- Procedure: compile-file source-file compiled-archive
     Compile the SOURCE-FILE, producing a ‘.zip’ archive COMPILED-FILE.

     For example, to byte-compile a file ‘foo.scm’ do:
          (compile-file "foo.scm" "foo")

     This will create ‘foo.zip’, which contains byte-compiled JVM
     ‘.class’ files.  You can move this file around, without worrying
     about class paths.  To load the compiled file, you can later ‘load’
     the named file, as in either ‘(load "foo")’ or ‘(load "foo.zip")’.
     This should have the same effect as loading ‘foo.scm’, except you
     will get the faster byte-compiled versions.


File: kawa.info,  Node: Compiling using Ant,  Next: Application compilation,  Prev: Archive compilation,  Up: Compiling

5.5.3 Compiling using Ant
-------------------------

Many Java projects use Ant (http://ant.apache.org) for building Java
projects.  Kawa includes a ‘<kawac>’ Ant ask that simplifies compiling
Kawa sources files to classes.  See the ‘build.xml’ in the Kawa source
distribution for examples.  See the ‘kawac’ task documentation
(ant-kawac.html) for details.


File: kawa.info,  Node: Application compilation,  Next: Applet compilation,  Prev: Compiling using Ant,  Up: Compiling

5.5.4 Compiling to a standalone application
-------------------------------------------

A Java application is a Java class with a special method (whose name is
‘main’).  The application can be invoked directly by naming it in the
Java command.  If you want to generate an application from a Scheme
program, create a Scheme source file with the definitions you need, plus
the top-level actions that you want the application to execute.

   For example, assuming your Scheme file is ‘MyProgram.scm’, you have
two ways at your disposal to compile this Scheme program to a standalone
application:
  1. Compile in the regular way decribed in the previous section, but
     add the ‘--main’ option.
          kawa --main -C MyProgram.scm

     The ‘--main’ option will compile all Scheme programs received in
     arguments to standalone applications.
  2. Compile in the regular way decribed in the previous section, but
     add the ‘main: #t’ module compile option to your module.
          ;; MyProgram.scm
          (module-name <myprogram>)
          (module-compile-options main: #t)

          kawa -C MyProgram.scm

     This way you can compile multiple Scheme programs at once, and
     still control which one(s) will compile to standalone
     application(s).

   Both method will create a ‘MyProgram.class’ which you can either
‘load’ (as decribed in the previous section), or invoke as an
application:
     java MyProgram [ARGS]
   Your Scheme program can access the command-line arguments ARGS by
using the global variable ‘command-line-arguments’, or the R6RS function
‘command-line’.

   If there is no explicit ‘module-export’ in a module compiled with
‘--main’ then no names are exported.  (The default otherwise is for all
names to be exported.)


File: kawa.info,  Node: Applet compilation,  Next: Compiling to executable,  Prev: Application compilation,  Up: Compiling

5.5.5 Compiling to an applet
----------------------------

An applet is a Java class that inherits from ‘java.applet.Applet’.  The
applet can be downloaded and run in a Java-capable web-browser.  To
generate an applet from a Scheme program, write the Scheme program with
appropriate definitions of the functions ‘init’, ‘start’, ‘stop’ and
‘destroy’.  You must declare these as zero-argument functions with a
‘<void>’ return-type.

   Here is an example, based on the scribble applet in Flanagan’s "Java
Examples in a Nutshell" (O’Reilly, 1997):
     (define-private last-x 0)
     (define-private last-y 0)

     (define (init) :: void
       (let ((applet (this)))
         (applet:addMouseListener
          (object (java.awt.event.MouseAdapter)
     	     ((mousePressed e)
     	      (set! last-x (e:getX))
     	      (set! last-y (e:getY)))))
         (applet:addMouseMotionListener
          (object (java.awt.event.MouseMotionAdapter)
     	     ((mouseDragged e)
     	      (let ((g (applet:getGraphics))
     		    (x (e:getX))
     		    (y (e:getY)))
     		(g:drawLine last-x last-y x y)
     		(set! last-x x)
     		(set! last-y y)))))))

     (define (start) :: void (format #t "called start.~%~!"))
     (define (stop) :: void (format #t "called stop.~%~!"))
     (define (destroy) :: void (format #t "called destroy.~%~!"))

   You compile the program with the ‘--applet’ flag in addition to the
normal ‘-C’ flag:
     java kawa.repl --applet -C scribble.scm

   You can then create a ‘.jar’ archive containing your applet:
     jar cf scribble.jar scribble*.class

   Finally, you create an ‘.html’ page referencing your applet and its
support ‘jar’s:
     <html><head><title>Scribble testapp</title></head>
     <body><h1>Scribble testapp</h1>
     You can scribble here:
     <br>
     <applet code="scribble.class" archive="scribble.jar, kawa-2.0.jar" width=200 height=200>
     Sorry, Java is needed.</applet>
     </body></html>

   The problem with using Kawa to write applets is that the Kawa ‘.jar’
file is quite big, and may take a while to download over a network
connection.  Some possible solutions:

   • Try to strip out of the Kawa ‘.jar’ any classes your applet doesn’t
     need.
   • Java 2 provides a mechanism to install a download extension
     (http://java.sun.com/docs/books/tutorial/ext/basics/download.html).
   • Consider some alternative to applets, such as Java Web Start
     (http://java.sun.com/products/javawebstart/).


File: kawa.info,  Node: Compiling to executable,  Prev: Applet compilation,  Up: Compiling

5.5.6 Compiling to a native executable
--------------------------------------

In the past it was possible to compile a Scheme program to native code
using GCJ. However, using GCJ with Kawa is no longer supported, as GCJ
is no longer being actively maintained.


File: kawa.info,  Node: Syntax,  Next: Program structure,  Prev: Running,  Up: Top

6 Syntax
********

* Menu:

* Syntax notation::
* Lexical and datum syntax::
* Lexical syntax::
* Datum syntax::
* Hash-prefixed forms::
* Primitive expression syntax::
* Colon notation:: Property access using colon notation
* Bodies::
* Syntax and conditional compilation::
* Macros::
* Named quasi-literals::


File: kawa.info,  Node: Syntax notation,  Next: Lexical and datum syntax,  Up: Syntax

6.1 Notation
============

The formal syntax for Kawa Scheme is written in an extended BNF.
Non–terminals are written LIKE-THIS.  Case is insignificant for
non–terminal names.  Literal text (terminals) are written ‘like this’.

   All spaces in the grammar are for legibility.

   The following extensions to BNF are used to make the description more
concise: THING^* or THING‘...’ both mean zero or more occurrences of
THING, and THING^+ means at least one THING.

   Some non-terminal names refer to the Unicode scalar values of the
same name: CHARACTER-TABULATION (U+0009), LINEFEED (U+000A),
CARRIAGE-RETURN (U+000D), LINE-TABULATION (U+000B), FORM-FEED (U+000C),
SPACE (U+0020), NEXT-LINE (U+0085), LINE-SEPARATOR (U+2028), and
PARAGRAPH-SEPARATOR (U+2029).


File: kawa.info,  Node: Lexical and datum syntax,  Next: Lexical syntax,  Prev: Syntax notation,  Up: Syntax

6.2 Lexical and datum syntax
============================

The syntax of Scheme code is organized in three levels:

  1. the _lexical syntax_ that describes how a program text is split
     into a sequence of lexemes,

  2. the _datum syntax_, formulated in terms of the lexical syntax, that
     structures the lexeme sequence as a sequence of _syntactic data_,
     where a syntactic datum is a recursively structured entity,

  3. the _program syntax_ formulated in terms of the datum syntax,
     imposing further structure and assigning meaning to syntactic data.

   Syntactic data (also called _external representations_) double as a
notation for objects, and the ‘read’ and ‘write’ procedures can be used
for reading and writing syntactic data, converting between their textual
representation and the corresponding objects.  Each syntactic datum
represents a corresponding _datum value_.  A syntactic datum can be used
in a program to obtain the corresponding datum value using ‘quote’.

   Scheme source code consists of syntactic data and (non–significant)
comments.  Syntactic data in Scheme source code are called _forms_.  (A
form nested inside another form is called a _subform_.)  Consequently,
Scheme’s syntax has the property that any sequence of characters that is
a form is also a syntactic datum representing some object.  This can
lead to confusion, since it may not be obvious out of context whether a
given sequence of characters is intended to be a representation of
objects or the text of a program.  It is also a source of power, since
it facilitates writing programs such as interpreters or compilers that
treat programs as objects (or vice versa).

   A datum value may have several different external representations.
For example, both ‘#e28.000’ and ‘#x1c’ are syntactic data representing
the exact integer object 28, and the syntactic data ‘(8 13)’, ‘( 08 13
)’, ‘(8 . (13 . ()))’ all represent a list containing the exact integer
objects 8 and 13.  Syntactic data that represent equal objects (in the
sense of ‘equal?’) are always equivalent as forms of a program.

   Because of the close correspondence between syntactic data and datum
values, we sometimes uses the term _datum_ for either a syntactic datum
or a datum value when the exact meaning is apparent from the context.


File: kawa.info,  Node: Lexical syntax,  Next: Datum syntax,  Prev: Lexical and datum syntax,  Up: Syntax

6.3 Lexical syntax
==================

The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non–significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the Unicode standard (http://unicode.org/).  Some of the lexemes,
such as identifiers, representations of number objects, strings etc., of
the lexical syntax are syntactic data in the datum syntax, and thus
represent objects.  Besides the formal account of the syntax, this
section also describes what datum values are represented by these
syntactic data.

   The lexical syntax, in the description of comments, contains a
forward reference to DATUM, which is described as part of the datum
syntax.  Being comments, however, these DATUMs do not play a significant
role in the syntax.

   Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, ‘#x1A’ and ‘#X1a’ are equivalent.  The identifier ‘Foo’ is,
however, distinct from the identifier ‘FOO’.

6.3.1 Formal account
--------------------

INTERLEXEME-SPACE may occur on either side of any lexeme, but not within
a lexeme.

   IDENTIFIERs, ‘.’, NUMBERs, CHARACTERs, and BOOLEANs, must be
terminated by a DELIMITER or by the end of the input.

     LEXEME ::= IDENTIFIER | BOOLEAN | NUMBER
              | CHARACTER | STRING
              | ‘(’ |  ‘)’ |  ‘[’ |  ‘]’ |  ‘#(’
              | ‘’’ | ‘‘’ | ‘,’ | ‘,@’ | ‘.’
              | ‘#’’ |  ‘#‘’ |  ‘#,’ |  ‘#,@’
     DELIMITER ::= ‘(’ |  ‘)’ |  ‘[’ | ‘]’ | ‘"’ | ‘;’ | ‘#’
              | WHITESPACE

   ((UNFINISHED))

6.3.2 Line endings
------------------

Line endings are significant in Scheme in single–line comments and
within string literals.  In Scheme source code, any of the line endings
in LINE-ENDING marks the end of a line.  Moreover, the two–character
line endings CARRIAGE-RETURN LINEFEED and CARRIAGE-RETURN NEXT-LINE each
count as a single line ending.

   In a string literal, a LINE-ENDING not preceded by a ‘\’ stands for a
linefeed character, which is the standard line–ending character of
Scheme.

6.3.3 Whitespace and comments
-----------------------------

     INTRALINE-WHITESPACE ::= SPACE | CHARACTER-TABULATION
     WHITESPACE ::=  INTRALINE-WHITESPACE
              | LINEFEED | LINE-TABULATION | FORM-FEED
              | CARRIAGE-RETURN | NEXT-LINE
              | any character whose category is Zs, Zl, or Zp
     LINE-ENDING ::= LINEFEED | CARRIAGE RETURN
              | CARRIAGE-RETURN LINEFEED | NEXT-LINE
              | CARRIAGE-RETURN NEXT-LINE | LINE-SEPARATOR
     COMMENT ::=  ‘;’ all subsequent characters up to a LINE-ENDING
                     or PARAGRAPH-SEPARATOR
              | NESTED-COMMENT
              | ‘#;’ INTERLEXEME-SPACE DATUM
              | SHEBANG-COMMENT
     NESTED-COMMENT ::=  ‘#|’ COMMENT-TEXT COMMENT-CONT* ‘|#’
     COMMENT-TEXT ::= character sequence not containing ‘#|’ or ‘|#’
     COMMENT-CONT ::= NESTED-COMMENT COMMENT-TEXT
     ATMOSPHERE ::= WHITESPACE | COMMENT
     INTERLEXEME-SPACE ::= ATMOSPHERE*

   As a special case the characters ‘#!/’ are treated as starting a
comment, but only at the beginning of file.  These characters are used
on Unix systems as an Shebang interpreter directive
(http://en.wikipedia.org/wiki/Shebang_(Unix)).  The Kawa reader skips
the entire line.  If the last non-whitespace character is ‘\’
(backslash) then the following line is also skipped, and so on.
     SHEBANG-COMMENT ::= ‘#!’ ABSOLUTE-FILENAME text up to non-escaped LINE-ENDING

_Whitespace_ characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

   The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

   A semicolon (‘;’) indicates the start of a line comment.  The comment
continues to the end of the line on which the semicolon appears.

   Another way to indicate a comment is to prefix a DATUM with ‘#;’,
possibly with INTERLEXEME-SPACE before the DATUM.  The comment consists
of the comment prefix ‘#;’ and the DATUM together.  This notation is
useful for “commenting out” sections of code.

   Block comments may be indicated with properly nested ‘#|’ and ‘|#’
pairs.
     #|
        The FACT procedure computes the factorial of a
        non-negative integer.
     |#
     (define fact
       (lambda (n)
         ;; base case
         (if (= n 0)
             #;(= n 1)
             1       ; identity of *
             (* n (fact (- n 1))))))

6.3.4 Identifiers
-----------------

     IDENTIFIER ::= INITIAL SUBSEQUENT*
              | PECULIAR-IDENTIFIER
     INITIAL ::= CONSTITUENT | SPECIAL-INITIAL
              | INLINE-HEX-ESCAPE
     LETTER ::= ‘a’ | ‘b’ | ‘c’ | ... | ‘z’
              | ‘A’ | ‘B’ | ‘C’ | ... | ‘Z’
     CONSTITUENT ::= LETTER
              | any character whose Unicode scalar value is greater than
                  127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
                  Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co
     SPECIAL-INITIAL ::= ‘!’ | ‘$’ | ‘%’ | ‘&’ | ‘*’ | ‘/’ | ‘<’ | ‘=’
              | ‘>’ | ‘?’ | ‘^’ | ‘_’ | ‘~’
     SUBSEQUENT ::= INITIAL | DIGIT
              | any character whose category is Nd, Mc, or Me
              | SPECIAL-SUBSEQUENT
     DIGIT ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’ | ‘8’ | ‘9’
     OCT-DIGIT ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’
     HEX-DIGIT ::= DIGIT
              | ‘a’ | ‘A’ | ‘b’ | ‘B’ | ‘c’ | ‘C’ | ‘d’ | ‘D’ | ‘e’ | ‘E’ | ‘f’ | ‘F’
     SPECIAL-SUBSEQUENT ::= ‘+’ | ‘-’ | ‘.’ | ‘@’
     ESCAPE-SEQUENCE ::= INLINE-HEX-ESCAPE
              | ‘\’CHARACTER-EXCEPT-X
              | MULTI-ESCAPE-SEQUENCE
     INLINE-HEX-ESCAPE ::= ‘\x’HEX-SCALAR-VALUE‘;’
     HEX-SCALAR-VALUE ::= HEX-DIGIT+
     MULTI-ESCAPE-SEQUENCE ::= ‘|’SYMBOL-ELEMENT^*‘|’
     SYMBOL-ELEMENT ::=  any character except ‘|’ or ‘\’
              | INLINE-HEX-ESCAPE | MNEMONIC-ESCAPE | ‘\|’

     CHARACTER-EXCEPT-X ::= any character except ‘x’
     PECULIAR-IDENTIFIER ::= ‘+’ | ‘-’ | ‘...’ | ‘->’ SUBSEQUENT^*

   Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
“extended alphabetic characters” is an identifier when it begins with a
character that cannot begin a representation of a number object.  In
addition, ‘+’, ‘-’, and ‘...’ are identifiers, as is a sequence of
letters, digits, and extended alphabetic characters that begins with the
two–character sequence ‘->’.  Here are some examples of identifiers:

     lambda         q                soup
     list->vector   +                V17a
     <=             a34kTMNs         ->-
     the-word-recursion-has-many-meanings

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

     ! $ % & * + - . / < = > ? @ ^ _ ~

   Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified using an ESCAPE-SEQUENCE.  For example, the
identifier ‘H\x65;llo’ is the same as the identifier ‘Hello’.

   Kawa supports two additional non-R6RS ways of making identifiers
using special characters, both taken from Common Lisp: Any character
(except ‘x’) following a backslash is treated as if it were a LETTER; as
is any character between a pair of vertical bars.

   Identifiers have two uses within Scheme programs:
   • Any identifier may be used as a *note variable: variable-reference.
     or as a *note syntactic keyword: macro-reference.
   • When an identifier appears as or with in *note literal:
     literal-expression, it is being used to denote a *note symbol:
     Simple symbols.

   In contrast with older versions of Scheme, the syntax distinguishes
between upper and lower case in identifiers and in characters specified
via their names, but not in numbers, nor in inline hex escapes used in
the syntax of identifiers, characters, or strings.  The following
directives give explicit control over case folding.

 -- Syntax: #!fold-case
 -- Syntax: #!no-fold-case

     These directives may appear anywhere comments are permitted and are
     treated as comments, except that they affect the reading of
     subsequent data.  The ‘#!fold-case’ directive causes the ‘read’
     procedure to case-fold (as if by ‘string-foldcase’) each identifier
     and character name subsequently read from the same port.  The
     ‘#!no-fold-case’ directive causes the ‘read’ procedure to return to
     the default, non-folding behavior.

   Note that colon ‘:’ is treated specially for *note colon notation:
Colon notation. in Kawa Scheme, though it is a SPECIAL-INITIAL in
standard Scheme (R6RS).

6.3.5 Numbers
-------------

((INCOMPLETE))

     NUMBER ::= ((TODO))
       | QUANTITY
     DECIMAL ::= DIGIT+ OPTIONAL-EXPONENT
       | ‘.’ DIGIT+ OPTIONAL-EXPONENT
       | DIGIT+ ‘.’ DIGIT+ OPTIONAL-EXPONENT

     OPTIONAL-EXPONENT ::= empty
       | EXPONENT-MARKER OPTIONAL-SIGN DIGIT+
     EXPONENT-MARKER ::= ‘e’ | ‘s’ | ‘f’ | ‘d’ | ‘l’
   The letter used for the exponent in a floating-point literal
determines its type:
‘e’
     Returns a ‘gnu.math.DFloat’ - for example ‘12e2’.  Note this
     matches the default when there is no EXPONENT-MARKER.
‘s’ or ‘f’
     Returns a primitive ‘float’ (or ‘java.lang.Float’ when boxed as an
     object) - for example ‘12s2’ or ‘12f2’.
‘d’
     Returns a primitive ‘double’ (or ‘java.lang.Double’ when boxed) -
     for example ‘12d2’.
‘l’
     Returns a ‘java.math.BigDecimal’ - for example ‘12l2’.
     OPTIONAL-SIGN ::= empty | ‘+’ | ‘-’
     DIGIT-2 ::= ‘0’ | ‘1’
     DIGIT-8 ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’
     DIGIT-10 ::= DIGIT
     DIGIT-16 ::= DIGIT-10 | ‘a’ | ‘b’ | ‘c’ | ‘d’ | ‘e’ | ‘f’


File: kawa.info,  Node: Datum syntax,  Next: Hash-prefixed forms,  Prev: Lexical syntax,  Up: Syntax

6.4 Datum syntax
================

The datum syntax describes the syntax of syntactic data in terms of a
sequence of LEXEMEs, as defined in the lexical syntax.

   The following grammar describes the syntax of syntactic data in terms
of various kinds of lexemes defined in the grammar in section “Lexical
Syntax”:

     DATUM ::= DEFINING-DATUM
              | NONDEFINING-DATUM
              | DEFINED-DATUM
     NONDEFINING-DATUM ::= LEXEME-DATUM
              | COMPOUND-DATUM

     LEXEME-DATUM ::= BOOLEAN | NUMBER
              | CHARACTER | STRING | SYMBOL
     SYMBOL ::= IDENTIFIER
     COMPOUND-DATUM ::= LIST | VECTOR | UNIFORM-VECTOR | EXTENDED-STRING-LITERAL | XML-LITERAL
     LIST ::= ‘(’DATUM*‘)’
              | ‘(’DATUM+ ‘.’ DATUM‘)’
              | ABBREVIATION
     VECTOR ::= ‘#(’DATUM*‘)’
     UNIFORM-VECTOR ::= TODO

6.4.1 Datum labels
------------------

     DATUM-LABEL ::= ‘#’INDEXNUM‘=’
     DEFINING-DATUM ::= DATUM-LABEL^+NONDEFINING-DATUM
     DEFINED-DATUM ::= ‘#’INDEXNUM‘#’
     INDEXNUM ::= DIGIT^+

   The lexical syntax ‘#N=DATUM’ reads the same as DATUM, but also
results in DATUM being labelled by N, which must a sequence of digits.

   The lexical syntax ‘#N#’ serves as a reference to some object
labelled by ‘#N=’; the result is the same object (in the sense of ‘eq?’)
as the ‘#N=’.

   Together, these syntaxes permit the notation of structures with
shared or circular substructure.

     (let ((x (list 'a 'b 'c)))
       (set-cdr! (cddr x) x)
       x)    ⇒ #0=(a b c . #0#)

   The scope of a datum label is the portion of the outermost datum in
which it appears that is to the right of the label.  Consequently, a
reference ‘#N#’ can occur only after a label ‘#N=’; it is an error to
attempt a forward reference.  In addition, it is an error if the
reference appears as the labelled object itself (as in ‘#N=#N#’),
because the object labelled by ‘#N=’ is not well defined in this case.

6.4.2 Abbreviations
-------------------

     ABBREVIATION ::= R6RS-ABBREVIATION | KAWA-ABBREVIATION
     R6RS-ABBREVIATION ::= ABBREV-PREFIX DATUM
     ABBREV-PREFIX ::= ‘’’ | ‘‘’ | ‘,’ | ‘,@’
              | ‘#’’ | ‘#‘’
     KAWA-ABBREVIATION ::= XXX

   The following abbreviations are expanded at read-time:

‘’’DATUM
     means ‘(quote’ DATUM‘)’.

‘‘’DATUM
     means ‘(quasiquote’ DATUM‘)’.

‘,’DATUM
     means ‘(unquote’ DATUM‘)’.

‘,@’DATUM
     means ‘(unquote-splicing’ DATUM‘)’.

‘#’’DATUM
     means ‘(syntax’ DATUM‘)’.

‘#‘’DATUM
     means ‘(quasisyntax’ DATUM‘)’.

‘#,’DATUM
     means ‘(unsyntax’ DATUM‘)’.  This abbreviation is currently only
     recognized when nested inside an explicit ‘#‘’DATUM form, because
     of a conflict with SRFI-10 named constructors.

‘#,@’DATUM
     means ‘(unsyntax-splicing’ DATUM‘)’.

DATUM1‘:’DATUM2
     means ‘($lookup$’ DATUM1 ‘(quasiquote’ DATUM2‘))’.  *Note Colon
     notation::.

‘[’EXPRESSION ...‘]’
     means ‘($bracket-list$’ EXPRESSION ...‘)’.

OPERATOR‘[’EXPRESSION ...‘]’
     means ‘($bracket-apply$’ OPERATOR EXPRESSION ...‘)’.


File: kawa.info,  Node: Hash-prefixed forms,  Next: Primitive expression syntax,  Prev: Datum syntax,  Up: Syntax

6.5 Hash-prefixed forms
=======================

A number of different special forms are indicated by an initial hash
(number) symbols (‘#’).  Here is a table summarizing them.

   Case is ignored for the character followed the ‘#’.  Thus ‘#x’ and
‘#X’ are the same.

‘#:’KEYWORD
     Guile-style keyword syntax (deprecated).
‘#\’
     *note Character literals: meta-character.
‘#!’
     *Note Special named constants::.
‘#‘’DATUM
     Equivalent to ‘(quasisyntax DATUM)’.  Convenience syntax for
     syntax-case macros.
‘#’’DATUM
     Equivalent to ‘(syntax DATUM)’.  Convenience syntax for syntax-case
     macros.
‘#,’DATUM
     Equivalent to ‘(unsyntax DATUM)’.  Currently only recognized when
     inside a ‘#`TEMPLATE’ form.  Convenience syntax for syntax-case
     macros.
‘#,(’NAME DATUM ...‘)’
     Special named constructors.  This syntax is deprecated, because it
     conflicts with ‘unsyntax’.  It is only recognized when _not_ in a
     ‘#`TEMPLATE’ form.
‘#,@’DATUM
     Equivalent to ‘(unsyntax-splicing DATUM)’.
‘#(’
     A vector.
‘#|’
     Start of nested-comment.
‘#/’REGEX‘/’
     *Note Regular expressions::.
‘#<’
     *Note XML literals::.
‘#;’DATUM
     A datum comment - the DATUM is ignored.  (An INTERLEXEME-SPACE may
     appear before the DATUM.)
‘#’NUMBER‘=’DATUM
     A reference definition, allowing cyclic and shared structure.
     Equivalent to the DATUM, but also defines an association between
     the integer NUMBER and that DATUM, which can be used by a
     subsequent ‘#NUMBER#’ form.
‘#’NUMBER‘#’
     A back-reference, allowing cyclic and shared structure.
‘#b’
     A binary (base-2) number.
‘#d’
     A decimal (base-10) number.
‘#e’
     A prefix to treat the following number as exact.
‘#f’
‘#false’
     The standard boolean false object.
‘#f’N‘(’NUMBER ...‘)’
     A uniform vector of floating-point numbers.  The parameter N is a
     precision, which can be 32 or 64.  *Note Uniform vectors::.
‘#i’
     A prefix to treat the following number as inexact.
‘#o’
     An octal (base-8) number.
‘#’BASE‘r’
     A number in the specified BASE (radix).
‘#s’N‘(’NUMBER ...‘)’
     A uniform vector of signed integers.  The parameter N is a
     precision, which can be 8, 16, 32, or 64.  *Note Uniform vectors::.
‘#t’
‘#true’
     The standard boolean true object.
‘#u’N‘(’NUMBER ...‘)’
     A uniform vector of unsigned integers.  The parameter N is a
     precision, which can be 8, 16, 32, or 64.  *Note Uniform vectors::.
‘#x’
     A hexadecimal (base-16) number.

   The follow named constructor forms are supported:

‘#,(path’ PATH‘)’
‘#,(filepath’ PATH‘)’
‘#,(URI’ PATH‘)’
‘#,(symbol’ LOCAL-NAME [URI [PREFIX]]‘)’
‘#,(symbol’ LOCAL-NAME NAMESPACE‘)’
‘#,(namespace’ URI [PREFIX]‘)’
‘#,(duration’ DURATION‘)’


File: kawa.info,  Node: Primitive expression syntax,  Next: Colon notation,  Prev: Hash-prefixed forms,  Up: Syntax

6.6 Primitive expression syntax
===============================

     EXPRESSION ::= LITERAL-EXPRESSION | VARIABLE-REFERENCE
       | PROCEDURE-CALL | TODO

6.6.1 Literal expressions
-------------------------

     LITERAL-EXPRESSION ::= ‘(quote’ DATUM‘)’
       | ‘’’ DATUM
       | CONSTANT
     CONSTANT ::= NUMBER | BOOLEAN | CHARACTER | STRING

   ‘(quote DATUM)’ evaluates to DATUM, which may be any external
representation of a Scheme object.  This notation is used to include
literal constants in Scheme code.
     (quote a)               ⇒  a
     (quote #(a b c))        ⇒  #(a b c)
     (quote (+ 1 2))         ⇒  (+ 1 2)

   ‘(quote DATUM)’ may be abbreviated as ‘'DATUM’.  The two notations
are equivalent in all respects.
     ’a                      ⇒  a
     ’#(a b c)               ⇒  #(a b c)
     ’()                     ⇒  ()
     ’(+ 1 2)                ⇒  (+ 1 2)
     ’(quote a)              ⇒  (quote a)
     ’’a                     ⇒  (quote a)

   Numerical constants, string constants, character constants,
bytevector constants, and boolean constants evaluate to themselves; they
need not be quoted.

     145932          ⇒  145932
     #t              ⇒  #t
     "abc"           ⇒  "abc"

   Note that *note keywords: Keywords. need to be quoted, unlike some
other Lisp/Scheme dialect, including Common Lisp, and earlier versions
of Kawa.  (Kawa currently evaluates a non-quoted keyword as itself, but
that will change.)

6.6.2 Variable references
-------------------------

     VARIABLE-REFERENCE ::= IDENTIFIER
   An expression consisting of a variable is a variable reference if it
is not a macro use (see below).  The value of the variable reference is
the value stored in the location to which the variable is bound.  It is
a syntax violation to reference an unbound variable.

   The following example examples assumes the base library has been
imported:

     (define x 28)
     x   ⇒  28

6.6.3 Procedure calls
---------------------

     PROCEDURE-CALL ::= ‘(’OPERATOR OPERAND …)
     OPERATOR ::= EXPRESSION
     OPERAND ::= EXPRESSION

   A procedure call consists of expressions for the procedure to be
called and the arguments to be passed to it, with enclosing parentheses.
A form in an expression context is a procedure call if OPERATOR is not
an identifier bound as a syntactic keyword.

   When a procedure call is evaluated, the operator and operand
expressions are evaluated (in an unspecified order) and the resulting
procedure is passed the resulting arguments.

     (+ 3 4)                ⇒  7
     ((if #f + *) 3 4)      ⇒  12


File: kawa.info,  Node: Colon notation,  Next: Bodies,  Prev: Primitive expression syntax,  Up: Syntax

6.7 Property access using colon notation
========================================

The "colon notation" accesses named parts (properties) of a value.  It
is used to get and set fields, call methods, construct compound symbols,
and more.  Evaluating the form ‘OWNER:PROPERTY’ evaluates the ‘OWNER’
then it extracts the named ‘PROPERTY’ of the result.

     PROPERTY-ACCESS-ABBREVIATION ::= PROPERTY-OWNER-EXPRESSION‘:’PROPERTY-NAME
     PROPERTY-OWNER-EXPRESSION ::= EXPRESSION
     PROPERTY-NAME ::= IDENTIFIER | ‘,’EXPRESSION

   The PROPERTY-NAME is usually a literal name, but it can be an
unquoted EXPRESSION (i.e.  following a ‘,’), in which case the name is
evaluated at run-time.  No separators are allowed on either side of the
colon.

   The input syntax ‘OWNER:PART’ is translated by the Scheme reader to
the internal representation ‘($lookup$ OWNER (quasiquote PART))’.

6.7.1 Part lookup rules
-----------------------

Evaluation proceeds as follows.  First PROPERTY-OWNER-EXPRESSION is
evaluated to yield a OWNER object.  Evaluating the PROPERTY-NAME yields
a PART name, which is a simple symbol: Either the literal IDENTIFIER, or
the result of evaluating the property-name EXPRESSION.  If the
EXPRESSION evaluates to a string, it is converted to a symbol, as if
using ‘string->symbol’.

   • If the OWNER implements ‘gnu.mapping.HasNamedParts’, then the
     result is that of invoking the ‘get’ method of the OWNER with the
     PART name as a parameter.

     As a special case of this rule, if OWNER is a
     ‘gnu.mapping.Namespace’, then the result is the *note compound
     symbol in that namespace: Namespaces.
   • If OWNER is a ‘java.lang.Class’ or a ‘gnu.bytecode.ObjectType’, the
     result is the static member named PART (i.e.  a static field,
     method, or member class).
   • If OWNER is a ‘java.lang.Package’ object, we get the member class
     or sub-package named PART.
   • Otherwise, we look for a named member (instance member or field).

     Note you can’t use colon notation to invoke instance methods of a
     ‘Class’, because it will match a previous rule.  For example if you
     want to invoke the ‘getDeclaredMethod’ method of the
     ‘java.util.List’ , you can’t write
     ‘(java.util.List:getDeclaredMethod’ because that will look for a
     static method in ‘java.util.List’.

   If the colon form is on the left-hand-side of an assignment (‘set!’),
then the named part is modified as appropriate.

6.7.2 Specific cases
--------------------

Some of these are depecated; more compact and readable forms are usually
preferred.

6.7.2.1 Invoking methods
........................

     ‘(’INSTANCE‘:’METHOD-NAME ARG ...‘)’
     ‘(’CLASS‘:’METHOD-NAME INSTANCE ARG ...‘)’
     ‘(’CLASS‘:’METHOD-NAME ARG ...‘)’
     ‘(*:’METHOD-NAME INSTANCE ARG ...‘)’

   For details *note Method operations::.

6.7.2.2 Accessing fields
........................

     CLASS‘:’FIELD-NAME
     INSTANCE‘:’FIELD-NAME
     ‘(’PREFIX‘:.’FIELD-NAME INSTANCE‘)’

   For details *note Field operations::.

6.7.2.3 Type literal
....................

     ‘(’TYPE‘:<>)’
   Returns the TYPE.  Deprecated; usually you can just write:
     TYPE

6.7.2.4 Type cast
.................

     ‘(’TYPE‘:’‘@’ EXPRESSION‘)’
   Performs a cast.  Deprecated; usually you can just write:
     ->TYPE

6.7.2.5 Type test
.................

     ‘(’TYPE‘:instanceof?’ EXPRESSION‘)’

   Deprecated; usually you can just write:
     (TYPE? EXPRESSION)

6.7.2.6 New object construction
...............................

     ‘(’TYPE‘:new’ ARG ...‘)’

   Deprecated; usually you can just write:
     ‘(’TYPE ARG ...‘)’

6.7.2.7 Getting array length
............................

     EXPRESSION‘:length’
     ‘(’EXPRESSION‘:.length)’


File: kawa.info,  Node: Bodies,  Next: Syntax and conditional compilation,  Prev: Colon notation,  Up: Syntax

6.8 Programs and Bodies
=======================

Program units
-------------

A PROGRAM-UNIT consists of a sequence of definitions and expressions.

     PROGRAM-UNIT ::= LIBRARY-DEFINITION^+ [STATEMENTS]
       | STATEMENTS
     STATEMENTS ::= STATEMENT^+
     STATEMENT ::= DEFINITION | EXPRESSION | ‘(begin’ STATEMENT^* ‘)’

   Typically a PROGRAM-UNIT corresponds to a single source file (i.e.a
named file in the file system).  Evaluating a PROGRAM-UNIT first
requires the Kawa processor to analyze the whole PROGRAM-UNIT to
determine which names are defined by the definitions, and then evaluates
each STATEMENT in order in the context of the defined names.  The value
of an EXPRESSION is normally discared, but may be printed out instead,
depending on the evaluating context.

   The read-eval-print-loop (REPL) reads one or more lines until it gets
a valid PROGRAM-UNIT, and evaluates it as above, except that the values
of expression are printed to the console (as if using the ‘display’
function).  Then the REPL reads and evaluates another PROGRAM-UNIT, and
so on.  A definition in an earlier PROGRAM-UNIT is remembered and is
visible in a later PROGRAM-UNIT unles it is overridden.

   A comment in the first 2 lines of a source file may contain an
encoding specification.  This can be used to tell the reader what kind
of character set encoding is used for the file.  This only works for a
character encoding that is compatible with ASCII (in the sense that if
the high-order bit is clear then it’s an ASCII character), and that are
no non-ASCI characters in the lines upto and including the encoding
specification.  A basic example is:
     ;; -*- coding: utf-8 -*-
   In general any string that matches the following regular expression
works:
     coding[:=]\s*([-a-zA-Z0-9]+)

Libraries
---------

A PROGRAM-UNIT may contain LIBRARY-DEFINITIONS.  In addition, any
STATEMENTS in PROGRAM-UNIT comprise an "implicit library", in that it
can be given a name, and referenced from other libraries.  Certain names
defined in the PROGRAM-UNIT an be exported, and then they can be
imported by other libraries For more information *note Module classes::.

   It is recommended but not required that:
   • There should be at most one LIBRARY-DEFINITION in a PROGRAM-UNIT.
   • The LIBRARY-NAME of the LIBRARY-DEFINITION should match the name of
     the source file.  For example:
          (define-library (foo bar) ...)
     should be in a file named ‘foo/bar.scm’.
   • If there is a LIBRARY-DEFINITION there should should be no extra
     STATEMENTS - i.e no implicit library definition.  (It is disallowed
     to ‘export’ any definitions from the implicit library if there are
     also a LIBRARY-DEFINITION.)
   Following these recommendations makes it easier to locate and
organize libraries.  However, having multiple libraries in a single
PROGRAM-UNIT is occasionally useful for source distribution and for
testing.

Bodies
------

The BODY of a ‘lambda’, ‘let’, ‘let*’, ‘let-values’, ‘let*-values’,
‘letrec’, or ‘letrec*’ expression, or that of a definition with a body
consists of zero or more definitions or expressions followed by a final
expression.  (Standard Scheme requires that all definitions precede all
expressions.)

     BODY ::= STATEMENT^*

   Each identifier defined by a definition is local to the BODY.  That
is, the identifier is bound, and the region of the binding is the entire
BODY.  Example:

     (let ((x 5))
       (define foo (lambda (y) (bar x y)))
       (define bar (lambda (a b) (+ (* a b) a)))
       (foo (+ x 3)))
     ⇒ 45

   When ‘begin’, ‘let-syntax’, or ‘letrec-syntax’ forms occur in a body
prior to the first expression, they are spliced into the body.  Some or
all of the body, including portions wrapped in ‘begin’, ‘let-syntax’, or
‘letrec-syntax’ forms, may be specified by a macro use.

   An expanded BODY containing variable definitions can be converted
into an equivalent ‘letrec*’ expression.  (If there is a definition
following expressions you may need to convert the expressions to dummy
definitions.)  For example, the ‘let’ expression in the above example is
equivalent to

     (let ((x 5))
       (letrec* ((foo (lambda (y) (bar x y)))
                 (bar (lambda (a b) (+ (* a b) a))))
         (foo (+ x 3))))


File: kawa.info,  Node: Syntax and conditional compilation,  Next: Macros,  Prev: Bodies,  Up: Syntax

6.9 Syntax and conditional compilation
======================================

Feature testing
---------------

 -- Syntax: cond-expand COND-EXPAND-CLAUSE^* [‘(else’
          command-or-definition*‘)’]
          COND-EXPAND-CLAUSE ::= ‘(’FEATURE-REQUIREMENT COMMAND-OR-DEFINITION*‘)’
          FEATURE-REQUIREMENT ::= FEATURE-IDENTIFIER
            | ‘(and’ FEATURE-REQUIREMENT^*‘)’
            | ‘(or’ FEATURE-REQUIREMENT^*‘)’
            | ‘(not’ FEATURE-REQUIREMENT‘)’
            | ‘(library’ LIBRARY-NAME‘)’
          FEATURE-IDENTIFIER ::= a symbol which is the name or alias of a SRFI

     The ‘cond-expand’ form tests for the existence of features at
     macro-expansion time.  It either expands into the body of one of
     its clauses or signals an error during syntactic processing.
     ‘cond-expand’ expands into the body of the first clause whose
     feature requirement is currently satisfied; the ‘else’ clause, if
     present, is selected if none of the previous clauses is selected.

     The implementation has a set of feature identifiers which are
     “present”, as well as a set of libraries which can be imported.
     The value of a FEATURE-REQUIREMENT is determined by replacing each
     FEATURE-IDENTIFIER by ‘#t’ if it is present (and ‘#f’ otherwise);
     replacing ‘(library LIBRARY-NAME)’ by ‘#t’ if LIBRARY-NAME is
     importable (and ‘#f’ otherwise); and then evaluating the resulting
     expression as a Scheme boolean expression under the normal
     interpretation of ‘and’, ‘or’, and ‘not’.

     Examples:
          (cond-expand
              ((and srfi-1 srfi-10)
               (write 1))
              ((or srfi-1 srfi-10)
               (write 2))
              (else))

          (cond-expand
            (command-line
             (define (program-name) (car (argv)))))

     The second example assumes that ‘command-line’ is an alias for some
     feature which gives access to command line arguments.  Note that an
     error will be signaled at macro-expansion time if this feature is
     not present.

     You can use ‘java-6’, ‘java-7’, ‘java-8’, or ‘java-9’ to check
     check if the underlying Java is a specific version or newer.  For
     example the name ‘java-7’ matches for either Java 7, Java 8, or
     newer, as reported by ‘System’ property ‘"java.version"’.

     You can use ‘class-exists:CLASSNAME’ to check if ‘CLASSNAME’ exists
     at compile-time.  The identifier ‘class-exists:org.example.MyClass’
     is roughly equivalent to the test ‘(library (org example
     MyClass))’.  (The latter has some special handling for ‘(srfi ...)’
     as well as builtin Kawa classes.)

 -- Procedure: features
     Returns a list of feature identifiers which ‘cond-expand’ treats as
     true.  This not a complete list - for example
     ‘class-exists:CLASSNAME’ feature identifiers are not included.  It
     is an error to modify this list.  Here is example of what
     ‘features’ might return:
          (features)  ⇒
          (complex exact-complex full-unicode java-7 java-6 kawa
           ratios srfi-0 srfi-4 srfi-6 srfi-8 srfi-9 srfi-11
           srfi-16 srfi-17 srfi-23 srfi-25 srfi-26 srfi-28 srfi-30
           srfi-39 string-normalize-unicode threads)

File inclusion
--------------

 -- Syntax: include path^+
 -- Syntax: include-relative path^+
 -- Syntax: include-ci path^+
     These take one or more path names expressed as string literals,
     find corresponding files, read the contents of the files in the
     specified order as if by repeated applications of ‘read’, and
     effectively replace the ‘include’ with a ‘begin’ form containing
     what was read from the files.

     You can control the search path used for ‘include’ by setting the
     ‘kawa.include.path’ property.  For example:
          $ kawa -Dkawa.include.path="|:/opt/kawa-includes"
     The special ‘"|"’ path element means to search relative to the
     directory containing the including source file.  The default search
     path is ‘"|:."’ which means to first search the directory
     containing the including source file, and then search the directory
     specified by ‘(current-path)’.

     The search path for ‘include-relative’ prepends ‘"|"’ before the
     search path used by ‘include’, so it always searches first the
     directory containing the including source file.  Note that if the
     default search path is used then ‘include’ and ‘include-relative’
     are equivalent; there is only a difference if the
     ‘kawa.include.path’ property changes the default.

     Using ‘include-ci’ is like ‘include’, except that it reads each
     file as if it began with the ‘#!fold-case’ directive.


File: kawa.info,  Node: Macros,  Next: Named quasi-literals,  Prev: Syntax and conditional compilation,  Up: Syntax

6.10 Macros
===========

Libraries and top–level programs can define and use new kinds of derived
expressions and definitions called _syntactic abstractions_ or _macros_.
A syntactic abstraction is created by binding a keyword to a _macro
transformer_ or, simply, _transformer_.

   The transformer determines how a use of the macro (called a _macro
use_) is transcribed into a more primitive form.

   Most macro uses have the form:

     (KEYWORD DATUM …)
where KEYWORD is an identifier that uniquely determines the kind of
form.  This identifier is called the _syntactic keyword_, or simply
_keyword_.  The number of DATUMs and the syntax of each depends on the
syntactic abstraction.

   Macro uses can also take the form of improper lists, singleton
identifiers, or ‘set!’ forms, where the second subform of the ‘set!’ is
the keyword:

     (KEYWORD DATUM … . DATUM)
     KEYWORD
     (set! KEYWORD DATUM)

   The ‘define-syntax’, ‘let-syntax’ and ‘letrec-syntax’ forms create
bindings for keywords, associate them with macro transformers, and
control the scope within which they are visible.

   The ‘syntax-rules’ and ‘identifier-syntax’ forms create transformers
via a pattern language.  Moreover, the ‘syntax-case’ form allows
creating transformers via arbitrary Scheme code.

   Keywords occupy the same name space as variables.  That is, within
the same scope, an identifier can be bound as a variable or keyword, or
neither, but not both, and local bindings of either kind may shadow
other bindings of either kind.

   Macros defined using ‘syntax-rules’ and ‘identifier-syntax’ are
“hygienic” and “referentially transparent” and thus preserve Scheme’s
lexical scoping.

   • If a macro transformer inserts a binding for an identifier
     (variable or keyword) not appearing in the macro use, the
     identifier is in effect renamed throughout its scope to avoid
     conflicts with other identifiers.

   • If a macro transformer inserts a free reference to an identifier,
     the reference refers to the binding that was visible where the
     transformer was specified, regardless of any local bindings that
     may surround the use of the macro.

   Macros defined using the ‘syntax-case’ facility are also hygienic
unless ‘datum->syntax’ is used.

   Kawa supports most of the ‘syntax-case’ feature.

   Syntax definitions are valid wherever definitions are.  They have the
following form:

 -- Syntax: define-syntax keyword TRANSFORMER-SPEC
     The KEYWORD is a identifier, and TRANSFORMER-SPEC is a function
     that maps syntax forms to syntax forms, usually an instance of
     ‘syntax-rules’.  If the ‘define-syntax’ occurs at the top level,
     then the top-level syntactic environment is extended by binding the
     KEYWORD to to the specified transformer, but existing references to
     any top-level binding for KEYWORD remain unchanged.  Otherwise, it
     is a "internal syntax definition", and is local to the BODY in
     which it is defined.

          (let ((x 1) (y 2))
             (define-syntax swap!
               (syntax-rules ()
                 ((swap! a b)
                  (let ((tmp a))
                    (set! a b)
                    (set! b tmp)))))
             (swap! x y)
             (list x y))  ⇒ (2 1)

     Macros can expand into definitions in any context that permits
     them.  However, it is an error for a definition to define an
     identifier whose binding has to be known in order to determine the
     meaning of the definitoion itself, or of any predecing definiton
     that belongs to the same group of internal definitions.

 -- Syntax: define-syntax-case name ‘(’literals‘)’ ‘(’pattern expr‘)’
          ...
     A convenience macro to make it easy to define ‘syntax-case’-style
     macros.  Defines a macro with the given NAME and list of LITERALS.
     Each PATTERN has the form of a ‘syntax-rules’-style pattern, and it
     is matched against the macro invocation syntax form.  When a match
     is found, the corresponding EXPR is evaluated.  It must evaluate to
     a syntax form, which replaces the macro invocation.
          (define-syntax-case macro-name (literals)
            (pat1 result1)
            (pat2 result2))
     is equivalent to:
          (define-syntax macro-name
            (lambda (form)
              (syntax-case form (literals)
                (pat1 result1)
                (pat2 result2))))

 -- Syntax: define-macro ‘(’name lambda-list‘)’ form ...
     _This form is deprecated._  Functionally equivalent to ‘defmacro’.

 -- Syntax: defmacro name lambda-list form ...
     _This form is deprecated._  Instead of
          (defmacro (NAME ...)
            (let ... `(... ,EXP ...)))
     you should probably do:
          (define-syntax-case NAME ()
            ((_ ...) (let #`(... #,EXP ...))))
     and instead of
          (defmacro (NAME ... VAR ...) `(... VAR ...))
     you should probably do:
          (define-syntax-case NAME ()
            ((_ ... VAR ...) #`(... VAR ...))

     Defines an old-style macro a la Common Lisp, and installs ‘(lambda
     LAMBDA-LIST FORM ...)’ as the expansion function for NAME.  When
     the translator sees an application of NAME, the expansion function
     is called with the rest of the application as the actual arguments.
     The resulting object must be a Scheme source form that is futher
     processed (it may be repeatedly macro-expanded).

 -- Procedure: gentemp
     Returns a new (interned) symbol each time it is called.  The symbol
     names are implementation-dependent.  (This is not directly
     macro-related, but is often used in conjunction with ‘defmacro’ to
     get a fresh unique identifier.)

 -- Procedure: expand form
     The result of evaluating FORM is treated as a Scheme expression,
     syntax-expanded to internal form, and then converted back to
     (roughly) the equivalent expanded Scheme form.

     This can be useful for debugging macros.

     To access this function, you must first ‘(require 'syntax-utils)’.
          (require 'syntax-utils)
          (expand '(cond ((> x y) 0) (else 1))) ⇒ (if (> x y) 0 1)

6.10.1 Pattern language
-----------------------

A TRANSFORMER-SPEC is an expression that evaluates to a transformer
procedure, which takes an input form and returns a resulting form.  You
can do general macro-time compilation with such a procedure, commonly
using ‘syntax-case’ (which is documented in the R6RS library
specification).  However, when possible it is better to use the simpler
pattern language of ‘syntax-rules’:

     TRANSFORMER-SPEC ::=
       ‘(syntax-rules (’ TR-LITERAL^* ‘)’ SYNTAX-RULE^*‘)’
       | ‘(syntax-rules’ ELLIPSIS ‘(’ TR-LITERAL^* ‘)’ SYNTAX-RULE^*‘)’
       | EXPRESSION
     SYNTAX-RULE ::= ‘(’LIST-PATTERN SYNTAX-TEMPLATE‘)’
     TR-LITERAL ::= IDENTIFIER
     ELLIPSIS ::= IDENTIFIER

   An instance of ‘syntax-rules’ produces a new macro transformer by
specifying a sequence of hygienic rewrite rules.  A use of a macro whose
keyword is associated with a transformer specified by ‘syntax-rules’ is
matched against the patterns contained in the SYNTAX-RULEs beginning
with the leftmost syntax rule .  When a match is found, the macro use is
transcribed hygienically according to the template.  The optional
ELLIPSIS species a symbol used to indicate repetition; it defaults to
‘...’ (3 periods).

     SYNTAX-PATTERN ::=
       IDENTIFIER | CONSTANT | LIST-PATTERN | VECTOR-PATTERN
     LIST-PATTERN ::= ‘(’ SYNTAX-PATTERN^* ‘)’
       | ‘(’ SYNTAX-PATTERN SYNTAX-PATTERN^* ‘.’ SYNTAX-PATTERN ‘)’
       | ‘(’ SYNTAX-PATTERN^* SYNTAX-PATTERN ELLIPSIS SYNTAX-PATTERN^* ‘)’
       | ‘(’ SYNTAX-PATTERN^* SYNTAX-PATTERN ELLIPSIS SYNTAX-PATTERN^* ‘.’ SYNTAX-PATTERN‘)’
     VECTOR-PATTERN ::= ‘#(’ SYNTAX-PATTERN^* ‘)’
       | ‘#(’ SYNTAX-PATTERN^* SYNTAX-PATTERN ELLIPSIS SYNTAX-PATTERN^* ‘)’

   An identifier appearing within a pattern can be an underscore (‘_’),
a literal identifier listed in the list of TR-LITERALs, or the ELLIPSIS.
All other identifiers appearing within a pattern are pattern variables.

   The outer SYNTAX-LIST of the pattern in a YNTAX-RULE must start with
an identifier.  It is not involved in the matching and is considered
neither a pattern variable nor a literal identifier.

   Pattern variables match arbitrary input elements and are used to
refer to elements of the input in the template.  It is an error for the
same pattern variable to appear more than once in a SYNTAX-PATTERN.

   Underscores also match arbitrary input elements but are not pattern
variables and so cannot be used to refer to those elements.  If an
underscore appears in the literals list, then that takes precedence and
underscores in the pattern match as literals.  Multiple underscores can
appear in a SYNTAX-PATTERN.

   Identifiers that appear in ‘(TR-LITERAL^*)’ are interpreted as
literal identifiers to be matched against corresponding elements of the
input.  An element in the input matches a literal identifier if and only
if it is an identifier and either both its occurrence in the macro
expression and its occurrence in the macro definition have the same
lexical binding, or the two identifiers are the same and both have no
lexical binding.

   A subpattern followed by ellipsis can match zero or more elements of
the input, unless ellipsis appears in the literals, in which case it is
matched as a literal.

   More formally, an input expression E matches a pattern P if and only
if:
   • P is an underscore (‘_’); or
   • P is a non-literal identifier; or
   • P is a literal identifier and E is an identifier with the same
     binding; or
   • P is a list ‘(’P_1 ...  P_N‘)’ and E is a list of N elements that
     match P_1 through P_N, respectively; or
   • P is an improper list ‘(’P_1 ...  P_N ‘.’  P_N+1‘)’ and E is a list
     or improper list of N or more elements that match P_1 through P_N,
     respectively, and whose Nth tail matches P_N+1; or
   • P is of the form ‘(’P_1 ...  P_K P_E ELLIPSIS P_K+1 ...  P_K+L‘)’
     where E is a proper list of N elements, the first K of which match
     P_1 through P_K, respectively, whose next N-K-L elements each match
     P_E, and whose remaining L elements match P_K+1 through P_K+L; or
   • P is of the form ‘(’P_1 ...  P_K P_E ELLIPSIS P_K+1 ...  P_K+L ‘.’
     P_X‘)’ where E is a list or improper list of N elements, the first
     K of which match P_1 through P_K, whose next N-K-L elements each
     match P_E, and whose remaining L elements match P_K+1 through
     P_K+L, and whose Nth and final ‘cdr’ matches P_X; or
   • P is a vector of the form ‘#(’P_1 ...  P_N‘)’ and E is a vector of
     N elements that match P_1 through P_N; or
   • P is of the form ‘#(’P_1 ...  P_K P_E ELLIPSIS P_K+1 ...  P_K+L‘)’
     where E is a vector of N elements the first K of which match P_1
     through P_K, whose next N-K-L elements each match P_E, and whose
     remaining L elements match P_K+1 through P_K+L; or
   • P is a constant and E is equal to P in the sense of the ‘equal?’
     procedure.

   It is an error to use a macro keyword, within the scope of its
binding, in an expression that does not match any of the patterns.
     SYNTAX-TEMPLATE ::= IDENTIFIER | CONSTANT
        | ‘(’TEMPLATE-ELEMENT^*‘)’
        | ‘(’TEMPLATE-ELEMENT TEMPLATE-ELEMENT^* ‘.’ SYNTAX-TEMPLATE ‘)’
        | ‘(’ ELLIPSIS SYNTAX-TEMPLATE‘)’
     TEMPLATE-ELEMENT ::= SYNTAX-TEMPLATE [ELLIPSIS]

   When a macro use is transcribed according to the template of the
matching SYNTAX-RULE, pattern variables that occur in the template are
replaced by the elements they match in the input.  Pattern variables
that occur in subpatterns followed by one or more instances of the
identifier ELLIPSIS are allowed only in subtemplates that are followed
by as many instances of ELLIPSIS .  They are replaced in the output by
all of the elements they match in the input, distributed as indicated.
It is an error if the output cannot be built up as specified.

   Identifiers that appear in the template but are not pattern variables
or the identifier ELLIPSIS are inserted into the output as literal
identifiers.  If a literal identifier is inserted as a free identifier
then it refers to the binding of that identifier within whose scope the
instance of ‘syntax-rules’ appears.  If a literal identifier is inserted
as a bound identifier then it is in effect renamed to prevent
inadvertent captures of free identifiers.

   A template of the form ‘(’ELLIPSIS TEMPLATE‘)’ is identical to
TEMPLATE , except that ELLIPSES within the template have no special
meaning.  That is, any ELLIPSES contained within TEMPLATE are treated as
ordinary identifiers.  In particular, the template ‘(’ELLIPSIS
ELLIPSIS‘)’ produces a single ELLIPSIS.  This allows syntactic
abstractions to expand into code containing ellipses.

     (define-syntax be-like-begin
       (syntax-rules ()
         ((be-like-begin name)
          (define-syntax name
            (syntax-rules ()
              ((name expr (... ...))
               (begin expr (... ...))))))))

     (be-like-begin sequence)
     (sequence 1 2 3 4) ⇒ 4

6.10.2 Identifier predicates
----------------------------

 -- Procedure: identifier? OBJ
     Return ‘#t’ if OBJ is an identifier, i.e., a syntax object
     representing an identifier, and ‘#f’ otherwise.

     The ‘identifier?’ procedure is often used within a fender to verify
     that certain subforms of an input form are identifiers, as in the
     definition of ‘rec’, which creates self–contained recursive
     objects, below.

          (define-syntax rec
            (lambda (x)
              (syntax-case x ()
                ((_ x e)
                 (identifier? #'x)
                 #'(letrec ((x e)) x)))))

          (map (rec fact
                 (lambda (n)
                   (if (= n 0)
                       1
                       (* n (fact (- n 1))))))
               '(1 2 3 4 5))    ⇒ (1 2 6 24 120)

          (rec 5 (lambda (x) x))  ⇒ exception

   The procedures ‘bound-identifier=?’ and ‘free-identifier=?’ each take
two identifier arguments and return ‘#t’ if their arguments are
equivalent and ‘#f’ otherwise.  These predicates are used to compare
identifiers according to their _intended use_ as free references or
bound identifiers in a given context.

 -- Procedure: bound-identifier=? ID1 ID2
     ID1 and ID2 must be identifiers.

     The procedure ‘bound-identifier=?’ returns ‘#t’ if a binding for
     one would capture a reference to the other in the output of the
     transformer, assuming that the reference appears within the scope
     of the binding, and ‘#f’ otherwise.

     In general, two identifiers are ‘bound-identifier=?’ only if both
     are present in the original program or both are introduced by the
     same transformer application (perhaps implicitly, see
     ‘datum->syntax’).

     The ‘bound-identifier=?’ procedure can be used for detecting
     duplicate identifiers in a binding construct or for other
     preprocessing of a binding construct that requires detecting
     instances of the bound identifiers.

 -- Procedure: free-identifier=? ID1 ID2
     ID1 and ID2 must be identifiers.

     The ‘free-identifier=?’ procedure returns ‘#t’ if and only if the
     two identifiers would resolve to the same binding if both were to
     appear in the output of a transformer outside of any bindings
     inserted by the transformer.  (If neither of two like–named
     identifiers resolves to a binding, i.e., both are unbound, they are
     considered to resolve to the same binding.)

     Operationally, two identifiers are considered equivalent by
     ‘free-identifier=?’ if and only the topmost matching substitution
     for each maps to the same binding or the identifiers have the same
     name and no matching substitution.

     The ‘syntax-case’ and ‘syntax-rules’ forms internally use
     ‘free-identifier=?’ to compare identifiers listed in the literals
     list against input identifiers.

          (let ((fred 17))
            (define-syntax a
              (lambda (x)
                (syntax-case x ()
                  ((_ id) #'(b id fred)))))
            (define-syntax b
              (lambda (x)
                (syntax-case x ()
                  ((_ id1 id2)
                   #`(list
                       #,(free-identifier=? #'id1 #'id2)
                       #,(bound-identifier=? #'id1 #'id2))))))
            (a fred))
              ⇒ (#t #f)

     The following definition of unnamed ‘let’ uses ‘bound-identifier=?’
     to detect duplicate identifiers.

          (define-syntax let
            (lambda (x)
              (define unique-ids?
                (lambda (ls)
                  (or (null? ls)
                      (and (let notmem? ((x (car ls)) (ls (cdr ls)))
                             (or (null? ls)
                                 (and (not (bound-identifier=? x (car ls)))
                                      (notmem? x (cdr ls)))))
                           (unique-ids? (cdr ls))))))
              (syntax-case x ()
                ((_ ((i v) ...) e1 e2 ...)
                 (unique-ids? #'(i ...))
                 #'((lambda (i ...) e1 e2 ...) v ...)))))

     The argument ‘#'(i ...)’ to ‘unique-ids?’ is guaranteed to be a
     list by the rules given in the description of ‘syntax’ above.

     With this definition of ‘let’:

          (let ((a 3) (a 4)) (+ a a))    ⇒ syntax error

     However,
          (let-syntax
            ((dolet (lambda (x)
                      (syntax-case x ()
                        ((_ b)
                         #'(let ((a 3) (b 4)) (+ a b)))))))
            (dolet a))
          ⇒ 7

     since the identifier ‘a’ introduced by ‘dolet’ and the identifier
     ‘a’ extracted from the input form are not ‘bound-identifier=?’.

     Rather than including ‘else’ in the literals list as before, this
     version of ‘case’ explicitly tests for ‘else’ using
     ‘free-identifier=?’.

          (define-syntax case
            (lambda (x)
              (syntax-case x ()
                ((_ e0 ((k ...) e1 e2 ...) ...
                    (else-key else-e1 else-e2 ...))
                 (and (identifier? #'else-key)
                      (free-identifier=? #'else-key #'else))
                 #'(let ((t e0))
                     (cond
                      ((memv t '(k ...)) e1 e2 ...)
                      ...
                      (else else-e1 else-e2 ...))))
                ((_ e0 ((ka ...) e1a e2a ...)
                    ((kb ...) e1b e2b ...) ...)
                 #'(let ((t e0))
                     (cond
                      ((memv t '(ka ...)) e1a e2a ...)
                      ((memv t '(kb ...)) e1b e2b ...)
                      ...))))))

     With either definition of ‘case’, ‘else’ is not recognized as an
     auxiliary keyword if an enclosing lexical binding for ‘else’
     exists.  For example,

          (let ((else #f))
            (case 0 (else (write "oops"))))    ⇒ syntax error

     since ‘else’ is bound lexically and is therefore not the same
     ‘else’ that appears in the definition of ‘case’.

6.10.3 Syntax-object and datum conversions
------------------------------------------

 -- Procedure: syntax->datum SYNTAX-OBJECT
 -- Deprecated procedure: syntax-object->datum SYNTAX-OBJECT
     Strip all syntactic information from a syntax object and returns
     the corresponding Scheme datum.

     Identifiers stripped in this manner are converted to their symbolic
     names, which can then be compared with ‘eq?’.  Thus, a predicate
     ‘symbolic-identifier=?’ might be defined as follows.

          (define symbolic-identifier=?
            (lambda (x y)
              (eq? (syntax->datum x)
                   (syntax->datum y))))

 -- Procedure: datum->syntax TEMPLATE-ID DATUM [SRCLOC]
 -- Deprecated procedure: datum->syntax-object TEMPLATE-ID DATUM
     TEMPLATE-ID must be a template identifier and DATUM should be a
     datum value.

     The ‘datum->syntax’ procedure returns a syntax-object
     representation of DATUM that contains the same contextual
     information as TEMPLATE-ID, with the effect that the syntax object
     behaves as if it were introduced into the code when TEMPLATE-ID was
     introduced.

     If SRCLOC is specified (and neither ‘#f’ or ‘#!null’), it specifies
     the file position (including line number) for the result.  In that
     case it should be a syntax object representing a list; otherwise it
     is currently ignored, though future extensions may support other
     ways of specifying the position.

     The ‘datum->syntax’ procedure allows a transformer to “bend”
     lexical scoping rules by creating _implicit identifiers_ that
     behave as if they were present in the input form, thus permitting
     the definition of macros that introduce visible bindings for or
     references to identifiers that do not appear explicitly in the
     input form.  For example, the following defines a ‘loop’ expression
     that uses this controlled form of identifier capture to bind the
     variable ‘break’ to an escape procedure within the loop body.  (The
     derived ‘with-syntax’ form is like ‘let’ but binds pattern
     variables.)

          (define-syntax loop
            (lambda (x)
              (syntax-case x ()
                ((k e ...)
                 (with-syntax
                     ((break (datum->syntax #'k 'break)))
                   #'(call-with-current-continuation
                       (lambda (break)
                         (let f () e ... (f)))))))))

          (let ((n 3) (ls '()))
            (loop
              (if (= n 0) (break ls))
              (set! ls (cons 'a ls))
              (set! n (- n 1))))
          ⇒ (a a a)

     Were ‘loop’ to be defined as:

          (define-syntax loop
            (lambda (x)
              (syntax-case x ()
                ((_ e ...)
                 #'(call-with-current-continuation
                     (lambda (break)
                       (let f () e ... (f))))))))

     the variable ‘break’ would not be visible in ‘e ...’.

     The datum argument DATUM may also represent an arbitrary Scheme
     form, as demonstrated by the following definition of ‘include’.

          (define-syntax include
            (lambda (x)
              (define read-file
                (lambda (fn k)
                  (let ((p (open-file-input-port fn)))
                    (let f ((x (get-datum p)))
                      (if (eof-object? x)
                          (begin (close-port p) '())
                          (cons (datum->syntax k x)
                                (f (get-datum p))))))))
              (syntax-case x ()
                ((k filename)
                 (let ((fn (syntax->datum #'filename)))
                   (with-syntax (((exp ...)
                                  (read-file fn #'k)))
                     #'(begin exp ...)))))))

     ‘(include "filename")’ expands into a ‘begin’ expression containing
     the forms found in the file named by ‘"filename"’.  For example, if
     the file ‘flib.ss’ contains:

          (define f (lambda (x) (g (* x x))))

     and the file ‘glib.ss’ contains:

          (define g (lambda (x) (+ x x)))

     the expression:

          (let ()
            (include "flib.ss")
            (include "glib.ss")
            (f 5))

     evaluates to ‘50’.

     The definition of ‘include’ uses ‘datum->syntax’ to convert the
     objects read from the file into syntax objects in the proper
     lexical context, so that identifier references and definitions
     within those expressions are scoped where the ‘include’ form
     appears.

     Using ‘datum->syntax’, it is even possible to break hygiene
     entirely and write macros in the style of old Lisp macros.  The
     ‘lisp-transformer’ procedure defined below creates a transformer
     that converts its input into a datum, calls the programmer’s
     procedure on this datum, and converts the result back into a syntax
     object scoped where the original macro use appeared.

          (define lisp-transformer
            (lambda (p)
              (lambda (x)
                (syntax-case x ()
                  ((kwd . rest)
                   (datum->syntax #'kwd
                     (p (syntax->datum x))))))))

6.10.4 Signaling errors in macro transformers
---------------------------------------------

 -- Syntax: syntax-error message args^*
     The MESSAGE and ARGS are treated similary as for the ‘error’
     procedure.  However, the error is reported when the ‘syntax-error’
     is expanded.  This can be used as a ‘syntax-rules’ template for a
     pattern that is an invalid use of the macro, which can provide more
     descriptive error messages.  The MESSAGE should be a string
     literal, and the ARGS arbitrary (non-evalualted) expressions
     providing additional information.

          (define-syntax simple-let
            (syntax-rules ()
              ((_ (head ... ((x . y) val) . tail)
                 body1 body2 ...)
               (syntax-error "expected an identifier but got" (x . y)))
              ((_ ((name val) ...) body1 body2 ...)
               ((lambda (name ...) body1 body2 ...)
                val ...))))

 -- Procedure: report-syntax-error location message
     This is a procedure that can be called at macro-expansion time by a
     syntax transformer function.  (In contrast ‘syntax-error’ is a
     syntax form used in the expansion result.)  The MESSAGE is reported
     as a compile-time error message.  The LOCATION is used for the
     source location (file name and line/column numbers): In general it
     can be a ‘SourceLocator’ value; most commonly it is a syntax object
     for a sub-list of the input form that is erroneous.  The value
     returned by ‘report-syntax-error’ is an instance of ‘ErrorExp’,
     which supresses further compilation.

          (define-syntax if
            (lambda (x)
              (syntax-case x ()
                           ((_ test then)
                            (make-if-exp #'test #'then #!null))
                           ((_ test then else)
                            (make-if-exp #'test #'then #'else))
                           ((_ e1 e2 e3 . rest)
                            (report-syntax-error #'rest
                             "too many expressions for 'if'"))
                           ((_ . rest)
                            (report-syntax-error #'rest
                             "too few expressions for 'if'")))))
     In the above example, one could use the source form ‘x’ for the
     location, but using ‘#'rest’ is more accurate.  Note that the
     following is incorrect, because ‘e1’ might not be a pair, in which
     case we don’t have location information for it (due to a Kawa
     limitation):
              (syntax-case x ()
                           ...
                           ((_ e1)
                            (report-syntax-error
                             #'e1 ;; poor location specifier
                             "too few expressions for 'if'")))))

6.10.5 Convenience forms
------------------------

 -- Syntax: with-syntax ((PATTERN EXPRESSION) …) BODY
     The ‘with-syntax’ form is used to bind pattern variables, just as
     ‘let’ is used to bind variables.  This allows a transformer to
     construct its output in separate pieces, then put the pieces
     together.

     Each PATTERN is identical in form to a ‘syntax-case’ pattern.  The
     value of each EXPRESSION is computed and destructured according to
     the corresponding PATTERN, and pattern variables within the PATTERN
     are bound as with ‘syntax-case’ to the corresponding portions of
     the value within BODY.

     The ‘with-syntax’ form may be defined in terms of ‘syntax-case’ as
     follows.

          (define-syntax with-syntax
            (lambda (x)
              (syntax-case x ()
                ((_ ((p e0) ...) e1 e2 ...)
                 (syntax (syntax-case (list e0 ...) ()
                           ((p ...) (let () e1 e2 ...))))))))

     The following definition of ‘cond’ demonstrates the use of
     ‘with-syntax’ to support transformers that employ recursion
     internally to construct their output.  It handles all ‘cond’ clause
     variations and takes care to produce one-armed ‘if’ expressions
     where appropriate.

          (define-syntax cond
            (lambda (x)
              (syntax-case x ()
                ((_ c1 c2 ...)
                 (let f ((c1 #'c1) (c2* #'(c2 ...)))
                   (syntax-case c2* ()
                     (()
                      (syntax-case c1 (else =>)
                       (((else e1 e2 ...) #'(begin e1 e2 ...))
                        ((e0) #'e0)
                        ((e0 => e1)
                         #'(let ((t e0)) (if t (e1 t))))
                        ((e0 e1 e2 ...)
                         #'(if e0 (begin e1 e2 ...)))))
                     ((c2 c3 ...)
                      (with-syntax ((rest (f #'c2 #'(c3 ...))))
                        (syntax-case c1 (=>)
                          ((e0) #'(let ((t e0)) (if t t rest)))
                          ((e0 => e1)
                           #'(let ((t e0)) (if t (e1 t) rest)))
                          ((e0 e1 e2 ...)
                           #'(if e0
                                  (begin e1 e2 ...)
                                  rest)))))))))))

 -- Syntax: quasisyntax TEMPLATE
 -- Auxiliary Syntax: unsyntax
 -- Auxiliary Syntax: unsyntax-splicing
     The ‘quasisyntax’ form is similar to ‘syntax’, but it allows parts
     of the quoted text to be evaluated, in a manner similar to the
     operation of ‘quasiquote’.

     Within a ‘quasisyntax’ TEMPLATE, subforms of ‘unsyntax’ and
     ‘unsyntax-splicing’ forms are evaluated, and everything else is
     treated as ordinary template material, as with ‘syntax’.

     The value of each ‘unsyntax’ subform is inserted into the output in
     place of the ‘unsyntax’ form, while the value of each
     ‘unsyntax-splicing’ subform is spliced into the surrounding list or
     vector structure.  Uses of ‘unsyntax’ and ‘unsyntax-splicing’ are
     valid only within ‘quasisyntax’ expressions.

     A ‘quasisyntax’ expression may be nested, with each ‘quasisyntax’
     introducing a new level of syntax quotation and each ‘unsyntax’ or
     ‘unsyntax-splicing’ taking away a level of quotation.  An
     expression nested within _n_ ‘quasisyntax’ expressions must be
     within _n_ _unsyntax_ or ‘unsyntax-splicing’ expressions to be
     evaluated.

     As noted in ABBREVIATION, ‘#`TEMPLATE’ is equivalent to
     ‘(quasisyntax TEMPLATE)’, ‘#,TEMPLATE’ is equivalent to ‘(unsyntax
     TEMPLATE)’, and ‘#,@TEMPLATE’ is equivalent to ‘(unsyntax-splicing
     TEMPLATE)’.  _Note_ that for backwards compatibility, you should
     only use ‘#,TEMPLATE’ inside a literal ‘#`TEMPLATE’ form.

     The ‘quasisyntax’ keyword can be used in place of ‘with-syntax’ in
     many cases.  For example, the definition of ‘case’ shown under the
     description of ‘with-syntax’ above can be rewritten using
     ‘quasisyntax’ as follows.

          (define-syntax case
            (lambda (x)
              (syntax-case x ()
                ((_ e c1 c2 ...)
                 #`(let ((t e))
                     #,(let f ((c1 #'c1) (cmore #'(c2 ...)))
                         (if (null? cmore)
                             (syntax-case c1 (else)
                               ((else e1 e2 ...)
                                #'(begin e1 e2 ...))
                               (((k ...) e1 e2 ...)
                                #'(if (memv t '(k ...))
                                      (begin e1 e2 ...))])
                             (syntax-case c1 ()
                               (((k ...) e1 e2 ...)
                                #`(if (memv t '(k ...))
                                      (begin e1 e2 ...)
                                      #,(f (car cmore)
                                            (cdr cmore))))))))))))

     _Note:_ Any ‘syntax-rules’ form can be expressed with ‘syntax-case’
     by making the ‘lambda’ expression and ‘syntax’ expressions
     explicit, and ‘syntax-rules’ may be defined in terms of
     ‘syntax-case’ as follows.

          (define-syntax syntax-rules
            (lambda (x)
              (syntax-case x ()
                ((_ (lit ...) ((k . p) t) ...)
                 (for-all identifier? #'(lit ... k ...))
                 #'(lambda (x)
                     (syntax-case x (lit ...)
                       ((_ . p) #'t) ...))))))


File: kawa.info,  Node: Named quasi-literals,  Prev: Macros,  Up: Syntax

6.11 Named quasi-literals
=========================

Traditional Scheme has only a few kinds of values, and thus only a few
builtin kinds of literals.  Modern Scheme allows defining new types, so
it is desirable to have a mechanism for defining literal values for the
new types.

   Consider the ‘*note URI: URI-type.’ type.  You can create a new
instance of a ‘URI’ using a constructor function:
     (URI "http://example.com/")
   This isn’t too bad, though the double-quote characters are an ugly
distraction.  However, if you need to construct the string it gets
messy:
     (URI (string-append base-uri "icon.png"))

   Instead use can write:
     &URI{http://example.com/}
   or:
     &URI{&[base-uri]icon.png}

   This syntax is translated by the Scheme reader to the more familiar
but more verbose equivalent forms:
     ($construct$:URI "http://example.com/")
     ($construct$:URI $<<$ base-uri $>>$ "icon.png")
   So for this to work there just needs to be a definition of
‘$construct$:URI’, usually a macro.  Normal scope rules apply; typically
you’d define ‘$construct$:URI’ in a module.

   The names ‘$<<$’ and ‘$>>$’ are bound to unique zero-length strings.
They are used to allow the implementation of ‘$construct$:URI’ to
determine which arguments are literal and which come from escaped
expressions.

   If you want to define your own ‘$construct$:TAG’, or to read
motivation and details, see the SRFI 108
(http://srfi.schemers.org/srfi-108/srfi-108.html) specification.

     EXTENDED-DATUM-LITERAL ::=
         ‘&’ CNAME ‘{’ [INITIAL-IGNORED] NAMED-LITERAL-PART^* ‘}’
       | ‘&’ CNAME ‘[’ EXPRESSION^* ‘]{’ [INITIAL-IGNORED] NAMED-LITERAL-PART^* ‘}’
     CNAME ::= IDENTIFIER
     NAMED-LITERAL-PART ::=
         any character except ‘&’, ‘{’ or ‘}’
       | ‘{’ NAMED-LITERAL-PART^+ ‘}’
       | CHAR-REF
       | ENTITY-REF
       | SPECIAL-ESCAPE
       | ENCLOSED-PART
       | EXTENDED-DATUM-LITERAL


File: kawa.info,  Node: Program structure,  Next: Multiple values,  Prev: Syntax,  Up: Top

7 Program structure
*******************

See *note program units:: for some notes on structure of an entire
source file.

* Menu:

* Boolean values::
* Conditionals::
* Definitions::
* Local binding constructs::
* Lazy evaluation::
* Threads::
* Exceptions::           Exception handling


File: kawa.info,  Node: Boolean values,  Next: Conditionals,  Up: Program structure

7.1 Boolean values
==================

The standard boolean objects for true and false are written as ‘#t’ and
‘#f’.  Alternatively, they may be written ‘#true’ and ‘#false’,
respectively.

     BOOLEAN ::= ‘#t’ | ‘#f’ | ‘#true’ | ‘#false’

   What really matters, though, are the objects that the Scheme
conditional expressions (‘if’, ‘cond’, ‘and’, ‘or’, ‘when’, ‘unless’,
‘do’) treat as true or false.  The phrase “a true value” (or sometimes
just “true”) means any object treated as true by the conditional
expressions, and the phrase “a false value” (or “false”) means any
object treated as false by the conditional expressions.

   Of all the Scheme values, only ‘#f’ counts as false in conditional
expressions.  All other Scheme values, including ‘#t’, count as true.  A
TEST-EXPRESSION is an expression evaluated in this manner for whether it
is true or false.

   _Note:_ There are plans to also treat as false the Java values
‘#!null’, and also all ‘java.lang.Boolean’ instances for which
‘booleanValue()’ return ‘false’ (in addition to the special
‘Boolean:FALSE’ instance which is already false).  However, this is not
yet implemented.

   _Note:_ Unlike some other dialects of Lisp, Scheme distinguishes ‘#f’
and the empty list from each other and from the symbol ‘nil’.

   Boolean constants evaluate to themselves, so they do not need to be
quoted in programs.

     #t       ⇒  #t
     #true    ⇒  #t
     #f       ⇒  #f
     #false   ⇒  #f
     '#f      ⇒  #f

 -- Type: boolean
     The type of boolean values.  As a type conversion, a true value is
     converted to ‘#t’, while a false value is converted to ‘#f’.
     Represented as a primitive Java ‘boolean’ or ‘kava.lang.Boolean’
     when converted to an object.

 -- Procedure: boolean? obj
     The ‘boolean?’ predicate returns ‘#t’ if OBJ is either ‘#t’ or
     ‘#f’, and returns ‘#f’ otherwise.
          (boolean? #f)   ⇒  #t
          (boolean? 0)    ⇒  #f
          (boolean? '())  ⇒  #f

 -- Procedure: not obj
     The not procedure returns ‘#t’ if OBJ is false, and returns ‘#f’
     otherwise.

          (not #t)         ⇒  #f
          (not 3)          ⇒  #f
          (not (list 3))   ⇒  #f
          (not #f)         ⇒  #t
          (not ’())        ⇒  #f
          (not (list))     ⇒  #f
          (not ’nil)       ⇒  #f

 -- Procedure: boolean=? boolean1 boolean2 boolean3 ...
     Returns ‘#t’ if all the arguments are booleans and all are ‘#t’ or
     all are ‘#f’.


File: kawa.info,  Node: Conditionals,  Next: Definitions,  Prev: Boolean values,  Up: Program structure

7.2 Conditionals
================

     TEST-EXPRESSION ::= EXPRESSION
     CONSEQUENT ::= EXPRESSION
     ALTERNATE ::= EXPRESSION

 -- Syntax: if TEST-EXPRESSION CONSEQUENT ALTERNATE
 -- Syntax: if TEST-EXPRESSION CONSEQUENT

     An ‘if’ expression is evaluated as follows: first, TEST-EXPRESSION
     is evaluated.  If it yields a true value, then CONSEQUENT is
     evaluated and its values are returned.  Otherwise ALTERNATE is
     evaluated and its values are returned.  If TEST yields ‘#f’ and no
     ALTERNATE is specified, then the result of the expression is
     unspecified.

          (if (> 3 2) 'yes 'no)          ⇒ yes
          (if (> 2 3) 'yes 'no)          ⇒ no
          (if (> 3 2)
              (- 3 2)
              (+ 3 2))                   ⇒ 1
          (if #f #f)                     ⇒ unspecified

     The CONSEQUENT and ALTERNATE expressions are in tail context if the
     ‘if’ expression itself is.

 -- Syntax: cond COND-CLAUSE^+
 -- Syntax: cond COND-CLAUSE^* ‘(else’ EXPRESSION…‘)’

          COND-CLAUSE ::= ‘(’TEST-EXPRESSION EXPRESSION^*‘)’
              | ‘(’TEST ‘=>’ EXPRESSION‘)’

     A ‘cond’ expression is evaluated by evaluating the TEST-EXPRESSIONs
     of successive COND-CLAUSEs in order until one of them evaluates to
     a true value.  When a TEST-EXPRESSION evaluates to a true value,
     then the remaining EXPRESSIONs in its COND-CLAUSE are evaluated in
     order, and the results of the last EXPRESSION in the COND-CLAUSE
     are returned as the results of the entire ‘cond’ expression.  If
     the selected COND-CLAUSE contains only the TEST-EXPRESSION and no
     EXPRESSIONs, then the value of the TEST-EXPRESSION is returned as
     the result.  If the selected COND-CLAUSE uses the ‘=>’ alternate
     form, then the EXPRESSION is evaluated.  Its value must be a
     procedure.  This procedure should accept one argument; it is called
     on the value of the TEST-EXPRESSION and the values returned by this
     procedure are returned by the ‘cond’ expression.

     If all TEST-EXPRESSIONs evaluate to ‘#f’, and there is no ‘else’
     clause, then the conditional expression returns unspecified values;
     if there is an ‘else’ clause, then its EXPRESSIONs are evaluated,
     and the values of the last one are returned.

          (cond ((> 3 2) 'greater)
                ((< 3 2) 'less))         ⇒ greater

          (cond ((> 3 3) 'greater)
                ((< 3 3) 'less)
                (else 'equal))           ⇒ equal

          (cond ('(1 2 3) => cadr)
                (else #f))               ⇒ 2

     For a COND-CLAUSE of one of the following forms:
          (TEST EXPRESSION^*)
          (else EXPRESSION EXPRESSION^*)

     the last EXPRESSION is in tail context if the ‘cond’ form itself
     is.  For a COND CLAUSE of the form:

          (TEST => EXPRESSION)

     the (implied) call to the procedure that results from the
     evaluation of EXPRESSION is in a tail context if the ‘cond’ form
     itself is.

 -- Syntax: case CASE-KEY CASE-CLAUSE^+
 -- Syntax: case CASE-KEY CASE-CLAUSE^* CASE-ELSE-CLAUSE

          CASE-KEY ::= EXPRESSION
          CASE-CLAUSE ::= ‘((’DATUM^*‘)’ EXPRESSION^+‘)’
              | ‘((’DATUM^*‘)’ ‘=>’ EXPRESSION‘)’
          CASE-ELSE-CLAUSE ::= ‘(else’  EXPRESSION^+‘)’
              | ‘(else =>’ EXPRESSION‘)’

     Each DATUM is an external representation of some object.  Each
     DATUM in the entire ‘case’ expression should be distinct.

     A ‘case’ expression is evaluated as follows.

       1. The CASE-KEY is evaluated and its result is compared using
          ‘eqv?’ against the data represented by the DATUMs of each
          CASE-CLAUSE in turn, proceeding in order from left to right
          through the set of clauses.

       2. If the result of evaluating CASE-KEY is equivalent to a datum
          of a CASE-CLAUSE, the corresponding EXPRESSIONs are evaluated
          from left to right and the results of the last expression in
          the CASE-CLAUSE are returned as the results of the ‘case’
          expression.  Otherwise, the comparison process continues.
       3. If the result of evaluating KEY is different from every datum
          in each set, then if there is an CASE-ELSE-CLAUSE its
          expressions are evaluated and the results of the last are the
          results of the ‘case’ expression; otherwise the result of
          ‘case’ expression is unspecified.

     If the selected CASE-CLAUSE or CASE-ELSE-CLAUSE uses the ‘=>’
     alternate form, then the EXPRESSION is evaluated.  It is an error
     if its value is not a procedure accepting one argument.  This
     procedure is then called on the value of the KEY and the values
     returned by this procedure are returned by the ‘case’ expression.

          (case (* 2 3)
            ((2 3 5 7) 'prime)
            ((1 4 6 8 9) 'composite))    ⇒ composite
          (case (car '(c d))
            ((a) 'a)
            ((b) 'b))                    ⇒ unspecified
          (case (car '(c d))
            ((a e i o u) 'vowel)
            ((w y) 'semivowel)
            (else => (lambda (x) x)))    ⇒ c

     The last EXPRESSION of a CASE CLAUSE is in tail context if the
     ‘case’ expression itself is.

 -- Syntax: and TEST-EXPRESSION …

     If there are no TEST-EXPRESSIONs, ‘#t’ is returned.  Otherwise, the
     TEST-EXPRESSION are evaluated from left to right until a
     TEST-EXPRESSION returns ‘#f’ or the last TEST-EXPRESSION is
     reached.  In the former case, the ‘and’ expression returns ‘#f’
     without evaluating the remaining expressions.  In the latter case,
     the last expression is evaluated and its values are returned.

          (and (= 2 2) (> 2 1))          ⇒  #t
          (and (= 2 2) (< 2 1))          ⇒  #f
          (and 1 2 'c '(f g))            ⇒  (f g)
          (and)                          ⇒  #t

     The ‘and’ keyword could be defined in terms of ‘if’ using
     ‘syntax-rules’ as follows:

          (define-syntax and
            (syntax-rules ()
              ((and) #t)
              ((and test) test)
              ((and test1 test2 ...)
               (if test1 (and test2 ...) #t))))

     The last TEST-EXPRESSION is in tail context if the ‘and’ expression
     itself is.

 -- Syntax: or TEST-EXPRESSION …
     If there are no TEST-EXPRESSIONs, ‘#f’ is returned.  Otherwise, the
     TEST-EXPRESSIONs are evaluated from left to right until a
     TEST-EXPRESSION returns a true value VAL or the last
     TEST-EXPRESSION is reached.  In the former case, the ‘or’
     expression returns VAL without evaluating the remaining
     expressions.  In the latter case, the last expression is evaluated
     and its values are returned.

          (or (= 2 2) (> 2 1))           ⇒ #t
          (or (= 2 2) (< 2 1))           ⇒ #t
          (or #f #f #f)                  ⇒ #f
          (or '(b c) (/ 3 0))            ⇒ (b c)

     The ‘or’ keyword could be defined in terms of ‘if’ using
     ‘syntax-rules’ as follows:

          (define-syntax or
            (syntax-rules ()
              ((or) #f)
              ((or test) test)
              ((or test1 test2 ...)
               (let ((x test1))
                 (if x x (or test2 ...))))))

     The last TEST-EXPRESSION is in tail context if the ‘or’ expression
     itself is.

 -- Syntax: when TEST-EXPRESSION form...
     If TEST-EXPRESSION is true, evaluate each FORM in order, returning
     the value of the last one.

 -- Syntax: unless TEST-EXPRESSION form...
     If TEST-EXPRESSION is false, evaluate each FORM in order, returning
     the value of the last one.


File: kawa.info,  Node: Definitions,  Next: Local binding constructs,  Prev: Conditionals,  Up: Program structure

7.3 Definitions
===============

 -- Syntax: define name [‘::’ TYPE] value

   In addition to ‘define’ (which can take an optional type specifier),
Kawa has some extra definition forms.

 -- Syntax: define-private name [‘::’ TYPE] value
 -- Syntax: define-private (name formals) body
     Same as ‘define’, except that ‘name’ is not exported.

 -- Syntax: define-constant name [‘::’ TYPE] value
 -- Syntax: define-early-constant name [:: type] value
     Defines NAME to have the given VALUE.  The value is readonly, and
     you cannot assign to it.  (This is not fully enforced.)

     If ‘define-early-constant’ is used _or_ the VALUE is a compile-time
     constant, then the compiler will create a ‘final’ field with the
     given name and type, and evaluate VALUE in the module’s class
     initializer (if the definition is static) or constructor (if the
     definition is non-static), before other definitions and
     expressions.  Otherwise, the VALUE is evaluated in the module body
     where it appears.

     If the VALUE is a compile-time constant, then the definition
     defaults to being static.

 -- Syntax: define-variable name [init]
     If INIT is specified and NAME does not have a global variable
     binding, then INIT is evaluated, and NAME bound to the result.
     Otherwise, the value bound to NAME does not change.  (Note that
     INIT is not evaluated if NAME does have a global variable binding.)

     Also, declares to the compiler that NAME will be looked up in the
     dynamic environment.  This can be useful for shutting up warnings
     from ‘--warn-undefined-variable’.

     This is similar to the Common Lisp ‘defvar’ form.  However, the
     Kawa version is (currently) only allowed at module level.

   For ‘define-namespace’ and ‘define-private-namespace’ see *note
Namespaces::.


File: kawa.info,  Node: Local binding constructs,  Next: Lazy evaluation,  Prev: Definitions,  Up: Program structure

7.4 Local binding constructs
============================

The binding constructs ‘let’, ‘let*’, ‘letrec’, and ‘letrec*’ give
Scheme a block structure, like Algol 60.  The syntax of these four
constructs is identical, but they differ in the regions they establish
for their variable bindings.  In a ‘let’ expression, the initial values
are computed before any of the variables become bound; in a ‘let*’
expression, the bindings and evaluations are performed sequentially;
while in ‘letrec’ and ‘letrec*’ expressions, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.

 -- Syntax: let ‘((’variable [‘::’ TYPE] init‘)’ ...‘)’ BODY
     Declare new local variables with the given NAME, initial value
     INIT, and optional type specification TYPE.  The INITs are
     evaluated in the current environment (in left-to-right onder), the
     VARIABLEs are bound to fresh locations holding the results, the
     BODY is evaluated in the extended environment, and the values of
     the last expression of body are returned.  Each binding of a
     variable has BODY as its region.  If TYPE is specified, then after
     the expression INIT is evaluated, the result coerced to TYPE, and
     then assigned to the variable.  If TYPE is not specified, it
     defaults to ‘Object’.

          (let ((x 2) (y 3))
            (* x y)) ⇒ 6

          (let ((x 2) (y 3))
            (let ((x 7)
                  (z (+ x y)))
              (* z x)))   ⇒ 35

 -- Syntax: let* ‘((’variable [‘::’ TYPE] init‘)’ ...‘)’ BODY

     The ‘let*’ binding construct is similar to ‘let’, but the bindings
     are performed sequentially from left to right, and the region of a
     VARIABLE is that part of the ‘let*’ expression to the right of the
     binding.  Thus the second binding is done in an environment in
     which the first binding is visible, and so on.  The VARIABLEs need
     not be distinct.

          (let ((x 2) (y 3))
            (let* ((x 7)
                   (z (+ x y)))
              (* z x)))  ⇒ 70

 -- Syntax: letrec ‘((’variable [‘::’ TYPE] init‘)’ ...‘)’ BODY
 -- Syntax: letrec* ‘((’variable [‘::’ TYPE] init‘)’ ...‘)’ BODY
     The VARIABLEs are bound to fresh locations, each VARIABLE is
     assigned in left-to-right order to the result of the corresponding
     INIT, the BODY is evaluated in the resulting environment, and the
     values of the last expression in body are returned.  Despite the
     left-to-right evaluation and assignment order, each binding of a
     VARIABLE has the entire ‘letrec’ or ‘letrec*’ expression as its
     region, making it possible to define mutually recursive procedures.

     In Kawa ‘letrec’ is defined as the same as ‘letrec*’.  In standard
     Scheme the order of evaluation of the INITs is undefined, as is the
     order of assignments.  If the order matters, you should use
     ‘letrec*’.

     If it is not possible to evaluate each INIT without assigning or
     referring to the value of the corresponding VARIABLE or the
     variables that follow it , it is an error.
          (letrec ((even?
                    (lambda (n)
                      (if (zero? n)
                          #t
                          (odd? (- n 1)))))
                   (odd?
                    (lambda (n)
                      (if (zero? n)
                          #f
                          (even? (- n 1))))))
            (even? 88))
               ⇒ #t


File: kawa.info,  Node: Lazy evaluation,  Next: Threads,  Prev: Local binding constructs,  Up: Program structure

7.5 Lazy evaluation
===================

"Lazy evaluation" (or call-by-need) delays evaluating an expression
until it is actually needed; when it is evaluated, the result is saved
so repeated evaluation is not needed.  Lazy evaluation
(http://en.wikipedia.org/wiki/Lazy_evaluation) is a technique that can
make some algorithms easier to express compactly or much more
efficiently, or both.  It is the normal evaluation mechanism for strict
functional (side-effect-free) languages such as Haskell
(http://www.haskell.org).  However, automatic lazy evaluation is awkward
to combine with side-effects such as input-output.  It can also be
difficult to implement lazy evaluation efficiently, as it requires more
book-keeping.

   Kawa, like other Schemes, uses “eager evaluation” - an expression is
normally evaluated immediately, unless it is wrapped in a special form.
Standard Scheme has some basic building blocks for “manual” lazy
evaluation, using an explicit ‘delay’ operator to indicate that an
expression is to be evaluated lazily, yielding a "promise", and a
‘force’ function to force evaluation of a promise.  This functionality
is enhanced in SRFI 45 (http://srfi.schemers.org/srfi-45/srfi-45.html),
in R7RS-draft (based on SRFI 45), and SRFI 41
(http://srfi.schemers.org/srfi-41/srfi-41.html) (lazy lists aka
streams).

   Kawa makes lazy evaluation easier to use, by "implicit forcing": The
promise is automatically evaluated (forced) when used in a context that
requires a normal value, such as arithmetic needing a number.  Kawa
enhances lazy evaluation in other ways, including support for safe
multi-threaded programming.

7.5.1 Delayed evaluation
------------------------

 -- Syntax: delay EXPRESSION
     The ‘delay’ construct is used together with the procedure ‘force’
     to implement _lazy evaluation_ or _call by need_.

     The result of ‘(delay EXPRESSION)’ is a _promise_ which at some
     point in the future may be asked (by the ‘force’ procedure) to
     evaluate EXPRESSION, and deliver the resulting value.  The effect
     of EXPRESSION returning multiple values is unspecified.

 -- Syntax: delay-force EXPRESSION
 -- Syntax: lazy EXPRESSION
     The ‘delay-force’ construct is similar to ‘delay’, but it is
     expected that its argument evaluates to a promise.  (Kawa treats a
     non-promise value as if it were a forced promise.)  The returned
     promise, when forced, will evaluate to whatever the original
     promise would have evaluated to if it had been forced.

     The expression ‘(delay-force EXPRESSION)’ is conceptually similar
     to ‘(delay (force EXPRESSION))’, with the difference that forcing
     the result of ‘delay-force’ will in effect result in a tail call to
     ‘(force EXPRESSION)’, while forcing the result of ‘(delay (force
     EXPRESSION))’ might not.  Thus iterative lazy algorithms that might
     result in a long series of chains of ‘delay’ and ‘force’ can be
     rewritten using delay-force to prevent consuming unbounded space
     during evaluation.

     Using ‘delay-force’ or ‘lazy’ is equivalent.  The name
     ‘delay-force’ is from R7RS; the name ‘lazy’ is from the older
     SRFI-45.

 -- Procedure: eager obj
     Returns a promise that when forced will return OBJ.  It is similar
     to ‘delay’, but does not delay its argument; it is a procedure
     rather than syntax.

     The Kawa implementation just returns OBJ as-is.  This is because
     Kawa treats as equivalent a value and forced promise evaluating to
     the value.

 -- Procedure: force promise
     The ‘force’ procedure forces the value of PROMISE.  As a Kawa
     extension, if the PROMISE is not a promise (a value that does not
     implement ‘gnu.mapping.Lazy’) then the argument is returned
     unchanged.  If no value has been computed for the promise, then a
     value is computed and returned.  The value of the promise is cached
     (or “memoized”) so that if it is forced a second time, the
     previously computed value is returned.
          (force (delay (+ 1 2)))                ⇒  3

          (let ((p (delay (+ 1 2))))
            (list (force p) (force p)))          ⇒  (3 3)

          (define integers
            (letrec ((next
                      (lambda (n)
                        (cons n (delay (next (+ n 1)))))))
              (next 0)))
          (define head
            (lambda (stream) (car (force stream))))
          (define tail
            (lambda (stream) (cdr (force stream))))

          (head (tail (tail integers)))          ⇒  2

     The following example is a mechanical transformation of a lazy
     stream-filtering algorithm into Scheme.  Each call to a constructor
     is wrapped in ‘delay’, and each argument passed to a deconstructor
     is wrapped in ‘force’.  The use of ‘(lazy ...)’ instead of ‘(delay
     (force ...))’ around the body of the procedure ensures that an
     ever-growing sequence of pending promises does not exhaust the
     heap.

          (define (stream-filter p? s)
            (lazy
             (if (null? (force s))
                 (delay ’())
                 (let ((h (car (force s)))
                       (t (cdr (force s))))
                   (if (p? h)
                       (delay (cons h (stream-filter p? t)))
                       (stream-filter p? t))))))

          (head (tail (tail (stream-filter odd? integers))))
              ⇒ 5

 -- Procedure: force* promise
     Does ‘force’ as many times as necessary to produce a non-promise.
     (A non-promise is a value that does not implement
     ‘gnu.mapping.Lazy’, or if it does implement ‘gnu.mapping.Lazy’ then
     forcing the value using the ‘getValue’ method yields the receiver.)

     The ‘force*’ function is a Kawa extension.  Kawa will add implicit
     calls to ‘force*’ in most contexts that need it, but you can also
     call it explicitly.

   The following examples are not intended to illustrate good
programming style, as ‘delay’, ‘lazy’, and ‘force’ are mainly intended
for programs written in the functional style.  However, they do
illustrate the property that only one value is computed for a promise,
no matter how many times it is forced.

     (define count 0)
     (define p
       (delay (begin (set! count (+ count 1))
                     (if (> count x)
                         count
                         (force p)))))
     (define x 5)
     p                  ⇒ _a promise_
     (force p)          ⇒ 6
     p                  ⇒ _a promise, still_
     (begin (set! x 10)
            (force p))  ⇒ 6

7.5.2 Implicit forcing
----------------------

If you pass a promise as an argument to a function like ‘sqrt’ if must
first be forced to a number.  In general, Kawa does this automatically
(implicitly) as needed, depending on the context.  For example:
     (+ (delay (* 3 7)) 13)   ⇒ 34

   Other functions, like ‘cons’ have no problems with promises, and
automatic forcing would be undesirable.

   Generally, implicit forcing happens for arguments that require a
specific type, and does not happen for arguments that work on _any_ type
(or ‘Object’).

   Implicit forcing happens for:
   • arguments to arithmetic functions;
   • the sequence and the index in indexing operations, like
     ‘string-ref’;
   • the operands to ‘eqv?’ and ‘equal?’ are forced, though the operands
     to ‘eq?’ are not;
   • port operands to port functions;
   • the value to be emitted by a ‘display’ but _not_ the value to be
     emitted by a ‘write’;
   • the function in an application.

   Type membership tests, such as the ‘instance?’ operation, generally
do not force their values.

   The exact behavior for when implicit forcing is a work-in-progress:
There are certainly places where implicit forcing doesn’t happen while
it should; there are also likely to be places where implicit forcing
happens while it is undesirable.

   Most Scheme implementations are such that a forced promise behaves
differently from its forced value, but some Scheme implementions are
such that there is no means by which a promise can be operationally
distingished from its forced value.  Kawa is a hybrid: Kawa tries to
minimize the difference between a forced promise and its forced value,
and may freely optimize and replace a forced promise with its value.

7.5.3 Blank promises
--------------------

A "blank promise" is a promise that doesn’t (yet) have a value _or_ a
rule for calculating the value.  Forcing a blank promise will wait
forever, until some other thread makes the promise non-blank.

   Blank promises are useful as a synchronization mechanism - you can
use it to safely pass data from one thread (the producer) to another
thread (the consumer).  Note that you can only pass one value for a
given promise: To pass multiple values, you need multiple promises.

     (define p (promise))
     (future ;; Consumer thread
       (begin
         (do-stuff)
         (define v (force promise)) ; waits until promise-set-value!
         (do-stuff-with v)))
     ;; Producer thread
     ... do stuff ...
     (promise-set-value! p (calculate-value))

 -- Constructor: promise
     Calling ‘promise’ as a zero-argument constructor creates a new
     blank promise.

     This calls the constructor for ‘gnu.mapping.Promise’.  You can also
     create a non-blank promise, by setting one of the ‘value’, ‘alias’,
     ‘thunk’, or ‘exception’ properties.  Doing so is equivalent to
     calling ‘promise-set-value!’, ‘promise-set-alias!’,
     ‘promise-set-thunk!’, or ‘promise-set-exception!’ on the resulting
     promise.  For example: ‘(delay exp)’ is equivalent to:
          (promise thunk: (lambda() exp))

   The following four procedures require that their first arguments be
blank promises.  When the procedure returns, the promise is no longer
blank, and cannot be changed.  This is because a promise is conceptually
placeholder for a single “not-yet-known” value; it is not a location
that can be assigned multiple times.  The former enables clean and safe
(“declarative") use of multiple threads; the latter is much trickier.

 -- Procedure: promise-set-value! promise value
     Sets the value of the PROMISE to VALUE, which makes the PROMISE
     forced.

 -- Procedure: promise-set-exception! promise exception
     Associate EXCEPTION with the PROMISE.  When the PROMISE is forced
     the EXCEPTION gets thrown.

 -- Procedure: promise-set-alias! promise other
     Bind the PROMISE to be an alias of OTHER.  Forcing PROMISE will
     cause OTHER to be forced.

 -- Procedure: promise-set-thunk! promise thunk
     Associate THUNK (a zero-argument procedure) with the PROMISE.  The
     first time the PROMISE is forced will causes the THUNK to be
     called, with the result (a value or an exception) saved for future
     calls.

 -- Procedure: make-promise obj
     The ‘make-promise’ procedure returns a promise which, when forced,
     will return OBJ.  It is similar to ‘delay’, but does not delay its
     argument: it is a procedure rather than syntax.  If OBJ is already
     a promise, it is returned.

     Because of Kawa’s implicit forcing, there is seldom a need to use
     ‘make-promise’, except for portability.

7.5.4 Lazy and eager types
--------------------------

 -- Type: promise[T]
     This parameterized type is the type of promises that evaluate to an
     value of type ‘T’.  It is equivalent to the Java interface
     ‘gnu.mapping.Lazy<T>’.  The implementation class for promises is
     usually ‘gnu.mapping.Promise’, though there are other classes that
     implement ‘Lazy’, most notably ‘gnu.mapping.Future’, used for
     futures, which are promises evaluated in a separate thread.

   Note the distinction between the types ‘integer’ (the type of actual
(eager) integer values), and ‘promise[integer]’ (the type of (lazy)
promises that evaluate to integer).  The two are compatible: if a
‘promise[integer]’ value is provided in a context requiring an ‘integer’
then it is automatically evaluated (forced).  If an ‘integer’ value is
provided in context requiring a ‘promise[integer]’, that conversion is
basically a no-op (though the compiler may wrap the ‘integer’ in a
pre-forced promise).

   If a fully-lazy language there would be no distinction, or at least
the promise type would be the default.  However, Kawa is mostly-eager
language, so the eager type is the default.  This makes efficient
code-generation easier: If an expression has an eager type, then the
compiler can generate code that works on its values directly, without
having to check for laziness.


File: kawa.info,  Node: Threads,  Next: Exceptions,  Prev: Lazy evaluation,  Up: Program structure

7.6 Threads
===========

There is a very preliminary interface to create parallel threads.  The
interface is similar to the standard ‘delay’/‘force’, where a thread is
basically the same as a promise, except that evaluation may be in
parallel.

 -- Syntax: future expression
     Creates a new thread that evaluates EXPRESSION.

     (The result extends ‘java.lang.Thread’ and implements
     ‘gnu.mapping.Lazy’.)

 -- Procedure: force thread
     The standard ‘force’ function has generalized to also work on
     threads.  If waits for the thread’s EXPRESSION to finish executing,
     and returns the result.

 -- Procedure: runnable function
     Creates a new ‘Runnable’ instance from a function.  Useful for
     passing to Java code that expects a ‘Runnable’.  You can get the
     result (a value or a thrown exception) using the ‘getResult’
     method.

 -- Syntax: synchronized object form ...
     Synchronize on the given OBJECT.  (This means getting an exclusive
     lock on the object, by acquiring its "monitor".)  Then execute the
     FORMs while holding the lock.  When the FORMs finish (normally or
     abnormally by throwing an exception), the lock is released.
     Returns the result of the last FORM.  Equivalent to the Java
     ‘synchronized’ statement, except that it may return a result.


File: kawa.info,  Node: Exceptions,  Prev: Threads,  Up: Program structure

7.7 Exception handling
======================

An "exception" is an object used to signal an error or other exceptional
situation.  The program or run-time system can "throw" the exception
when an error is discovered.  An exception handler is a program
construct that registers an action to handle exceptions when the handler
is active.

   If an exception is thrown and not handled then the
read-eval-print-loop will print a stack trace, and bring you back to the
top level prompt.  When not running interactively, an unhandled
exception will normally cause Kawa to be exited.

   In the Scheme exception model (as of R6RS and R7RS) exception
handlers are one-argument procedures that determine the action the
program takes when an exceptional situation is signaled.  The system
implicitly maintains a current exception handler in the dynamic
environment.  The program raises an exception by invoking the current
exception handler, passing it an object encapsulating information about
the exception.  Any procedure accepting one argument can serve as an
exception handler and any object can be used to represent an exception.

   The Scheme exception model is implemented on top of the Java VM’s
native exception model where the only objects that can be thrown are
instances of ‘java.lang.Throwable’.  Kawa also provides direct access to
this native model, as well as older Scheme exception models.

 -- Procedure: with-exception-handler handler thunk
     It is an error if HANDLER does not accept one argument.  It is also
     an error if THUNK does not accept zero arguments.  The
     ‘with-exception-handler’ procedure returns the results of invoking
     THUNK.  The HANDLER is installed as the current exception handler
     in the dynamic environment used for the invocation of THUNK.

          (call-with-current-continuation
            (lambda (k)
             (with-exception-handler
              (lambda (x)
               (display "condition: ")
               (write x)
               (newline)
               (k 'exception))
              (lambda ()
               (+ 1 (raise ’an-error))))))
                 ⇒ exception
                 and prints condition: an-error

          (with-exception-handler
           (lambda (x)
            (display "something went wrong\n"))
           (lambda ()
            (+ 1 (raise ’an-error))))
              prints something went wrong

     After printing, the second example then raises another exception.

     _Performance note:_ The THUNK is inlined if it is a lambda
     expression.  However, the HANDLER cannot be inlined even if it is a
     lambda expression, because it could be called by
     ‘raise-continuable’.  Using the ‘guard’ form is usually more
     efficient.

 -- Procedure: raise obj
     Raises an exception by invoking the current exception handler on
     OBJ.  The handler is called with the same dynamic environment as
     that of the call to raise, except that the current exception
     handler is the one that was in place when the handler being called
     was installed.  If the handler returns, then OBJ is re-raised in
     the same dynamic environment as the handler.

     If OBJ is an instance of ‘java.lang.Throwable’, then ‘raise’ has
     the same effect as ‘primitive-throw’.

 -- Procedure: raise-continuable obj
     Raises an exception by invoking the current exception handler on
     OBJ.  The handler is called with the same dynamic environment as
     the call to ‘raise-continuable’, except that: (1) the current
     exception handler is the one that was in place when the handler
     being called was installed, and (2) if the handler being called
     returns, then it will again become the current exception handler.
     If the handler returns, the values it returns become the values
     returned by the call to ‘raise-continuable’.

          (with-exception-handler
            (lambda (con)
              (cond
                ((string? con)
                 (display con))
                (else
                 (display "a warning has been issued")))
              42)
            (lambda ()
              (+ (raise-continuable "should be a number")
                 23)))
                prints: should be a number
                ⇒ 65

 -- Syntax: guard VARIABLE COND-CLAUSE^+ BODY
     The BODY is evaluated with an exception handler that binds the
     raised object to VARIABLE and, within the scope of that binding,
     evaluates the clauses as if they were the clauses of a ‘cond’
     expression.  That implicit ‘cond’ expression is evaluated with the
     continuation and dynamic environment of the ‘guard’ expression.  If
     every cond-clause’s test evaluates to ‘#f’ and there is no ‘else’
     clause, then ‘raise-continuable’ is invoked on the raised object
     within the dynamic environment of the original call to ‘raise’ or
     ‘raise-continuable’, except that the current exception handler is
     that of the ‘guard’ expression.

          (guard (condition
                   ((assq 'a condition) => cdr)
                   ((assq 'b condition)))
            (raise (list (cons 'a 42))))
                ⇒ 42

          (guard (condition
                   ((assq 'a condition) => cdr)
                   ((assq 'b condition)))
            (raise (list (cons 'b 23))))
                ⇒ (b . 23)

     _Performance note:_ Using ‘guard’ is moderately efficient: there is
     some overhead compared to using native exception handling, but both
     the BODY and the handlers in the COND-CLAUSE are inlined.

 -- Procedure: dynamic-wind in-guard thunk out-guard
     All three arguments must be 0-argument procedures.  First calls
     IN-GUARD, then THUNK, then OUT-GUARD.  The result of the expression
     is that of THUNK.  If THUNK is exited abnormally (by throwing an
     exception or invoking a continuation), OUT-GUARD is called.

     If the continuation of the dynamic-wind is re-entered (which is not
     yet possible in Kawa), the IN-GUARD is called again.

     This function was added in R5RS.

 -- Procedure: read-error? obj
     Returns #t if OBJ is an object raised by the ‘read’ procedure.
     (That is if OBJ is a ‘gnu.text.SyntaxException’.)

 -- Procedure: file-error? obj
     Returns #t if OBJ is an object raised by inability to open an input
     or output port on a file.  (This includes
     ‘java.io.FileNotFoundException’ as well as certain other
     exceptions.)

7.7.1 Simple error objects
--------------------------

 -- Procedure: error message obj ...
     Raises an exception as if by calling ‘raise’ on a newly allocated
     "simple error object", which encapsulates the information provided
     by MESSAGE (which should a string), as well as any OBJ arguments,
     known as the irritants.

     The string representation of a simple error object is as if calling
     ‘(format "#<ERROR ~a~{ ~w~}>" MESSAGE IRRITANTS)’.  (That is the
     MESSAGE is formatted as if with ‘display’ while each irritant OBJ
     is formatted as if with ‘write’.)

     This procedure is part of SRFI-23, and R7RS. It differs from (and
     is incompatible with) R6RS’s ‘error’ procedure.

 -- Procedure: error-object? obj
     Returns ‘#t’ if OBJ is a simple error object.  Specifically, that
     OBJ is an instance of ‘kawa.lang.NamedException’.  Otherwise, it
     returns ‘#f’.

 -- Procedure: error-object-message error-object
     Returns the message encapsulated by error-object, which must be a
     simple error object.

 -- Procedure: error-object-irritants error-object
     Returns a list of the irritants (other arguments) encapsulated by
     error-object, which must be a simple error object.

7.7.2 Named exceptions
----------------------

These functions associate a symbol with exceptions and handlers: A
handler catches an exception if the symbol matches.

 -- Procedure: catch key thunk handler
     Invoke THUNK in the dynamic context of HANDLER for exceptions
     matching KEY.  If thunk throws to the symbol KEY, then HANDLER is
     invoked this way:

          (handler key args ...)

     KEY may be a symbol.  The THUNK takes no arguments.  If THUNK
     returns normally, that is the return value of ‘catch’.

     Handler is invoked outside the scope of its own ‘catch’.  If
     HANDLER again throws to the same key, a new handler from further up
     the call chain is invoked.

     If the key is ‘#t’, then a throw to _any_ symbol will match this
     call to ‘catch’.

 -- procedure: throw key arg ...
     Invoke the catch form matching KEY, passing the ARGs to the current
     HANDLER.

     If the key is a symbol it will match catches of the same symbol or
     of ‘#t’.

     If there is no handler at all, an error is signaled.

7.7.3 Native exception handling
-------------------------------

 -- Procedure: primitive-throw exception
     Throws the EXCEPTION, which must be an instance of a sub-class of
     ‘java.lang.Throwable’.

 -- Syntax: try-finally body handler
     Evaluate BODY, and return its result.  However, before it returns,
     evaluate HANDLER.  Even if BODY returns abnormally (by throwing an
     exception), HANDLER is evaluated.

     (This is implemented just like Java’s ‘try’-‘finally’.  However,
     the current implementation does not duplicate the HANDLER.)

 -- Syntax: try-catch body handler ...
     Evaluate BODY, in the context of the given HANDLER specifications.
     Each HANDLER has the form:
          VAR TYPE EXP ...
     If an exception is thrown in BODY, the first HANDLER is selected
     such that the thrown exception is an instance of the HANDLER’s
     TYPE.  If no HANDLER is selected, the exception is propagated
     through the dynamic execution context until a matching HANDLER is
     found.  (If no matching HANDLER is found, then an error message is
     printed, and the computation terminated.)

     Once a HANDLER is selected, the VAR is bound to the thrown
     exception, and the EXP in the HANDLER are executed.  The result of
     the ‘try-catch’ is the result of BODY if no exception is thrown, or
     the value of the last EXP in the selected HANDLER if an exception
     is thrown.

     (This is implemented just like Java’s ‘try’-‘catch’.)


File: kawa.info,  Node: Multiple values,  Next: Symbols and namespaces,  Prev: Program structure,  Up: Top

8 Multiple values
*****************

The multiple-value feature was added in R5RS.

 -- Procedure: values object ...
     Delivers all of its arguments to its continuation.

 -- Procedure: call-with-values thunk receiver
     Call its THUNK argument with a continuation that, when passed some
     values, calls the RECEIVER procedure with those values as
     arguments.

 -- Syntax: define-values FORMALS EXPRESSION
     It is an error if a variable appears more than once in the set of
     FORMALS.

     The EXPRESSION is evaluated, and the FORMALS are bound to the
     return values in the same way that the FORMALS in a ‘lambda’
     expression are matched to the arguments in a procedure call.

          (define-values (x y) (integer-sqrt 17))
          (list x y)    ⇒ (4 1)
          (let ()
            (define-values (x y) (values 1 2))
            (+ x y))
                        ⇒  3

 -- Syntax: let-values ‘((’FORMALS EXPRESSION‘)’ ...‘)’ BODY
     Each FORMALS should be a formal arguments list as for a ‘lambda’.

     The EXPRESSIONs are evaluated in the current environment, the
     variables of the FORMALS are bound to fresh locations, the return
     values of the EXPRESSIONs are stored in the variables, the BODY is
     evaluated in the extended environment, and the values of the last
     expression of BODY are returned.  The BODY is a "tail body", cf
     section 3.5 of the R5RS.

     The matching of each FORMALS to values is as for the matching of
     FORMALS to arguments in a ‘lambda’ expression, and it is an error
     for an EXPRESSION to return a number of values that does not match
     its corresponding FORMALS.
          (let-values (((a b . c) (values 1 2 3 4)))
            (list a b c))            ⇒ (1 2 (3 4))

          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (let-values (((a b) (values x y))
                         ((x y) (values a b)))
              (list a b x y)))       ⇒ (x y a b)

 -- Syntax: let*-values ‘((’FORMALS EXPRESSION‘)’ ...‘)’ BODY

     Each FORMALS should be a formal arguments list as for a ‘lambda’
     expression.

     ‘let*-values’ is similar to ‘let-values’, but the bindings are
     performed sequentially from left to right, and the region of a
     binding indicated by (FORMALS EXPRESSION) is that part of the
     ‘let*-values’ expression to the right of the binding.  Thus the
     second binding is done in an environment in which the first binding
     is visible, and so on.
          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (let*-values (((a b) (values x y))
                          ((x y) (values a b)))
              (list a b x y)))       ⇒ (x y x y)

 -- Syntax: receive FORMALS EXPRESSION BODY
     This convenience form (from SRFI-8
     (http://srfi.schemers.org/srfi-8/srfi-8.html)) is equivalent to:
          (let-values ((FORMALS EXPRESSION)) BODY)
     For example:
          (receive a (values 1 2 3 4)
            (reverse a)) ⇒ (4 3 2 1)

          (receive (a b . c) (values 1 2 3 4)
            (list a b c))            ⇒ (1 2 (3 4))

          (let ((a 'a) (b 'b) (x 'x) (y 'y))
            (receive (a b) (values x y)
              (receive (x y) (values a b)
                (list a b x y))))    ⇒ (x y x y)

 -- Procedure: values-append arg1 ...
     The values resulting from evaluating each argument are appended
     together.


File: kawa.info,  Node: Symbols and namespaces,  Next: Procedures,  Prev: Multiple values,  Up: Top

9 Symbols and namespaces
************************

An identifier is a name that appears in a program.

   A symbol is an object representing a string that cannot be modified.
This string is called the symbol’s name.  Unlike strings, two symbols
whose names are spelled the same way are indistinguishable.  A symbol is
immutable (unmodifiable) and normally viewed as atomic.  Symbols are
useful for many applications; for instance, they may be used the way
enumerated values are used in other languages.

   In addition to the simple symbols or standard Scheme, Kawa also has
compound (two-part) symbols.

* Menu:

* Simple symbols::
* Namespaces::
* Keywords::
* Special named constants::


File: kawa.info,  Node: Simple symbols,  Next: Namespaces,  Up: Symbols and namespaces

9.1 Simple symbols
==================

Simple symbols have no properties other than their name, an immutable
string.  They have the useful property that two simple symbols are
identical (in the sense of ‘eq?’, ‘eqv?’ and ‘equal?’) if and only if
their names are spelled the same way.  A symbol literal is formed using
‘quote’.

 -- Procedure: symbol? OBJ
     Return ‘#t’ if OBJ is a symbol, ‘#f’ otherwise.

          (symbol? 'foo)          ⇒ #t
          (symbol? (car '(a b)))  ⇒ #t
          (symbol? "bar")         ⇒ #f
          (symbol? 'nil)          ⇒ #t
          (symbol? '())           ⇒ #f
          (symbol? #f)            ⇒ #f

 -- Procedure: symbol->string SYMBOL
     Return the name of SYMBOL as an immutable string.

          (symbol->string 'flying-fish)                   ⇒  "flying-fish"
          (symbol->string 'Martin)                        ⇒  "Martin"
          (symbol->string (string->symbol "Malvina"))     ⇒  "Malvina"

 -- Procedure: string->symbol STRING
     Return the symbol whose name is STRING.

          (eq? 'mISSISSIppi 'mississippi)
          ⇒ #f

          (string->symbol "mISSISSIppi")
          ⇒ the symbol with name "mISSISSIppi"

          (eq? 'bitBlt (string->symbol "bitBlt"))
          ⇒ #t

          (eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
          ⇒ #t

          (string=? "K. Harper, M.D."
                    (symbol->string (string->symbol "K. Harper, M.D.")))
          ⇒ #t


File: kawa.info,  Node: Namespaces,  Next: Keywords,  Prev: Simple symbols,  Up: Symbols and namespaces

9.2 Namespaces and compound symbols
===================================

Different applications may want to use the same symbol to mean different
things.  To avoid such "name clashes" we can use "compound symbols",
which have two string parts: a "local name" and a "namespace URI". The
namespace-uri can be any string, but it is recommended that it have the
form of an absolute URI
(http://en.wikipedia.org/wiki/Uniform_Resource_Identifier).  It would be
too verbose to write the full URI all the time, so one usually uses a
"namespace prefix" (namespace alias) as a short local alias to refer to
a namespace URI.

   Compound symbols are usually written using the infix colon operator:
     PREFIX:LOCAL-NAME
   where PREFIX is is namespace alias bound to some (lexically-known)
namespace URI.

   Compound symbols are used for namespace-aware XML processing.

9.2.1 Namespace objects
-----------------------

A "namespace" is a mapping from strings to symbols.  The string is the
local-name of resulting symbol.  A namespace is similar to a Common Lisp
"package".

   A namespace has a namespace-uri, which a string; it recommended that
it have the form of an absolute URI. A namespace may optionally have a
prefix, which is a string used when printing out symbols belonging to
the namespace.  (If you want for “equivalent symbols” (i.e.  those that
have the same local-name and same uri) to be the identical symbol
object, then you should use namespaces whose prefix is the empty
string.)

 -- Constructor: namespace name [prefix]
     Return a namespace with the given NAME and PREFIX.  If no such
     namespace exists, create it.  The NAMESPACE-NAME is commonly a URI,
     especially when working with XML, in which case it is called a
     NAMESPACE-URI.  However, any non-empty string is allowed.  The
     prefix can be a string or a simple symbol.  (If a symbol is used,
     then the symbol’s local-name is used.)  The default for PREFIX is
     the empty string.  Multiple calls with the same arguments will
     yield the same namespace object.

   The reader macro ‘#,namespace’ is equivalent to the ‘namespace’
function, but it is invoked at read-time:
     #,(namespace "http://www.w3.org/1999/XSL/Transform" xsl)
     (eq? #,(namespace "foo") (namespace "foo")) ⇒ #t

   The form ‘(,#namespace "" "")’ returns the default "empty namespace",
which is used for simple symbols.

 -- Procedure: namespace-uri namespace
     Return the namespace-uri of the argument NAMESPACE, as a string.

 -- Procedure: namespace-prefix namespace
     Return the namespace prefix of the argument NAMESPACE, as a string.

9.2.2 Compound symbols
----------------------

A compound symbol is one that belongs to a namespace other than the
default empty namespace, and (normally) has a non-empty namespace uri.
(It is possible for a symbol to belong to a non-default namespace and
have an empty namespace uri, but that is not recommended.)

 -- Constructor: symbol local-name namespace-spec
 -- Constructor: symbol local-name [uri [prefix]]
     Construct a symbol with the given LOCAL-NAME and namespace.  If
     NAMESPACE-SPEC is a namespace object, then find (or if needed
     construct) a symbol with the given LOCAL-NAME belonging to the
     namespace.  Multiple calls to ‘symbol’ with the same namespace and
     LOCAL-NAME will yield the same symbol object.

     If uri is a string (optionally followed by a prefix), then:
          (symbol lname uri [prefix])
     is equivalent to:
          (symbol lname (namespace uri [prefix]))

     Using ‘#t’ for the NAMESPACE-SPEC is equivalent to using the empty
     namespace ‘#,(namespace "")’.

     Using ‘#!null’ or ‘#f’ for the NAMESPACE-SPEC creates an UNINTERNED
     symbol, which does not belong to any namespace.

 -- Procedure: symbol-local-name symbol
     Return the local name of the argument symbol, as an immutable
     string.  (The string is interned, except in the case of an
     uninterned symbol.)

 -- Procedure: symbol-prefix symbol
     Return the prefix of the argument symbol, as an immutable (and
     interned) string.

 -- Procedure: symbol-namespace-uri symbol
     Return the namespace uri of the argument symbol, as an immutable
     (and interned) string.

 -- Procedure: symbol-namespace symbol
     Return the namespace object (if any) of the argument symbol.
     Returns ‘#!null’ if the symbol is uninterned.

 -- Procedure: symbol=? SYMBOL1 SYMBOL2 SYMBOL3 …
     Return ‘#t’ if the symbols are equivalent as symbols, i.e., if
     their local-names and namespace-uris are the same.  They may have
     different values of ‘symbol-prefix’ and ‘symbol-namespace’.  If a
     symbol is uninterned (or is ‘#!null’) then ‘symbol=?’ returns the
     same result as ‘eq?’.

   Two symbols are ‘equal?’ or ‘eqv?’ if they’re ‘symbol=?’.

9.2.3 Namespace aliases
-----------------------

A namespace is usually referenced using a shorter "namespace alias",
which is is a lexical definition that binds a namespace prefix to a
namespace object (and thus a namespace uri).  This allows using compound
symbols as identifiers in Scheme programs.

 -- Syntax: define-namespace name namespace-name
     Defines NAME as a "namespace prefix" - a lexically scoped
     "nickname" for the namespace whose full name is NAMESPACE-NAME,
     which should be a non-empty string literal.  It is customary for
     the string have syntactic form of an absolute URI
     (http://en.wikipedia.org/wiki/Uniform_Resource_Identifier), but any
     non-empty string is acceptable and is used without further
     interpretation.

     Any symbols in the scope of this definitions that contain a colon,
     and where the part before the colon matches the NAME will be
     treated as being in the package/namespace whose global unique name
     is the NAMESPACE-NAME.

     Has mostly the same effect as:
          (define-constant NAME #,(namespace NAMESPACE-NAME)

     However, using ‘define-namespace’ (rather than ‘define-constant’)
     is recommended if you want to use compound symbols as names of
     variables, especially local variables, or if you want to quote
     compound symbols.

     Note that the prefix is only visible lexically: it is not part of
     the namespace, or thus indirectly the symbols, and so is not
     available when printing the symbol.  You might consider using
     ‘define-xml-namespace’ as an alternative.

     A namespace is similar to a Common Lisp package, and the
     NAMESPACE-NAME is like the name of the package.  However, a
     namespace alias belongs to the lexical scope, while a Common Lisp
     package nickname is global and belongs to the package itself.

     If the namespace-name starts with the string ‘"class:"’, then the
     NAME can be used for invoking Java methods (*note Method
     operations::) and accessing fields (*note Field operations::).

     You can use a namespace as an abbreviation or renaming of a class
     name, but as a matter of style ‘define-alias’ is preferred.

 -- Syntax: define-private-namespace name namespace-name
     Same as ‘define-namespace’, but the prefix NAME is local to the
     current module.

   For example you might have a set of a geometry definitions defined
under the namespace-uri ‘"http://foo.org/lib/geometry"’:

     (define-namespace geom "http://foo.org/lib/geometry")
     (define (geom:translate x y)
       (java.awt.geom.AffineTransform:getTranslateInstance x y))
     (define geom:zero (geom:translate 0 0))
     geom:zero
       ⇒ AffineTransform[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]

   You could have some other definitions for complex math:
     (define-namespace complex "http://foo.org/lib/math/complex")
     (define complex:zero +0+0i)

   You can use a namespace-value directly in a compound name:
     (namespace "http://foo.org/lib/geometry"):zero
       ⇒ AffineTransform[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]

   The variation ‘define-xml-namespace’ is used for *note Creating XML
nodes::.

 -- Syntax: define-xml-namespace prefix "namespace-uri"
     Defines a namespace with prefix PREFIX and URI NAMESPACE-URI.  This
     is similar to ‘define-namespace’ but with two important
     differences:
        • Every symbol in the namespace automatically maps to an
          element-constructor-type, as with the ‘html’ namespace.
        • The PREFIX is a component of the namespace object, and hence
          indirectly of any symbols belongining to the namespace.

     Thus the definition is roughly equivalent to:
          (define-constant NAME #,(namespace NAMESPACE-NAME NAME)
     along with an infinite set of definitions, for every possible TAG:
          (define (name:TAG . rest) (apply make-element 'name:TAG rest))

     $ kawa --output-format xml
     #|kawa:1|# (define-xml-namespace na "Namespace1")
     #|kawa:2|# (define-xml-namespace nb "Namespace1")
     #|kawa:3|# (define xa (na:em "Info"))
     #|kawa:4|# xa
     <na:em xmlns:na="Namespace1">Info</na:em>
     #|kawa:5|# (define xb (nb:em "Info"))
     #|kawa:6|# xa
     <nb:em xmlns:nb="Namespace1">Info</nb:em>

   Note that the prefix is part of the qualified name (it is actually
part of the namespace object), and it is used when printing the tag.
Two qualified names (symbols) that have the same local-name and the same
namespace-name are considered equal, even if they have different prefix.
You can think of the prefix as annotation used when printing, but not
otherwise part of the “meaning” of a compound symbol.  They are the same
object if they also have the same prefix.  This is an important
different from traditional Lisp/Scheme symbols, but it is how XML QNames
work.
     #|kawa:7|# (instance? xb na:em)
     true
     #|kawa:8|# (eq? 'na:em 'nb:em)
     false
     #|kawa:9|# (equal? 'na:em 'nb:em)
     true
     #|kawa:10|# (eqv? 'na:em 'nb:em)
     true
   (Note that ‘#t’ is printed as ‘true’ when using XML formatting.)

   The predefined ‘html’ prefix could be defined thus:
     (define-xml-namespace html "http://www.w3.org/1999/xhtml")


File: kawa.info,  Node: Keywords,  Next: Special named constants,  Prev: Namespaces,  Up: Symbols and namespaces

9.3 Keywords
============

Keywords are similar to symbols.  They are used mainly for specifying
keyword arguments.

   Historically keywords have been self-evaluating (you did not need to
quote them).  This is changing: you should quote a keyword if you want a
literal keyword value, and not quote it if it is used with a keyword
argument.  (This change is a work-in-progress.)

     KEYWORD ::= IDENTIFIER‘:’

   A keyword is a single token; therefore no whitespace is allowed
between the IDENTIFIER and the colon (which is not considered part of
the name of the keyword).

 -- Procedure: keyword? obj
     Return ‘#t’ if OBJ is a keyword, and otherwise returns ‘#f’.

 -- Procedure: keyword->string keyword
     Returns the name of KEYWORD as a string.  The name does not include
     the final ‘#\:’.

 -- Procedure: string->keyword string
     Returns the keyword whose name is STRING.  (The STRING does not
     include a final ‘#\:’.)


File: kawa.info,  Node: Special named constants,  Prev: Keywords,  Up: Symbols and namespaces

9.4 Special named constants
===========================

 -- Constant: #!optional
     Special self-evaluating literal used in lambda parameter lists
     before optional parameters.

 -- Constant: #!rest
     Special self-evaluating literal used in lambda parameter lists
     before the rest parameter.

 -- Constant: #!key
     Special self-evaluating literal used in lambda parameter lists
     before keyword parameters.

 -- Constant: #!eof
     The end-of-file object.

     Note that if the Scheme reader sees this literal at top-level, it
     is returned literally.  This is indistinguishable from coming to
     the end of the input file.  If you do not want to end reading, but
     want the actual value of ‘#!eof’, you should quote it.

 -- Constant: #!void
     The void value.  Same as ‘(values)’.  If this is the value of an
     expression in a read-eval-print loop, nothing is printed.

 -- Constant: #!null
     The Java ‘null’ value.  This is not really a Scheme value, but is
     useful when interfacing to low-level Java code.


File: kawa.info,  Node: Procedures,  Next: Numbers,  Prev: Symbols and namespaces,  Up: Top

10 Procedures
*************

 -- Procedure: apply proc [arg1 ...] args
     ARGS must be a sequence (list, vector, or string) or a primitive
     Java array.  (This is an extension over standard Scheme, which
     requires that ARGS be a list.)  Calls the PROC (which must be a
     procedure), using as arguments the ARG1...  values plus all the
     elements of ARGS.

 -- Syntax: constant-fold proc arg1 ...
     Same as ‘(PROC ARG1 ...)’, unless PROC and all the following
     arguments are compile-time constants.  (That is: They are either
     constant, or symbols that have a global binding and no lexical
     binding.)  In that case, PROC is applied to the arguments at
     compile-time, and the result replaces the ‘constant-fold’ form.  If
     the application raises an exception, a compile-time error is
     reported.  For example:
          (constant-fold vector 'a 'b 'c)
     is equivalent to ‘(quote #(a b c))’, assuming ‘vector’ has not been
     re-bound.

* Menu:

* Procedure properties::
* Generic procedures::
* Extended formals::


File: kawa.info,  Node: Procedure properties,  Next: Generic procedures,  Up: Procedures

10.1 Procedure properties
=========================

You can associate arbitrary "properties" with any procedure.  Each
property is a (KEY, VALUE)-pair.  Usually the KEY is a symbol, but it
can be any object.

   The system uses certain internal properties: ‘'name’ refers to the
name used when a procedure is printed; ‘'emacs-interactive’ is used to
implement Emacs ‘interactive’ specification; ‘'setter’ is used to
associate a ‘setter’ prcedure.

 -- Procedure: procedure-property proc key [default]
     Get the property value corresponding to the given KEY.  If PROC has
     no property with the given KEY, return DEFAULT (which defaults to
     ‘#f’) instead.

 -- Procedure: set-procedure-property! proc key value
     Associate the given VALUE with the KEY property of PROC.

   To change the print name of the standard ‘+’ procedure (probably not
a good idea!), you could do:
     (set-procedure-property! + 'name 'PLUS)
   Note this _only_ changes the name property used for printing:
     + ⇒ #<procedure PLUS>
     (+ 2 3) ⇒ 5
     (PLUS 3 4) ⇒ ERROR

   As a matter of style, it is cleaner to use the ‘define-procedure’
form, as it is a more declarative interface.

 -- Syntax: define-procedure name [propname: propvalue] ... method ...
     Defines NAME as a compound procedure consisting of the specified
     METHODs, with the associated properties.  Applying NAME select the
     "best" METHOD, and applies that.  See the following section on
     generic procedures.

     For example, the standard ‘vector-ref’ procedure specifies one
     method, as well as the ‘setter’ property:
          (define-procedure vector-ref
            setter: vector-set!
            (lambda ((vector :: <vector>) (k :: <int>))
              (invoke vector 'get k)))


File: kawa.info,  Node: Generic procedures,  Next: Extended formals,  Prev: Procedure properties,  Up: Procedures

10.2 Generic (dynamically overloaded) procedures
================================================

A "generic procedure" is a collection of "method procedures".  (A
"method procedure" is not the same as a Java method, but the terms are
related.)  You can call a generic procedure, which selects the "closest
match" among the component method procedures: I.e.  the most specific
method procedure that is applicable given the actual arguments.

     *Warning:* The current implementation of selecting the "best"
     method is not reliable if there is more than one method.  It can
     select depending on argument count, and it can select between
     primitive Java methods.  However, selecting between different
     Scheme procedures based on parameter types should be considered
     experimental.  The main problem is we can’t determine the most
     specific method, so Kawa just tries the methods in order.

 -- Procedure: make-procedure [keyword: value]... method...
     Create a generic procedure given the specific methods.  You can
     also specify property values for the result.

     The KEYWORDs specify how the arguments are used.  A ‘method:’
     keyword is optional and specifies that the following argument is a
     method.  A ‘name:’ keyword specifies the name of the resulting
     procedure, when used for printing.  Unrecognized keywords are used
     to set the procedure properties of the result.
          (define plus10 (make-procedure foo: 33 name: 'Plus10
                                      method: (lambda (x y) (+ x y 10))
                                      method: (lambda () 10)))


File: kawa.info,  Node: Extended formals,  Prev: Generic procedures,  Up: Procedures

10.3 Extended Formal Arguments List
===================================

The formal arguments list of a lambda expression has two extendsions
over standard Scheme: Kawa borrows the extended formal argument list of
DSSSL, and Kawa allows you to declare the type of the parameter.

     LAMBDA-EXPRESSION ::= ‘(lambda’ FORMALS OPT-RETURN-TYPE BODY‘)’
     RETURN-TYPE ::= TYPE
     OPT-RETURN-TYPE ::= [[‘::’] TYPE]
   where
     FORMALS ::= ‘(’FORMAL-ARGUMENTS‘)’ | REST-ARG
   You can of course also use the extended format in a ‘define’:
     (define (NAME FORMAL-ARGUMENTS) [RTYPE] BODY)
     FORMAL-ARGUMENTS ::=
         REQ-OPT-ARGS (REST-KEY-ARGS | ‘.’ REST-ARG)
     REQ-OPT-ARGS ::= REQ-ARG ... [‘#!optional’ OPT-ARG ...]
     REST-KEY-ARGS ::= [‘#!rest’ REST-ARG] [‘#!key’ KEY-ARG ...]
     REQ-ARG ::=  VARIABLE [‘::’ TYPE] | ‘(’VARIABLE [[‘::’] TYPE] ‘)’
     OPT-ARG ::= ARG-WITH-DEFAULT
     KEY-ARG ::= ARG-WITH-DEFAULT
     ARG-WITH-DEFAULT ::= VARIABLE [‘::’ TYPE]
         | ‘(’ VARIABLE [‘::’ TYPE [INITIALIZER] | INITIALIZER [[‘::’] TYPE]] ‘)’
     REST-ARG ::= VARIABLE

   When the procedure is applied to a list of actual arguments, the
formal and actual arguments are processed from left to right as follows:

   • The REQ-ARGs are bound to actual arguments starting with the first
     actual argument.  It shall be an error if there are fewer actual
     arguments then there are REQ-ARGs.
   • Next the OPT-ARGs are bound to remaining actual arguemnts.  If
     there are fewer remaining actual arguments than there are OPT-ARGs,
     then the remaining VARIABLEs are bound to the corresponding
     INITIALIZER, if one was specified, and otherwise to ‘#f’.  The
     INITIALIZER is evaluated in an environment in which all the
     previous formal parameters have been bound.
   • If there is a REST-ARG, it is bound to a list of all the remaining
     actual arguments.  These remaining actual arguments are also
     eligible to be bound to keyword arguments.  If there is no REST-ARG
     and there are no KEY-ARGs, then it shall be an error if there are
     any remaining actual arguments.
   • If ‘#!key’ was specified, then there shall be an even number of
     remaining actual arguments.  These are interpreted as a series of
     pairs, where the first member of each pair is a keyword specifying
     the argument name, and the second is the corresponding value.  It
     shall be an error if the first member of a pair is not a keyword.
     It shall be an error if the argument name is not the same as a
     variable in a KEY-ARGs, unless there is a REST-ARG.  If the same
     argument name occurs more than once in the list of actual
     arguments, then the first value is used.  If there is no actual
     argument for a particular KEY-ARG, then the variable is bound to
     the corresponding INITIALIZER, if one was specified, and otherwise
     to ‘#f’.  The INITIALIZER is evaluated in an environment in which
     all the previous formal parameters have been bound.

   If a TYPE is specified, the corresponding actual argument (or the
INITIALIZER default value) is coerced to the specified TYPE.  In the
function body, the parameter has the specified type.

   If RTYPE (the first form of the function body) is an unbound
identifier of the form ‘<TYPE>’ (that is the first character is ‘<’ and
the last is ‘>’), then that specifies the function’s return type.  It is
syntactic sugar for ‘(as <TYPE> (begin BODY))’.

 -- Syntax: cut slot-or-expr slot-or-expr* [‘<...>’]
     where each SLOT-OR-EXPR is either an EXPRESSION or the literal
     symbol ‘<>’.

     It is frequently necessary to specialize some of the parameters of
     a multi-parameter procedure.  For example, from the binary
     operation ‘cons’ one might want to obtain the unary operation
     ‘(lambda (x) (cons 1 x))’.  This specialization of parameters is
     also known as "partial application", "operator section", or
     "projection".  The macro ‘cut’ specializes some of the parameters
     of its first argument.  The parameters that are to show up as
     formal variables of the result are indicated by the symbol ‘<>’,
     pronouced as "slot".  In addition, the symbol ‘<...>’, pronounced
     as "rest-slot", matches all residual arguments of a variable
     argument procedure.

     A ‘cut’-expression is transformed into a LAMBDA EXPRESSION with as
     many formal variables as there are slots in the list SLOT-OR-EXPR*.
     The body of the resulting LAMBDA EXPRESSION calls the first
     SLOT-OR-EXPR with arguments from the SLOT-OR-EXPR* list in the
     order they appear.  In case there is a rest-slot symbol, the
     resulting procedure is also of variable arity, and the body calls
     the first SLOT-OR-EXPR with remaining arguments provided to the
     actual call of the specialized procedure.

     Here are some examples:

     ‘(cut cons (+ a 1) <>)’ is the same as ‘(lambda (x2) (cons (+ a 1) x2))’

     ‘(cut list 1 <> 3 <> 5)’ is the same as ‘(lambda (x2 x4) (list 1 x2 3 x4 5))’

     ‘(cut list)’ is the same as ‘(lambda () (list))’

     ‘(cut list 1 <> 3 <...>)’ is the same as ‘(lambda (x2 . xs) (apply list 1 x2 3 xs))’

     The first argument can also be a slot, as one should expect in
     Scheme: ‘(cut <> a b)’ is the same as ‘(lambda (f) (f a b))’

 -- Syntax: cute slot-or-expr slot-or-expr* [‘<...>’]
     The macro ‘cute’ (a mnemonic for "cut with evaluated non-slots") is
     similar to ‘cut’, but it evaluates the non-slot expressions at the
     time the procedure is specialized, not at the time the specialized
     procedure is called.

     For example ‘(cute cons (+ a 1) <>)’ is the same as ‘(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))’

     As you see from comparing this example with the first example
     above, the ‘cute’-variant will evaluate ‘(+ a 1)’ once, while the
     ‘cut’-variant will evaluate it during every invocation of the
     resulting procedure.


File: kawa.info,  Node: Numbers,  Next: Characters and text,  Prev: Procedures,  Up: Top

11 Quantities and Numbers
*************************

Kawa supports the full Scheme set of number operations with some
extensions.

   Kawa converts between Scheme number types and Java number types as
appropriate.

* Menu:

* Arithmetic operations::
* Numerical input and output::
* Quaternions::
* Quantities::
* Logical Number Operations::
* Performance of numeric operations::


File: kawa.info,  Node: Arithmetic operations,  Next: Numerical input and output,  Up: Numbers

11.1 Arithmetic operations
==========================

 -- Procedure: real-valued? OBJ
 -- Procedure: rational-valued? OBJ
 -- Procedure: integer-valued? OBJ
     These numerical type predicates can be applied to any kind of
     argument.  The ‘real-valued?’ procedure returns ‘#t’ if the object
     is a number object and is equal in the sense of ‘=’ to some real
     number object, or if the object is a NaN, or a complex number
     object whose real part is a NaN and whose imaginary part is zero in
     the sense of ‘zero?’.  The ‘rational-valued?’ and ‘integer-valued?’
     procedures return ‘#t’ if the object is a number object and is
     equal in the sense of ‘=’ to some object of the named type, and
     otherwise they return ‘#f’.

          (real-valued? +nan.0)                  ⇒ #t
          (real-valued? +nan.0+0i)               ⇒ #t
          (real-valued? -inf.0)                  ⇒ #t
          (real-valued? 3)                       ⇒ #t
          (real-valued? -2.5+0.0i)               ⇒ #t

          (real-valued? -2.5+0i)                 ⇒ #t
          (real-valued? -2.5)                    ⇒ #t
          (real-valued? #e1e10)                  ⇒ #t

          (rational-valued? +nan.0)              ⇒ #f
          (rational-valued? -inf.0)              ⇒ #f
          (rational-valued? 6/10)                ⇒ #t
          (rational-valued? 6/10+0.0i)           ⇒ #t
          (rational-valued? 6/10+0i)             ⇒ #t
          (rational-valued? 6/3)                 ⇒ #t

          (integer-valued? 3+0i)                 ⇒ #t
          (integer-valued? 3+0.0i)               ⇒ #t
          (integer-valued? 3.0)                  ⇒ #t
          (integer-valued? 3.0+0.0i)             ⇒ #t
          (integer-valued? 8/4)                  ⇒ #t

          _Note:_ These procedures test whether a given number object
          can be coerced to the specified type without loss of numerical
          accuracy.  Specifically, the behavior of these predicates
          differs from the behavior of ‘real?’, ‘rational?’, and
          ‘integer?’ on complex number objects whose imaginary part is
          inexact zero.

          _Note:_ The behavior of these type predicates on inexact
          number objects is unreliable, because any inaccuracy may
          affect the result.

 -- Procedure: exact-integer? z
     Returns ‘#t’ if Z is both exact and an integer; otherwise returns
     ‘#f’.
          (exact-integer? 32)                    ⇒ #t
          (exact-integer? 32.0)                  ⇒ #t
          (exact-integer? 32/5)                  ⇒ #f

 -- Procedure: finite? Z
     Returns ‘#t’ if Z is finite real number (i.e.  an infinity and not
     a NaN), or if Z is a complex number whose real and imaginary parts
     are both finite.
          (finite? 3)             ⇒ #t
          (finite? +inf.0)        ⇒ #f
          (finite? 3.0+inf.0i)    ⇒ #f

 -- Procedure: infinite? Z
     Return ‘#t’ if Z is an infinite real number (‘+int.0’ or ‘-inf.0’),
     or if Z is a complex number where either real or imaginary parts or
     both are infinite.
          (infinite? 5.0)         ⇒ #f
          (infinite? +inf.0)      ⇒ #t
          (infinite? +nan.0)      ⇒ #f
          (infinite? 3.0+inf.0i)  ⇒ #t

 -- Procedure: nan? Z
     For a real numer returns whether its is a NaN; for a complex number
     if the real or imaginary parts or both is a NaN.
          (nan? +nan.0)           ⇒ #t
          (nan? 32)               ⇒ #f
          (nan? +nan.0+5.0i)      ⇒ #t
          (nan? 1+2i)             ⇒ #f

 -- Procedure: + Z …
 -- Procedure: * Z …
     These procedures return the sum or product of their arguments.

          (+ 3 4)                          ⇒  7
          (+ 3)                            ⇒  3
          (+)                              ⇒  0
          (+ +inf.0 +inf.0)                ⇒  +inf.0
          (+ +inf.0 -inf.0)                ⇒  +nan.0

          (* 4)                            ⇒  4
          (*)                              ⇒  1
          (* 5 +inf.0)                     ⇒  +inf.0
          (* -5 +inf.0)                    ⇒  -inf.0
          (* +inf.0 +inf.0)                ⇒  +inf.0
          (* +inf.0 -inf.0)                ⇒  -inf.0
          (* 0 +inf.0)                     ⇒  +nan.0
          (* 0 +nan.0)                     ⇒  +nan.0
          (* 1.0 0)                        ⇒  0.0

     For any real number object X that is neither infinite nor NaN:

          (+ +inf.0 X)                   ⇒  +inf.0
          (+ -inf.0 X)                   ⇒  -inf.0

     For any real number object X:

          (+ +nan.0 X)                   ⇒  +nan.0

     For any real number object X that is not an exact 0:

          (* +nan.0 X)                   ⇒  +nan.0

     The behavior of ‘-0.0’ is illustrated by the following examples:

          (+  0.0 -0.0)  ⇒  0.0
          (+ -0.0  0.0)  ⇒  0.0
          (+  0.0  0.0)  ⇒  0.0
          (+ -0.0 -0.0)  ⇒ -0.0

 -- Procedure: - Z
 -- Procedure: - Z1 Z2 Z3 …
     With two or more arguments, this procedures returns the difference
     of its arguments, associating to the left.  With one argument,
     however, it returns the negation (additive inverse) of its
     argument.

          (- 3 4)                               ⇒  -1
          (- 3 4 5)                             ⇒  -6
          (- 3)                                 ⇒  -3
          (- +inf.0 +inf.0)                     ⇒  +nan.0

     The behavior of ‘-0.0’ is illustrated by the following examples:

          (-  0.0)       ⇒ -0.0
          (- -0.0)       ⇒  0.0
          (-  0.0 -0.0)  ⇒  0.0
          (- -0.0  0.0)  ⇒ -0.0
          (-  0.0  0.0)  ⇒  0.0
          (- -0.0 -0.0)  ⇒  0.0

 -- Procedure: / Z
 -- Procedure: / Z1 Z2 Z3 …
     If all of the arguments are exact, then the divisors must all be
     nonzero.  With two or more arguments, this procedure returns the
     quotient of its arguments, associating to the left.  With one
     argument, however, it returns the multiplicative inverse of its
     argument.

          (/ 3 4 5)                         ⇒  3/20
          (/ 3)                             ⇒  1/3
          (/ 0.0)                           ⇒  +inf.0
          (/ 1.0 0)                         ⇒  +inf.0
          (/ -1 0.0)                        ⇒  -inf.0
          (/ +inf.0)                        ⇒  0.0
          (/ 0 0)                           ⇒  exception &assertion
          (/ 3 0)                           ⇒  exception &assertion
          (/ 0 3.5)                         ⇒  0.0
          (/ 0 0.0)                         ⇒  +nan.0
          (/ 0.0 0)                         ⇒  +nan.0
          (/ 0.0 0.0)                       ⇒  +nan.0

     If this procedure is applied to mixed non–rational real and
     non–real complex arguments, it either raises an exception with
     condition type ‘&implementation-restriction’ or returns an
     unspecified number object.

 -- Procedure: floor/ x y
 -- Procedure: truncate/ x y
 -- Procedure: div-and-mod x y
 -- Procedure: div0-and-mod0 x y
     These procedures implement number–theoretic integer division.  They
     accept two real numbers X and Y as operands, where Y must be
     nonzero.  In all cases the result is two values Q (an integer) and
     R (a real) that satisfy the equations:
          X = Q * Y + R
          Q = ROUNDING-OP(X/Y)
     The result is inexact if either argument is inexact.

     For ‘floor/’ the ROUNDING-OP is the ‘floor’ function (below).
          (floor/ 123 10)         ⇒  12 3
          (floor/ 123 -10)        ⇒  -13 -7
          (floor/ -123 10)        ⇒  -13 7
          (floor/ -123 -10)       ⇒  12 -3

     For ‘truncate/’ the ROUNDING-OP is the ‘truncate’ function.
          (truncate/ 123 10)      ⇒  12 3
          (truncate/ 123 -10)     ⇒  -12 3
          (truncate/ -123 10)     ⇒  -12 -3
          (truncate/ -123 -10)    ⇒  12 -3

     For ‘div-and-mod’ the ROUNDING-OP is either ‘floor’ (if Y is
     positive) or ‘ceiling’ (if Y is negative).  We have:
          0  <= R < |Y|
          (div-and-mod 123 10)    ⇒  12 3
          (div-and-mod 123 -10)   ⇒  -12 3
          (div-and-mod -123 10)   ⇒  -13 7
          (div-and-mod -123 -10)  ⇒  13 7

     For ‘div0-and-mod0’ the ROUNDING-OP is the ‘round’ function, and
     ‘r’ lies within a half–open interval centered on zero.
          -|Y/2| <= R < |Y/2|

          (div0-and-mod0 123 10)   ⇒  12 3
          (div0-and-mod0 123 -10)  ⇒  -12 3
          (div0-and-mod0 -123 10)  ⇒  -12 -3
          (div0-and-mod0 -123 -10) ⇒  12 -3
          (div0-and-mod0 127 10)   ⇒  13 -3
          (div0-and-mod0 127 -10)  ⇒  -13 -3
          (div0-and-mod0 -127 10)  ⇒  -13 3
          (div0-and-mod0 -127 -10) ⇒  13 3

     The inconsistent naming is for historical reasons: ‘div-and-mod’
     and ‘div0-and-mod0’ are from R6RS, while ‘floor/’ and ‘truncate/’
     are from R7RS.

 -- Procedure: floor-quotient x y
 -- Procedure: truncate-quotient x y
 -- Procedure: div x y
 -- Procedure: div0 x y
     These procedures return the quotient part (first value) of
     respectively ‘floor/’, ‘truncate/’, ‘div-and-mod’, and
     ‘div0-and-mod0’.

 -- Procedure: floor-remainder x y
 -- Procedure: truncate-remainder x y
 -- Procedure: mod x y
 -- Procedure: mod0 x y
     These procedures return the remainder part (second value) of
     respectively ‘floor/’, ‘truncate/’, ‘div-and-mod’, and
     ‘div0-and-mod0’.

     As a Kawa extension Y may be zero, in which case the result is X:
          (mod 123 0)     ⇒  123 ;; Kawa extension

 -- Procedure: quotient x y
 -- Procedure: remainder x y
 -- Procedure: modulo x y
     These are equivalent to ‘truncate-quotient’, ‘truncate-remainder’,
     and ‘floor-remainder’, respectively.  These are provided for
     backward compatibility.
          (remainder 13 4)     ⇒ 1
          (remainder -13 4)    ⇒ -1
          (remainder 13 -4)    ⇒ 1
          (remainder -13 -4)   ⇒ -1
          (remainder -13 -4.0) ⇒ -1.0
          (modulo 13 4)   ⇒ 1
          (modulo -13 4)  ⇒ 3
          (modulo 13 -4)  ⇒ -4
          (modulo -13 -4) ⇒ -1

 -- Procedure: abs X
     Returns the absolute value of its argument.

          (abs -7)                         ⇒  7
          (abs -inf.0)                     ⇒  +inf.0

 -- Procedure: gcd N1 …
 -- Procedure: lcm N1 …
     These procedures return the greatest common divisor or least common
     multiple of their arguments.  The result is always non–negative.
     The arguments must be integers; if an argument is inexact, so is
     the result.

          (gcd 32 -36)                     ⇒  4
          (gcd)                            ⇒  0
          (lcm 32 -36)                     ⇒  288
          (lcm 32.0 -36)                   ⇒  288.0 ; inexact
          (lcm)                            ⇒  1

 -- Procedure: numerator Q
 -- Procedure: denominator Q
     These procedures return the numerator or denominator of their
     argument; the result is computed as if the argument was represented
     as a fraction in lowest terms.  The denominator is always positive.
     The denominator of ‘0’ is defined to be ‘1’.  The arguments must be
     integers; if an argument is inexact, so is the result.

          (numerator   (/ 6 4))            ⇒  3
          (denominator (/ 6 4))            ⇒  2
          (denominator (inexact (/ 6 4)))        ⇒  2.0

 -- Procedure: floor X
 -- Procedure: ceiling X
 -- Procedure: truncate X
 -- Procedure: round X
     These procedures return inexact integer objects for inexact
     arguments that are not infinities or NaNs, and exact integer
     objects for exact rational arguments.

     ‘floor’
          Returns the largest integer object not larger than X.

     ‘ceiling’
          Returns the smallest integer object not smaller than X.
     ‘truncate’
          Returns the integer object closest to X whose absolute value
          is not larger than the absolute value of X.

     ‘round’
          Returns the closest integer object to X, rounding to even when
          X represents a number halfway between two integers.

     If the argument to one of these procedures is inexact, then the
     result is also inexact.  If an exact value is needed, the result
     should be passed to the ‘exact’ procedure.

     Although infinities and NaNs are not integer objects, these
     procedures return an infinity when given an infinity as an
     argument, and a NaN when given a NaN.

          (floor -4.3)                     ⇒  -5.0
          (ceiling -4.3)                   ⇒  -4.0
          (truncate -4.3)                  ⇒  -4.0
          (round -4.3)                     ⇒  -4.0

          (floor 3.5)                      ⇒  3.0
          (ceiling 3.5)                    ⇒  4.0
          (truncate 3.5)                   ⇒  3.0
          (round 3.5)                      ⇒  4.0

          (round 7/2)                      ⇒  4
          (round 7)                        ⇒  7

          (floor +inf.0)                   ⇒  +inf.0
          (ceiling -inf.0)                 ⇒  -inf.0
          (round +nan.0)                   ⇒  +nan.0

 -- Procedure: rationalize X1 X2
     The ‘rationalize’ procedure returns a number object representing
     the _simplest_ rational number differing from X1 by no more than
     X2.

     A rational number _r_1_ is _simpler_ than another rational number
     _r_2_ if ‘r_1 = p_1/q_1’ and ‘r_2 = p_2/q_2’ (in lowest terms) and
     ‘|p_1| <= |p_2|’ and ‘|q_1| <= |q_2|’.  Thus ‘3/5’ is simpler than
     ‘4/7’.

     Although not all rationals are comparable in this ordering
     (consider ‘2/7’ and ‘3/5’) any interval contains a rational number
     that is simpler than every other rational number in that interval
     (the simpler ‘2/5’ lies between ‘2/7’ and ‘3/5’).

     Note that ‘0 = 0/1’ is the simplest rational of all.
          (rationalize (exact .3) 1/10)          ⇒ 1/3
          (rationalize .3 1/10)                  ⇒ #i1/3  ; approximately

          (rationalize +inf.0 3)                 ⇒  +inf.0
          (rationalize +inf.0 +inf.0)            ⇒  +nan.0

     The first two examples hold only in implementations whose inexact
     real number objects have sufficient precision.

 -- Procedure: exp Z
 -- Procedure: log Z
 -- Procedure: log Z1 Z2
 -- Procedure: sin Z
 -- Procedure: cos Z
 -- Procedure: tan Z
 -- Procedure: asin Z
 -- Procedure: acos Z
 -- Procedure: atan Z
 -- Procedure: atan X1 X2
     These procedures compute the usual transcendental functions.

     The ‘exp’ procedure computes the base–E exponential of Z.  The
     ‘log’ procedure with a single argument computes the natural
     logarithm of Z (*not* the base–10 logarithm); ‘(log Z1 Z2)’
     computes the base–Z2 logarithm of Z1.

     The ‘asin’, ‘acos’, and ‘atan’ procedures compute arcsine,
     arccosine, and arctangent, respectively.  The two–argument variant
     of ‘atan’ computes:

          (angle (make-rectangular X2 X1))

     These procedures may return inexact results even when given exact
     arguments.
          (exp +inf.0)    ⇒ +inf.0
          (exp -inf.0)    ⇒ 0.0
          (log +inf.0)    ⇒ +inf.0
          (log 0.0)       ⇒ -inf.0
          (log 0)         ⇒ exception &assertion
          (log -inf.0)    ⇒ +inf.0+3.141592653589793i    ; approximately
          (atan -inf.0)   ⇒ -1.5707963267948965          ; approximately
          (atan +inf.0)   ⇒ 1.5707963267948965           ; approximately
          (log -1.0+0.0i) ⇒ 0.0+3.141592653589793i       ; approximately
          (log -1.0-0.0i) ⇒ 0.0-3.141592653589793i       ; approximately
                                                          ; if -0.0 is distinguished

 -- Procedure: square z
     Returns the square of Z.  This is equivalent to ‘(* Z Z)’.
          (square 42)    ⇒ 1764
          (square 2.0)   ⇒ 4.0

 -- Procedure: sqrt Z
     Return the principal square root of Z.  For rational Z, the result
     has either positive real part, or zero real part and non–negative
     imaginary part.  The value of ‘(sqrt Z)’ could be expressed as:

          e^((log z)/2)

     The ‘sqrt’ procedure may return an inexact result even when given
     an exact argument.

          (sqrt -5)                   ⇒  0.0+2.23606797749979i ; approximately
          (sqrt +inf.0)               ⇒  +inf.0
          (sqrt -inf.0)               ⇒  +inf.0i

 -- Procedure: exact-integer-sqrt K
     The ‘exact-integer-sqrt’ procedure returns two non–negative exact
     integer objects _s_ and _r_ where ‘K = s^2 + r’ and ‘K < (s+1)^2’.

          (exact-integer-sqrt 4)  ⇒ 2 0 ; two return values
          (exact-integer-sqrt 5)  ⇒ 2 1 ; two return values


File: kawa.info,  Node: Numerical input and output,  Next: Quaternions,  Prev: Arithmetic operations,  Up: Numbers

11.2 Numerical input and output
===============================

 -- Procedure: number->string z [radix]

     The procedure ‘number->string’ takes a number and a radix and
     returns as a string an external representation of the given number
     in the given radix such that
          (let ((number number)
                (radix radix))
            (eqv? number
                  (string->number (number->string number radix)
                                  radix)))
     is true.  It is an error if no possible result makes this
     expression true.

     If present, RADIX must be an exact integer in the range 2 to 36,
     inclusive.  If omitted, RADIX defaults to 10.

     If Z is inexact, the RADIX is 10, and the above expression can be
     satisfied by a result that contains a decimal point, then the
     result contains a decimal point and is expressed using the minimum
     number of digits (exclusive of exponent and trailing zeroes) needed
     to make the above expression; otherwise the format of the result is
     unspecified.

     The result returned by ‘number->string’ never contains an explicit
     radix prefix.

     _Note:_ The error case can occur only when Z is not a complex
     number or is a complex number with a non-rational real or imaginary
     part.

     _Rationale:_ If Z is an inexact number and the RADIX is 10, then
     the above expression is normally satisfied by a result containing a
     decimal point.  The unspecified case allows for infinities, NaNs,
     and unusual representations.

 -- Procedure: string->number string [radix]
     Returns a number of the maximally precise representation expressed
     by the given STRING.  It is an error if RADIX is not an exact
     integer in the range 2 to 26, inclusive.

     If supplied, RADIX is a default radix that will be overridden if an
     explicit radix prefix is present in string (e.g.  ‘"#o177"’).  If
     RADIX is not supplied, then the default RADIX is 10.  If STRING is
     not a syntactically valid notation for a number, or would result in
     a number that the implementation cannot represent, then
     ‘string->number’ returns ‘#f’.  An error is never signaled due to
     the content of STRING.

          (string->number "100")      ⇒  100
          (string->number "100" 16)   ⇒  256
          (string->number "1e2")      ⇒  100.0
          (string->number "#x100" 10) ⇒  256


File: kawa.info,  Node: Quaternions,  Next: Quantities,  Prev: Numerical input and output,  Up: Numbers

11.3 Quaternions
================

Kawa extends the Scheme numeric tower to include quaternions
(http://en.wikipedia.org/wiki/Quaternion) as a proper superset of the
complex numbers.  Quaternions provide a convenient notation to represent
rotations in three-dimensional space
(http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation), and are
therefore commonly found in applications such as computer graphics,
robotics, and spacecraft engineering.  The Kawa quaternion API is
modeled after this (http://www.ccs.neu.edu/home/dorai/squat/squat.html)
with some additions.

   A quaternion is a number that can be expressed in the form
‘w+xi+yj+zk’, where ‘w’, ‘x’, ‘y’, and ‘z’ are real, and ‘i’, ‘j’, and
‘k’ are imaginary units satisfying i^2 = j^2 = k^2 = ijk = -1.  The
magnitude of a quaternion is defined to be its Euclidean norm when
viewed as a point in R^4.

   The real–part of a quaternion is also called its ‘scalar’, while the
i–part, j–part, and k–part taken together are also called its ‘vector’.
A quaternion with zero j–part and k–part is an ordinary complex number.
(If the i–part is also zero, then it is a real).  A quaternion with zero
real–part is called a ‘vector quaternion’.

   The reader syntax for number literals has been extended to support
both rectangular and polar (hyperspherical) notation for quaternions.
The rectangular notation is as above, i.e.  ‘w+xi+yj+zk’.  The polar
notation takes the form ‘r@t%u&v’, where ‘r’ is the magnitude, ‘t’ is
the first angle, and ‘u’ and ‘v’ are two other angles called the
“colatitude” and “longitude”.

   The rectangular coordinates and polar coordinates are related by the
equations:
     W = R * cos T
     X = R * sin T * cos U
     Y = R * sin T * sin U * cos V
     Z = R * sin T * sin U * cos V
   With either notation, zero elements may be omitted.

 -- Procedure: make-rectangular W X
 -- Procedure: make-rectangular W X Y Z
     These procedures construct quaternions from Cartesian coordinates.

 -- Procedure: make-polar R T
 -- Procedure: make-polar R T U V
     These procedures construct quaternions from polar coordinates.

 -- Procedure: + Q …
 -- Procedure: - Q …
 -- Procedure: * Q …
 -- Procedure: / Q
 -- Procedure: / Q1 Q2 Q3 …
 -- Procedure: expt Q1 Q2
 -- Procedure: exp Q
 -- Procedure: log Q
 -- Procedure: sqrt Q
 -- Procedure: sin Q
 -- Procedure: cos Q
 -- Procedure: tan Q
 -- Procedure: asin Q
 -- Procedure: acos Q
 -- Procedure: atan Q
     All of the arithmetic and transcendental functions defined for
     complex arguments have been extended to support quaternions.

     Quaternion multiplication is not commutative, so there are two
     possible interpretations of ‘(/ q1 q2)’ which would yield different
     results: either ‘(* q1 (/ q2))’, or ‘(* (/ q2) q1)’.  Division in
     this implementation has been defined such that ‘(/ q1 q2 ...)’ is
     equivalent to ‘(* q1 (/ q2) ...)’, but it is recommended to use
     reciprocals (unary ‘/’) and multiplication.

 -- Procedure: real-part Q
     Return the real–part of Q.

          (real-part 0)          ⇒  0
          (real-part -i)         ⇒  0
          (real-part 1+2i-3j+4k) ⇒  1

 -- Procedure: imag-part Q
     Return the i–part of Q.

          (imag-part 0)          ⇒  0
          (imag-part -i)         ⇒  -1
          (imag-part 1+2i-3j+4k) ⇒  2

 -- Procedure: magnitude Q
     Return the Euclidean norm of Q.  If Q is ‘a+bi+cj+dk’, then
     ‘(magnitude q)’ is ‘(sqrt (apply + (map square (list a b c d))))’

 -- Procedure: angle Q
     Return the angle of Q.

11.3.1 The ‘(kawa quaternions)’ module
--------------------------------------

The following additional functionality is made available by doing one
of:
     (require 'quaternions) ;; or
     (import (kawa quaternions))

 -- Alias: quaternion
     An alias for ‘gnu.math.Quaternion’, useful for type declarations.
 -- Procedure: quaternion? X
     Return ‘#t’ if X is a quaternion, i.e.  an ordinary number, and
     ‘#f’ otherwise.

          (quaternion? 0)          ⇒  #t
          (quaternion? -i)         ⇒  #t
          (quaternion? 1+2i-3j+4k) ⇒  #t
          (quaternion? 10.0m)      ⇒  #f
          (quaternion? "x")        ⇒  #f

 -- Procedure: jmag-part Q
     Return the j–part of Q.

          (jmag-part 0)          ⇒  0
          (jmag-part -i)         ⇒  0
          (jmag-part 1+2i-3j+4k) ⇒  -3
 -- Procedure: kmag-part Q

          (kmag-part 0)          ⇒  0
          (kmag-part -i)         ⇒  0
          (kmag-part 1+2i-3j+4k) ⇒  4

 -- Procedure: complex-part Q
     Return the projection of Q into the complex plane: ‘(+ (real-part
     q) (* +i (imag-part q)))’

          (complex-part 0)          ⇒  0
          (complex-part -i)         ⇒  -1i
          (complex-part 1+2i-3j+4k) ⇒  1+2i
 -- Procedure: vector-part Q
     Return the vector–part of Q.

          (vector-part 0)          ⇒  0
          (vector-part -i)         ⇒  -1i
          (vector-part 1+2i-3j+4k) ⇒  +2i-3j+4k

 -- Procedure: unit-quaternion Q
     Return a quaternion of unit magnitude with the same direction as Q.
     If Q is zero, return zero.  This is like a 4D version of a signum
     function.

          (unit-quaternion 0)          ⇒  0
          (unit-quaternion -i)         ⇒  -1i
          (unit-quaternion 1+2i-3j+4k) ⇒  0.18257418583505536+0.3651483716701107i-0.5477225575051661j+0.7302967433402214k

 -- Procedure: unit-vector Q
     Return the vector–part of Q, scaled to have magnitude 1.  If the
     vector–part is zero, then return zero.

          (unit-vector 0)          ⇒  0
          (unit-vector -i)         ⇒  -1i
          (unit-vector 1+2i-3j+4k) ⇒  +0.3713906763541037i-0.5570860145311556j+0.7427813527082074k

 -- Procedure: colatitude Q
     Return the colatitude of Q.

 -- Procedure: longitude Q
     Return the longitude of Q.

 -- Procedure: dot-product Q1 Q2
     For two vector quaternions Q1 = ‘ai+bj+ck’ and Q2 = ‘di+ej+fk’,
     return ‘ad + be + cf’.  This is equal to the R^3 dot product for
     vectors (a,b,c) and (d,e,f), and is also equal to ‘(- (real-part (*
     q1 q2)))’.  It is an error if either Q1 or Q2 has a non-zero
     real–part.

 -- Procedure: cross-product Q1 Q2
     For two vector quaternions Q1 = ‘ai+bj+ck’ and Q2 = ‘di+ej+fk’,
     return the R^3 cross product for vectors (a,b,c) and (d,e,f), which
     is equal to ‘(vector-part (* q1 q2))’.  It is an error if either Q1
     or Q2 has a non-zero real–part.

 -- Procedure: conjugate Q
     Return ‘(+ (real-part q) (* -1 (vector-part q)))’.

          (conjugate 0)          ⇒  0
          (conjugate -i)         ⇒  +1i
          (conjugate 1+2i-3j+4k) ⇒  1-2i+3j-4k


File: kawa.info,  Node: Quantities,  Next: Logical Number Operations,  Prev: Quaternions,  Up: Numbers

11.4 Quantities and Units
=========================

As a super-class of numbers, Kawa also provides quantities.  A
"quantity" is a product of a "unit" and a pure number.  The number part
can be an arbitrary complex number.  The unit is a product of integer
powers of base units, such as meter or second.

   Quantity literals have the following syntax:
     QUANTITY ::= OPTIONAL-SIGN DECIMAL UNIT-TERM [‘*’ UNIT-TERM]... [‘/’ UNIT-TERM]
     UNIT-TERM ::= UNIT-NAME [‘^’ DIGIT+]
     UNIT-NAME ::= LETTER+
   Some examples are ‘10pt’ (10 points), ‘5s’ (5 seconds), and ‘4cm^2’
(4 square centimeters).

   Note the QUANTITY syntax is not recognized by the reader.  Instead
these are read as symbols.  Assuming there is no lexical binding the for
the symbol, it will be rewritten at compile-time into an expression.
For example ‘4cm^2’ is transformed into:
     (* 4.0 (expt unit:cm 2))

 -- Procedure: quantity? object
     True iff OBJECT is a quantity.  Note that all numbers are
     quantities, but not the other way round.  Currently, there are no
     quantities that re not numbers.  To distinguish a plain unit-less
     number from a quantity, you can use ‘complex?’.

 -- Procedure: quantity->number q
     Returns the pure number part of the quantity Q, relative to
     primitive (base) units.  If Q is a number, returns Q.  If Q is a
     unit, yields the magitude of Q relative to base units.

 -- Procedure: quantity->unit q
     Returns the unit of the quantity Q.  If Q is a number, returns the
     empty unit.

 -- Procedure: make-quantity x unit
     Returns the product of X (a pure number) and UNIT.  You can specify
     a string instead of UNIT, such as ‘"cm"’ or ‘"s"’ (seconds).

 -- Syntax: define-base-unit unit-name dimension
     Define UNIT-NAME as a base (primitive) unit, which is used to
     measure along the specified DIMENSION.
          (define-base-unit dollar "Money")

 -- Syntax: define-unit unit-name expression
     Define UNIT-NAME as a unit (that can be used in literals) equal to
     the quantity EXPRESSION.
          (define-unit cent 0.01dollar)
     The UNIT-NAME is declared in the ‘unit’ namespace, so the above is
     equivalent to:
          (define-constant unit:cent (* 0.01 unit:dollar))


File: kawa.info,  Node: Logical Number Operations,  Next: Performance of numeric operations,  Prev: Quantities,  Up: Numbers

11.5 Logical Number Operations
==============================

These functions operate on the 2’s complement binary representation of
an exact integer.

 -- Procedure: bitwise-not i
     Returns the bit-wise logical inverse of the argument.  More
     formally, returns the exact integer whose two’s complement
     representation is the one’s complement of the two’s complement
     representation of I.

 -- Procedure: bitwise-and i ...
 -- Procedure: bitwise-ior i ...
 -- Procedure: bitwise-xor i ...
     These procedures return the exact integer that is the bit-wise
     “and”, “inclusive or”, or “exclusive or” of the two’s complement
     representations of their arguments.  If they are passed only one
     argument, they return that argument.  If they are passed no
     arguments, they return the integer that acts as identity for the
     operation: -1, 0, or 0, respectively.

 -- Procedure: bitwise-if i1 i2 i3

     Returns the exact integer that is the bit-wise “if” of the twos
     complement representations of its arguments, i.e.  for each bit, if
     it is 1 in i1, the corresponding bit in i2 becomes the value of the
     corresponding bit in the result, and if it is 0, the corresponding
     bit in i3 becomes the corresponding bit in the value of the result.
     This is equivaent to the following computation:
          (bitwise-ior (bitwise-and i1 i2)
                       (bitwise-and (bitwise-not i1) i3))

 -- Procedure: bitwise-bit-count i
     If ei is non-negative, returns the number of 1 bits in the twos
     complement representation of i.  Otherwise it returns the result of
     the following computation:
          (bitwise-not (bitwise-bit-count (bitwise-not i)))

 -- Procedure: bitwise-length i
     Returns the number of bits needed to represent i if it is positive,
     and the number of bits needed to represent ‘(bitwise-not I)’ if it
     is negative, which is the exact integer that is the result of the
     following computation:
          (do ((result 0 (+ result 1))
               (bits (if (negative? i)
                         (bitwise-not i)
                         ei)
                     (bitwise-arithmetic-shift bits -1)))
              ((zero? bits)
               result))
     This is the number of bits needed to represent I in an unsigned
     field.

 -- Procedure: bitwise-first-bit-set i
     Returns the index of the least significant 1 bit in the twos
     complement representation of i.  If ei is 0, then - 1 is returned.
          (bitwise-first-bit-set 0) ⇒ -1
          (bitwise-first-bit-set 1) ⇒ 0
          (bitwise-first-bit-set -4) ⇒ 2

 -- Procedure: bitwise-bit-set? i1 i2
     Returns ‘#t’ if the i2’th bit (where I2 must be non-negative) is 1
     in the two’s complement representation of I1, and ‘#f’ otherwise.
     This is the result of the following computation:
          (not (zero?
                 (bitwise-and
                   (bitwise-arithmetic-shift-left 1 i2)
                   i1)))

 -- Procedure: bitwise-copy-bit i bitno replacement-bit
     Return the result of replacing the BITNO’th bit of I by
     REPLACEMENT-BIT, where BITNO must be non-negative, and
     REPLACEMENT-BIT must be either 0 or 1.  This is the result of the
     following computation:
          (let* ((mask (bitwise-arithmetic-shift-left 1 bitno)))
            (bitwise-if mask
                      (bitwise-arithmetic-shift-left replacement-bit bitno)
                      i))

 -- Procedure: bitwise-bit-field n start end
     Return the integer formed from the (unsigned) bit-field starting at
     START and ending just before END.  Same as:
          (let ((mask
                 (bitwise-not
                  (bitwise-arithmetic-shift-left -1 END))))
            (bitwise-arithmetic-shift-right
              (bitwise-and N mask)
              START))

 -- Procedure: bitwise-copy-bit-field to start end from
     Returns the result of replacing in TO the bits at positions from
     START (inclusive) to END (exclusive) by the bits in FROM from
     position 0 (inclusive) to position END - START (exclusive).  Both
     START and START must be non-negative, and START must be less than
     or equal to START.

     This is the result of the following computation:
          (let* ((mask1
                   (bitwise-arithmetic-shift-left -1 start))
                 (mask2
                   (bitwise-not
                     (bitwise-arithmetic-shift-left -1 end)))
                 (mask (bitwise-and mask1 mask2)))
            (bitwise-if mask
                        (bitwise-arithmetic-shift-left from
                                                       start)
                        to))

 -- Procedure: bitwise-arithmetic-shift i j
     Shifts I by J.  It is a “left” shift if ‘J>0’, and a “right” shift
     if ‘J<0’.  The result is equal to ‘(floor (* I (expt 2 J)))’.

     Examples:
          (bitwise-arithmetic-shift -6 -1) ⇒-3
          (bitwise-arithmetic-shift -5 -1) ⇒ -3
          (bitwise-arithmetic-shift -4 -1) ⇒ -2
          (bitwise-arithmetic-shift -3 -1) ⇒ -2
          (bitwise-arithmetic-shift -2 -1) ⇒ -1
          (bitwise-arithmetic-shift -1 -1) ⇒ -1

 -- Procedure: bitwise-arithmetic-shift-left i amount
 -- Procedure: bitwise-arithmetic-shift-right i amount
     The AMOUNT must be non-negative The ‘bitwise-arithmetic-shift-left’
     procedure returns the same result as ‘bitwise-arithmetic-shift’,
     and ‘(bitwise-arithmetic-shift-right I AMOUNT)’ returns the same
     result as ‘(bitwise-arithmetic-shift I (- AMOUNT))’;

 -- Procedure: bitwise-rotate-bit-field n start end count
     Returns the result of cyclically permuting in N the bits at
     positions from START (inclusive) to END (exclusive) by COUNT bits
     towards the more significant bits, START and END must be
     non-negative, and START must be less than or equal to END.  This is
     the result of the following computation:
          (let* ((n     ei1)
                 (width (- end start)))
            (if (positive? width)
                (let* ((count (mod count width))
                       (field0
                         (bitwise-bit-field n start end))
                       (field1 (bitwise-arithmetic-shift-left
                                 field0 count))
                       (field2 (bitwise-arithmetic-shift-right
                                 field0
                                 (- width count)))
                       (field (bitwise-ior field1 field2)))
                  (bitwise-copy-bit-field n start end field))
                n))

 -- Procedure: bitwise-reverse-bit-field i start end
     Returns the result obtained from I by reversing the order of the
     bits at positions from START (inclusive) to END (exclusive), where
     START and END must be non-negative, and START must be less than or
     equal to END.
          (bitwise-reverse-bit-field #b1010010 1 4) ⇒  88 ; #b1011000

 -- Procedure: logop op x y
     Perform one of the 16 bitwise operations of X and Y, depending on
     OP.

 -- Procedure: logtest i j
     Returns true if the arguments have any bits in common.  Same as
     ‘(not (zero? (bitwise-and I J)))’, but is more efficient.

11.5.1 SRFI-60 Logical Number Operations
----------------------------------------

Kawa supports SRFI-60 “Integers as Bits” as well, although we generally
recommend using the R6RS-compatible functions instead when possible.
Unless noted as being a builtin function, to use these you must first
‘(require 'srfi-60)’ or ‘(import (srfi :60))’ (or ‘(import (srfi :60
integer-bits))’).

 -- Procedure: logand i ...
     Equivalent to ‘(bitwise-and I ...)’.  Builtin.

 -- Procedure: logior i ...
     Equivalent to ‘(bitwise-ior I ...)’.  Builtin.

 -- Procedure: logxor i ...
     Equivalent to ‘(bitwise-xor I ...)’.  Builtin.

 -- Procedure: lognot i
     Equivalent to ‘(bitwise-not I)’.  Builtin.

 -- Procedure: bitwise-merge mask i j
     Equivalent to ‘(bitwise-if MASK I J)’.

 -- Procedure: any-bits-set? i j
     Equivalent to ‘(logtest I J)’.

 -- Procedure: logcount i
 -- Procedure: bit-count i
     Count the number of 1-bits in I, if it is non-negative.  If I is
     negative, count number of 0-bits.  Same as ‘(bitwise-bit-count I)’
     if I is non-negative.  Builtin as ‘logcount’.

 -- Procedure: integer-length i
     Equivalent to ‘(bitwise-length I)’.  Builtin.

 -- Procedure: log2-binary-factors i
 -- Procedure: first-set-bit i
     Equivalent to ‘(bitwise-first-bit-set I)’.

 -- Procedure: logbit? pos i
 -- Procedure: bit-set? pos i
     Equivalent to ‘(bitwise-bit-set? I POS)’.

 -- Procedure: copy-bit bitno i bool
     Equivalent to ‘(bitwise-copy-bit I BITNO (if BOOL 1 0))’.

 -- Procedure: bit-field n start end
     Equivalent to ‘(bitwise-bit-field N START END)’.

 -- Procedure: copy-bit-field to from start end
     Equivalent to ‘(bitwise-copy-bit-field TO START END FROM)’.

 -- Procedure: arithmetic-shift i j
     Equivalent to ‘(bitwise-arithmetic-shift I J)’.  Builtin.

 -- Procedure: ash i j
     Alias for ‘arithmetic-shift’.  Builtin.

 -- Procedure: rotate-bit-field n count start end
     Equivalent to ‘(bitwise-rotate-bit-field N START END COUNT)’.

 -- Procedure: reverse-bit-field i start end
     Equivalent to ‘(bitwise-reverse-bit-field I START END)’.

 -- Procedure: integer->list K [LENGTH]
 -- Procedure: list->integer LIST
     The ‘integer->list’ procedure returns a list of LENGTH booleans
     corresponding to the bits of the non-negative integer K, with ‘#t’
     for ‘1’ and ‘#f’ for ‘0’.  LENGTH defaults to ‘(bitwise-length K)’.
     The list will be in order from MSB to LSB, with the value of ‘(odd?
     K)’ in the last car.

     The ‘list->integer’ procedure returns the integer corresponding to
     the booleans in the list LIST.  The ‘integer->list’ and
     ‘list->integer’ procedures are inverses so far as ‘equal?’ is
     concerned.

 -- Procedure: booleans->integer bool1 ...
     Returns the integer coded by the BOOL1 ...  arguments.  Equivalent
     to ‘(list->integer (list BOOL1 ...))’.

11.5.2 Deprecated Logical Number Operations
-------------------------------------------

This older function is still available, but we recommend using the
R6RS-compatible function.

 -- Procedure: bit-extract n start end
     Equivalent to ‘(bitwise-bit-field N START END)’.


File: kawa.info,  Node: Performance of numeric operations,  Prev: Logical Number Operations,  Up: Numbers

11.6 Performance of numeric operations
======================================

Kawa can generally do a pretty good job of generating efficient code for
numeric operations, at least when it knows or can figure out the types
of the operands.

   The basic operations ‘+’, ‘-’, and ‘*’ are compiled to
single-instruction bytecode if both operands are ‘int’ or ‘long’.
Likewise, if both operands are floating-point (or one is floating-point
and the other is rational), then single-instruction ‘double’ or ‘float’
instructions are emitted.

   A binary operation involing an infinite-precision ‘integer’ and a
fixed-size ‘int’ or ‘long’ is normally evaluated by expanding the latter
to ‘integer’ and using ‘integer’ arithmetic.  An exception is the
‘integer’ argument is an integer literal whose value fits in a ‘int’ or
‘long’ - in that case the operation is done using ‘int’ or ‘long’
arithmetic.

   In general, integer literals have amorphous type.  When used to infer
the type of a variable, they have ‘integer’ type:
     (let ((v1 0))
       ... v1 has type integer ... )
   However, a literal whose value fits in the ‘int’ or ‘long’ range is
implicitly viewed ‘int’ or ‘long’ in certain contexts, primarily method
overload resolution and binary arithmethic (as mentioned above).

   The comparison functions ‘<’, ‘<=’, ‘=’, ‘>’, and ‘=>’ are also
optimized to single instriction operations if the operands have
appropriate type.  However, the functions ‘zero?’, ‘positive?’, and
‘negative?’ have not yet been optimized.  Instead of ‘(positive? x)’
write ‘(> x 0)’.

   There are a number of integer division and modulo operations.  If the
operands are ‘int’ or ‘long’, it is faster to use ‘quotient’ and
‘remainder’ rather than ‘div’ and ‘mod’ (or ‘modulo’).  If you know the
first operand is non-negative and the second is positive, then use
‘quotient’ and ‘remainder’.  (If an operand is an arbitrary-precision
‘integer’, then it dosn’t really matter.)

   The logical operations ‘bitwise-and’, ‘bitwise-ior’, ‘bitwise-xor’,
‘bitwise-not’, ‘bitwise-arithmetic-shift-left’,
‘bitwise-arithmetic-shift-right’ are compiled to single bitcode
instructions if the operands are ‘int’ or ‘long’.  Avoid
‘bitwise-arithmetic-shift’ if the sign of the shift is known.  If the
operands are arbitrary-precision ‘integer’, a library call is needed,
but run-time type dispatch is avoided.


File: kawa.info,  Node: Characters and text,  Next: Data structures,  Prev: Numbers,  Up: Top

12 Characters and text
**********************

* Menu:

* Characters::
* Character sets::
* Strings::
* String literals::
* Unicode::              Unicode character classes and conversions
* Regular expressions::


File: kawa.info,  Node: Characters,  Next: Character sets,  Up: Characters and text

12.1 Characters
===============

Characters are objects that represent human-readable characters such as
letters and digits.  More precisely, a character represents a Unicode
scalar value (http://www.unicode.org/glossary/#unicode_scalar_value).
Each character has an integer value in the range ‘0’ to ‘#x10FFFF’
(excluding the range ‘#xD800’ to ‘#xDFFF’ used for Surrogate Code Points
(http://www.unicode.org/glossary/#surrogate_code_point)).

     _Note:_ Unicode distinguishes between glyphs, which are printed for
     humans to read, and characters, which are abstract entities that
     map to glyphs (sometimes in a way that’s sensitive to surrounding
     characters).  Furthermore, different sequences of scalar values
     sometimes correspond to the same character.  The relationships
     among scalar, characters, and glyphs are subtle and complex.

     Despite this complexity, most things that a literate human would
     call a “character” can be represented by a single Unicode scalar
     value (although several sequences of Unicode scalar values may
     represent that same character).  For example, Roman letters,
     Cyrillic letters, Hebrew consonants, and most Chinese characters
     fall into this category.

     Unicode scalar values exclude the range ‘#xD800’ to ‘#xDFFF’, which
     are part of the range of Unicode "code points".  However, the
     Unicode code points in this range, the so-called "surrogates", are
     an artifact of the UTF-16 encoding, and can only appear in specific
     Unicode encodings, and even then only in pairs that encode scalar
     values.  Consequently, all characters represent code points, but
     the surrogate code points do not have representations as
     characters.

 -- Type: character
     A Unicode code point - normally a Unicode scalar value, but could
     be a surrogate.  This is implemented using a 32-bit ‘int’.  When an
     object is needed (i.e.  the "boxed" representation), it is
     implemented an instance of ‘gnu.text.Char’.

 -- Type: character-or-eof
     A ‘character’ or the specical ‘#!eof’ value (used to indicate
     end-of-file when reading from a port).  This is implemented using a
     32-bit ‘int’, where the value -1 indicates end-of-file.  When an
     object is needed, it is implemented an instance of ‘gnu.text.Char’
     or the special ‘#!eof’ object.

 -- Type: char
     A UTF-16 code unit.  Same as Java primitive ‘char’ type.
     Considered to be a sub-type of ‘character’.  When an object is
     needed, it is implemented as an instance of ‘java.lang.Character’.
     Note the unfortunate inconsistency (for historical reasons) of
     ‘char’ boxed as ‘Character’ vs ‘character’ boxed as ‘Char’.

   Characters are written using the notation ‘#\’CHARACTER (which stands
for the given CHARACTER; ‘#\x’HEX-SCALAR-VALUE (the character whose
scalar value is the given hex integer); or ‘#\’CHARACTER-NAME (a
character with a given name):

     CHARACTER ::= ‘#\’ANY-CHARACTER
             | ‘#\’ CHARACTER-NAME
             | ‘#\x’ HEX-SCALAR-VALUE
             | ‘#\X’ HEX-SCALAR-VALUE

   The following CHARACTER-NAME forms are recognized:
‘#\alarm’
     ‘#\x0007’ - the alarm (bell) character
‘#\backspace’
     ‘#\x0008’
‘#\delete’
‘#\del’
‘#\rubout’
     ‘#\x007f’ - the delete or rubout character
‘#\escape’
‘#\esc’
     ‘#\x001b’
‘#\newline’
‘#\linefeed’
     ‘#\x001a’ - the linefeed character
‘#\null’
‘#\nul’
     ‘#\x0000’ - the null character
‘#\page’
     ‘#\000c’ - the formfeed character
‘#\return’
     ‘#\000d’ - the carriage return character
‘#\space’
     ‘#\x0020’ - the preferred way to write a space
‘#\tab’
     ‘#\x0009’ - the tab character
‘#\vtab’
     ‘#\x000b’ - the vertical tabulation character

 -- Procedure: char? OBJ
     Return ‘#t’ if OBJ is a character, ‘#f’ otherwise.  (The OBJ can be
     any character, not just a 16-bit ‘char’.)

 -- Procedure: char->integer CHAR
 -- Procedure: integer->char SV
     SV should be a Unicode scalar value, i.e., a non–negative exact
     integer object in ‘[0, #xD7FF] union [#xE000, #x10FFFF]’.  (Kawa
     also allows values in the surrogate range.)

     Given a character, ‘char->integer’ returns its Unicode scalar value
     as an exact integer object.  For a Unicode scalar value SV,
     ‘integer->char’ returns its associated character.

          (integer->char 32)                     ⇒ #\space
          (char->integer (integer->char 5000))   ⇒ 5000
          (integer->char #\xD800)                ⇒ throws ClassCastException

     _Performance note:_ A call to ‘char->integer’ is compiled as
     casting the argument to a ‘character’, and then re-interpreting
     that value as an ‘int’.  A call to ‘integer->char’ is compiled as
     casting the argument to an ‘int’, and then re-interpreting that
     value as an ‘character’.  If the argument is the right type, no
     code is emitted: the value is just re-interpreted as the result
     type.

 -- Procedure: char=? CHAR1 CHAR2 CHAR3 …
 -- Procedure: char<? CHAR1 CHAR2 CHAR3 …
 -- Procedure: char>? CHAR1 CHAR2 CHAR3 …
 -- Procedure: char<=? CHAR1 CHAR2 CHAR3 …
 -- Procedure: char>=? CHAR1 CHAR2 CHAR3 …
     These procedures impose a total ordering on the set of characters
     according to their Unicode scalar values.

          (char<? #\z #\ß)      ⇒ #t
          (char<? #\z #\Z)      ⇒ #f

     _Performance note:_ This is compiled as if converting each argument
     using ‘char->integer’ (which requires no code) and the using the
     corresponing ‘int’ comparison.

 -- Procedure: digit-value char
     This procedure returns the numeric value (0 to 9) of its argument
     if it is a numeric digit (that is, if ‘char-numeric?’ returns
     ‘#t’), or ‘#f’ on any other character.

          (digit-value #\3)        ⇒ 3
          (digit-value #\x0664)    ⇒ 4
          (digit-value #\x0AE6)    ⇒ 0
          (digit-value #\x0EA6)    ⇒ #f


File: kawa.info,  Node: Character sets,  Next: Strings,  Prev: Characters,  Up: Characters and text

12.2 Character sets
===================

Sets of characters are useful for text-processing code, including
parsing, lexing, and pattern-matching.  SRFI 14
(http://srfi.schemers.org/srfi-14/srfi-14.html) specifies a ‘char-set’
type for such uses.  Some examples:

     (import (srfi :14 char-sets))
     (define vowel (char-set #\a #\e #\i #\o #\u))
     (define vowely (char-set-adjoin vowel #\y))
     (char-set-contains? vowel #\y) ⇒  #f
     (char-set-contains? vowely #\y) ⇒  #t

   See the SRFI 14 specification
(http://srfi.schemers.org/srfi-14/srfi-14.html) for details.

 -- Type: char-set
     The type of character sets.  In Kawa ‘char-set’ is a type that can
     be used in type specifiers:
          (define vowely ::char-set (char-set-adjoin vowel #\y))

   Kawa uses inversion lists
(http://www.ibm.com/developerworks/linux/library/l-cpinv.html) for an
efficient implementation, using Java ‘int’ arrays to represents
character ranges (inversions).  The ‘char-set-contains?’ function uses
binary search, so it takes time proportional to the logarithm of the
number of inversions.  Other operations may take time proportional to
the number of inversions.


File: kawa.info,  Node: Strings,  Next: String literals,  Prev: Character sets,  Up: Characters and text

12.3 Strings
============

Strings are sequences of characters.  The _length_ of a string is the
number of characters that it contains, as an exact non-negative integer.
This number is usually fixed when the string is created, however, you
can extend a mutable string with the (Kawa-specific) ‘string-append!’
function.  The _valid indices_ of a string are the exact non-negative
integers less than the length of the string.  The first character of a
string has index 0, the second has index 1, and so on.

   Strings are _implemented_ as a sequence of 16-bit ‘char’ values, even
though they’re semantically a sequence of 32-bit Unicode code points.  A
character whose value is greater than ‘#xffff’ is represented using two
surrogate characters.  The implementation allows for natural
interoperability with Java APIs.  However it does make certain
operations (indexing or counting based on character counts) difficult to
implement efficiently.  Luckily one rarely needs to index or count based
on character counts; alternatives are discussed below.

   Some of the procedures that operate on strings ignore the difference
between upper and lower case.  The names of the versions that ignore
case end with “‘-ci’” (for “case insensitive”).

 -- Type: string
     The type of string objects.  The underlying type is the interface
     ‘java.lang.CharSequence’.  Immultable strings are
     ‘java.lang.String’, while mutable strings are ‘gnu.lists.FString’.

12.3.1 Basic string procedures
------------------------------

 -- Procedure: string? OBJ
     Return ‘#t’ if OBJ is a string, ‘#f’ otherwise.

 -- Constructor: string CHAR …
     Return a newly allocated string composed of the arguments.  This is
     analogous to LIST.

 -- Procedure: make-string K
 -- Procedure: make-string K CHAR
     Return a newly allocated string of length K.  If CHAR is given,
     then all elements of the string are initialized to CHAR, otherwise
     the contents of the STRING are unspecified.

 -- Procedure: string-length STRING
     Return the number of characters in the given STRING as an exact
     integer object.

     _Performance note:_ Calling ‘string-length’ may take time
     propertial to the length of the STRING, because of the need to scan
     for surrogate pairs.

 -- Procedure: string-ref STRING K
     K must be a valid index of STRING.  The ‘string-ref’ procedure
     returns character K of STRING using zero–origin indexing.

     _Performance note:_ Calling ‘string-ref’ may take time propertial
     to K because of the need to check for surrogate pairs.  An
     alternative is to use ‘string-cursor-ref’.  If iterating through a
     string, use ‘string-for-each’.

 -- Procedure: string-set! string k char
     This procedure stores CHAR in element K of STRING.

          (define s1 (make-string 3 #\*))
          (define s2 "***")
          (string-set! s1 0 #\?) ⇒ _void_
          s1 ⇒ "?**"
          (string-set! s2 0 #\?) ⇒ _error_
          (string-set! (symbol->string 'immutable) 0 #\?) ⇒ _error_

     _Performance note:_ Calling ‘string-set!’ may take time propertial
     to the length of the string: First it must scan for the right
     position, like ‘string-ref’ does.  Then if the new character
     requires using a surrogate pair (and the old one doesn’t) then we
     have to make rom in the string, possible re-allocating a new ‘char’
     array.  Alternatively, if the old character requires using a
     surrogate pair (and the new one doesn’t) then following characters
     need to be moved.

     The function ‘string-set!’ is deprecated: It is inefficient, and it
     very seldom does the correct thing.  Instead, you can construct a
     string with ‘string-append!’.

 -- Procedure: substring STRING START END
     STRING must be a string, and START and END must be exact integer
     objects satisfying:

          0 <= START <= END <= (string-length STRING)

     The ‘substring’ procedure returns a newly allocated string formed
     from the characters of STRING beginning with index START
     (inclusive) and ending with index END (exclusive).

 -- Procedure: string-append STRING …
     Return a newly allocated string whose characters form the
     concatenation of the given strings.

 -- Procedure: string-append! STRING VALUE …
     The STRING must be a mutable string, such as one retuned by
     ‘make-string’ or ‘string-copy’.  The ‘string-append!’ procedure
     extends STRING by appending each VALUE (in order) to the end of
     STRING.

     _Performance note:_ The compiler converts a call with multiple
     VALUEs to a multiple ‘string-append!’ calls.  If a VALUE is known
     to be a ‘character’, then no boxing (object-allocation) is needed.

     The following example show to to efficiently process a string using
     ‘string-for-each’ and incrementally “building” a result string
     using ‘string-append!’.

          (define (translate-space-to-newline str::string)::string
            (let ((result (make-string 0)))
              (string-for-each
               (lambda (ch)
                 (string-append! result
                                 (if (char=? ch #\Space) #\Newline ch)))
               str)
              result))

 -- Procedure: string->list STRING [START [END]]
 -- Procedure: list->string LIST
     It is an error if any element of LIST is not a character.

     The ‘string->list’ procedure returns a newly allocated list of the
     characters of STRING between START and END.  The ‘list->string’
     procedure returns a newly allocated string formed from the
     characters in LIST.  In both procedures, order is preserved.  The
     ‘string->list’ and ‘list->string’ procedures are inverses so far as
     ‘equal?’ is concerned.

 -- Procedure: string-for-each PROC STRING1 STRING2 …
 -- Procedure: string-for-each PROC STRING1 [start [end]]
     The STRINGs must all have the same length.  PROC should accept as
     many arguments as there are STRINGs.

     The START-END variant is provided for compatibility with the
     SRFI-13 version.  (In that case START and END count code Unicode
     scalar values (‘character’ values), not Java 16-bit ‘char’ values.)

     The ‘string-for-each’ procedure applies PROC element–wise to the
     characters of the STRINGs for its side effects, in order from the
     first characters to the last.  PROC is always called in the same
     dynamic environment as ‘string-for-each’ itself.

     Analogous to ‘for-each’.

          (let ((v '()))
            (string-for-each
              (lambda (c) (set! v (cons (char->integer c) v)))
              "abcde")
             v)
            ⇒ (101 100 99 98 97)

     _Performance note:_ The compiler generates efficient code for
     ‘string-for-each’.  If PROC is a lambda expression, it is inlined,

 -- Procedure: string-map PROC STRING1 STRING2 …
     The ‘string-map’ procedure applies PROC element-wise to the
     elements of the strings and returns a string of the results, in
     order.  It is an error if PROC does not accept as many arguments as
     there are strings, or return other than a single character.  If
     more than one string is given and not all strings have the same
     length, ‘string-map’ terminates when the shortest string runs out.
     The dynamic order in which PROC is applied to the elements of the
     strings is unspecified.

          (string-map char-foldcase "AbdEgH")  ⇒ "abdegh"
          (string-map
            (lambda (c) (integer->char (+ 1 (char->integer c))))
            "HAL")
                  ⇒ "IBM"
          (string-map
            (lambda (c k)
              ((if (eqv? k #\u) char-upcase char-downcase) c))
            "studlycaps xxx"
            "ululululul")
                  ⇒ "StUdLyCaPs"

     _Performance note:_ The ‘string-map’ procedure has not been
     optimized (mainly because it is not very useful): The characters
     are boxed, and the PROC is not inlined even if a lambda expression.

 -- Procedure: string-copy STRING [START [END]]
     Returns a newly allocated copy of the the part of the given STRING
     between START and END.

 -- Procedure: string-replace! DST DST-START DST-END SRC [SRC-START
          [SRC-END]]
     Replaces the characters of string DST (between DST-START and
     DST-END) with the characters of SRC (between SRC-START and
     SRC-END).  The number of characters from SRC may be different than
     the number replaced in DST, so the string may grow or contract.
     The special case where DST-START is equal to DST-END corresponds to
     insertion; the case where SRC-START is equal to SRC-END corresponds
     to deletion.  The order in which characters are copied is
     unspecified, except that if the source and destination overlap,
     copying takes places as if the source is first copied into a
     temporary string and then into the destination.  (This is achieved
     without allocating storage by making sure to copy in the correct
     direction in such circumstances.)

 -- Procedure: string-copy! TO AT FROM [START [END]]
     Copies the characters of the string FROM that are between START end
     END into the string TO, starting at index AT.  The order in which
     characters are copied is unspecified, except that if the source and
     destination overlap, copying takes places as if the source is first
     copied into a temporary string and then into the destination.
     (This is achieved without allocating storage by making sure to copy
     in the correct direction in such circumstances.)

     This is equivalent to (and implemented as):
          (string-replace! to at (+ at (- end start)) from start end))

          (define a "12345")
          (define b (string-copy "abcde"))
          (string-copy! b 1 a 0 2)
          b  ⇒  "a12de"

 -- Procedure: string-fill! STRING FILL [START [END]]
     The ‘string-fill!’ procedure stores FILL in the elements of STRING
     between START and END.  It is an error if FILL is not a character
     or is forbidden in strings.

12.3.2 String Comparisons
-------------------------

 -- Procedure: string=? STRING1 STRING2 STRING3 …
     Return ‘#t’ if the strings are the same length and contain the same
     characters in the same positions.  Otherwise, the ‘string=?’
     procedure returns ‘#f’.

          (string=? "Straße" "Strasse")    ⇒ #f

 -- Procedure: string<? STRING1 STRING2 STRING3 …
 -- Procedure: string>? STRING1 STRING2 STRING3 …
 -- Procedure: string<=? STRING1 STRING2 STRING3 …
 -- Procedure: string>=? STRING1 STRING2 STRING3 …
     These procedures return ‘#t’ if their arguments are (respectively):
     monotonically increasing, monotonically decreasing, monotonically
     non-decreasing, or monotonically nonincreasing.  These predicates
     are required to be transitive.

     These procedures are the lexicographic extensions to strings of the
     corresponding orderings on characters.  For example, ‘string<?’ is
     the lexicographic ordering on strings induced by the ordering
     ‘char<?’ on characters.  If two strings differ in length but are
     the same up to the length of the shorter string, the shorter string
     is considered to be lexicographically less than the longer string.

          (string<? "z" "ß")      ⇒ #t
          (string<? "z" "zz")     ⇒ #t
          (string<? "z" "Z")      ⇒ #f

 -- Procedure: string-ci=? STRING1 STRING2 STRING3 …
 -- Procedure: string-ci<? STRING1 STRING2 STRING3 …
 -- Procedure: string-ci>? STRING1 STRING2 STRING3 …
 -- Procedure: string-ci<=? STRING1 STRING2 STRING3 …
 -- Procedure: string-ci>=? STRING1 STRING2 STRING3 …
     These procedures are similar to ‘string=?’, etc., but behave as if
     they applied ‘string-foldcase’ to their arguments before invokng
     the corresponding procedures without ‘-ci’.

          (string-ci<? "z" "Z")                   ⇒ #f
          (string-ci=? "z" "Z")                   ⇒ #t
          (string-ci=? "Straße" "Strasse")        ⇒ #t
          (string-ci=? "Straße" "STRASSE")        ⇒ #t
          (string-ci=? "ΧΑΟΣ" "χαοσ")             ⇒ #t

12.3.3 String Conversions
-------------------------

 -- Procedure: string-upcase STRING
 -- Procedure: string-downcase STRING
 -- Procedure: string-titlecase STRING
 -- Procedure: string-foldcase STRING
     These procedures take a string argument and return a string result.
     They are defined in terms of Unicode’s locale–independent case
     mappings from Unicode scalar–value sequences to scalar–value
     sequences.  In particular, the length of the result string can be
     different from the length of the input string.  When the specified
     result is equal in the sense of ‘string=?’ to the argument, these
     procedures may return the argument instead of a newly allocated
     string.

     The ‘string-upcase’ procedure converts a string to upper case;
     ‘string-downcase’ converts a string to lower case.  The
     ‘string-foldcase’ procedure converts the string to its case–folded
     counterpart, using the full case–folding mapping, but without the
     special mappings for Turkic languages.  The ‘string-titlecase’
     procedure converts the first cased character of each word, and
     downcases all other cased characters.

          (string-upcase "Hi")              ⇒ "HI"
          (string-downcase "Hi")            ⇒ "hi"
          (string-foldcase "Hi")            ⇒ "hi"

          (string-upcase "Straße")          ⇒ "STRASSE"
          (string-downcase "Straße")        ⇒ "straße"
          (string-foldcase "Straße")        ⇒ "strasse"
          (string-downcase "STRASSE")       ⇒ "strasse"

          (string-downcase "Σ")             ⇒ "σ"
          ; Chi Alpha Omicron Sigma:
          (string-upcase "ΧΑΟΣ")            ⇒ "ΧΑΟΣ"
          (string-downcase "ΧΑΟΣ")          ⇒ "χαος"
          (string-downcase "ΧΑΟΣΣ")         ⇒ "χαοσς"
          (string-downcase "ΧΑΟΣ Σ")        ⇒ "χαος σ"
          (string-foldcase "ΧΑΟΣΣ")         ⇒ "χαοσσ"
          (string-upcase "χαος")            ⇒ "ΧΑΟΣ"
          (string-upcase "χαοσ")            ⇒ "ΧΑΟΣ"

          (string-titlecase "kNock KNoCK")  ⇒ "Knock Knock"
          (string-titlecase "who's there?") ⇒ "Who's There?"
          (string-titlecase "r6rs")         ⇒ "R6rs"
          (string-titlecase "R6RS")         ⇒ "R6rs"

          _Note:_ The case mappings needed for implementing these
          procedures can be extracted from ‘UnicodeData.txt’,
          ‘SpecialCasing.txt’, ‘WordBreakProperty.txt’ (the “MidLetter”
          property partly defines case–ignorable characters), and
          ‘CaseFolding.txt’ from the Unicode Consortium.

          Since these procedures are locale–independent, they may not be
          appropriate for some locales.

          _Note:_ Word breaking, as needed for the correct casing of the
          upper case greek sigma and for ‘string-titlecase’, is
          specified in Unicode Standard Annex #29.

          _Kawa Note:_ The implementation of ‘string-titlecase’ does not
          correctly handle the case where an initial character needs to
          be converted to multiple characters, such as “LATIN SMALL
          LIGATURE FL” which should be converted to the two letters
          ‘"Fl"’.

 -- Procedure: string-normalize-nfd STRING
 -- Procedure: string-normalize-nfkd STRING
 -- Procedure: string-normalize-nfc STRING
 -- Procedure: string-normalize-nfkc STRING
     These procedures take a string argument and return a string result,
     which is the input string normalized to Unicode normalization form
     D, KD, C, or KC, respectively.  When the specified result is equal
     in the sense of ‘string=?’ to the argument, these procedures may
     return the argument instead of a newly allocated string.

          (string-normalize-nfd "\xE9;")          ⇒ "\x65;\x301;"
          (string-normalize-nfc "\xE9;")          ⇒ "\xE9;"
          (string-normalize-nfd "\x65;\x301;")    ⇒ "\x65;\x301;"
          (string-normalize-nfc "\x65;\x301;")    ⇒ "\xE9;"

12.3.4 String Cursor API
------------------------

Indexing into a string (using for example ‘string-ref’) is inefficient
because of the possible presence of surrogate pairs.  Hence given an
index I access normally requires linearly scanning the string until we
have seen I characters.

   The string-cursor API is defined in terms of abstract “cursor
values”, which point to a position in the string.  This avoids the
linear scan.

   The API is non-standard, but is based on that in Chibi Scheme.

 -- Type: string-cursor
     An abstract posistion (index) in a string.  Implemented as a
     primitive ‘int’ which counts the number of preceding code units
     (16-bit ‘char’ values).

 -- Procedure: string-cursor-start str
     Returns a cursor for the start of the string.  The result is always
     0, cast to a ‘string-cursor’.

 -- Procedure: string-cursor-end str
     Returns a cursor for the end of the string - one past the last
     valid character.  Implemented as ‘(as string-cursor (invoke STR
     'length))’.

 -- Procedure: string-cursor-ref str cursor
     Return the ‘character’ at the CURSOR.

 -- Procedure: string-cursor-next string cursor [count]
     Return the cursor position COUNT (default 1) character positions
     forwards beyond CURSOR.  For each COUNT this may add either 1 or 2
     (if pointing at a surrogate pair) to the CURSOR.

 -- Procedure: string-cursor-prev string cursor [count]
     Return the cursor position COUNT (default 1) character positions
     backwards before CURSOR.

 -- Procedure: substring-cursor string [start [end]]
     Create a substring of the section of STRING between the cursors
     START and END.

 -- Procedure: string-cursor<? cursor1 cursor2
 -- Procedure: string-cursor<=? cursor1 cursor2
 -- Procedure: string-cursor=? cursor1 cursor2
 -- Procedure: string-cursor>=? cursor1 cursor2
 -- Procedure: string-cursor>? cursor1 cursor2
     Is the position of CURSOR1 respectively before, before or same,
     same, after, or after or same, as CURSOR2.

     _Performance note:_ Implemented as the corresponding ‘int’
     comparison.

 -- Procedure: string-cursor-for-each proc string [start [end]]
     Apply the procedure PROC to each character position in STRING
     between the cursors START and END.

