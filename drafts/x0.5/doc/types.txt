Types in Bard

I. Concrete Types

-----
Atoms
-----

The simplest concrete datatpes in Bard are atoms. An atom is a basic
concrete value without internal structure, such as an integer or a
character. All of Bard's more complex types are built by assembling
atoms into structures.

Numbers

<bignum>
<complexnum>
<double-float>
<fixnum>
<ratio>
<single-float>

Booleans

<false>
<true>

Other atoms

<character>
<nothing>
<undefined>

----------
Structures
----------

Structures define values that consist of atoms and other structures
contained in named or indexed slots. 

The following kinds of structures are supported:

- Limited Atoms: instances are restricted instances of an atom type.
- Records: instances are sets of named slots.
- Tuples: instances are sequences of values, accessed by index.
- Enumerations: instances are values taken from an explicitly enumerated set.
- Unions: instances are instances of any of several explicitly-enumerated structures or atom types.

Limited Atoms
-------------

A limited atom is a structure whose values are instances of an atom
type, but restricted by a rule. Here's an example:

  (define <nat> (limited <fixnum> :minimum 1 :maximum nothing))

This expression defines <nat> as the fixnums greater than or equal to 1.

Here are a few more examples:

  (define <unsigned-byte> (limited <fixnum> :minimum 0 :maximum 255))
  (define <whitespace-character> (limited <character> :members [#\space #\tab #\newline #\return #\page]))
  (define <fraction> (limited <ratio> :minimum 1/10000 :maximum 9999/10000))


Records
-------

A record is a set of named slots. You can define default values for
slots, and restrictions may be placed on the types of values in the
slots.

When a record is defined, three kinds of functions are automatically
defined with it:

- Structure predicate

  A predicate that returns true if its argument is an instance of the
  structure and false otherwise. For example, if we define a structure
  <foo>, the predicate foo? is automatically defined. A parameter to
  the defining form enables you to control the name of the predicate.

- Accessors

  Functions that read and return the contents of slots, or assign new
  values to them. Accessors that read slots are called getters;
  accessors that write slots are called setters. Defining a record
  automatically defines getters, but not setters. If you want setters
  for record slots you must explicitly specify them in the record
  definition, which means that by default record instances are
  immutable.

  Again, if we define a record <foo> with slots named x and y, Bard
  automatically creates the readers named foo.x and foo.y.

- Constructors

  A constructor is a function that can be used to make instances of
  the record. When we define the record <foo>, Bard creates the
  function make-foo. If <foo> has slots x and y, Bard causes make-foo
  to accept the keyword parameters :x and :y to specify initial values
  for the slots. Once again, parameters to the defining form enable
  finer control over the initialization of record instances.

Tuples
------

A tuple is a structure that consists of a sequence of values. The
tuple definition determines the minimum and maximum number of values
that can be present, and the allowed types of the values. You can read
a value from a tuple instance by index.

For example:

  (define tuple <ostype> 
          :minimum-count 4 
          :maximum-count 4 
          :element-type <unsigned-byte> 
          :initial-element 0
          :setter ostype.set-element!)

As with a record definition, this tuple definition automatically
defines a set of functions:

- Structure predicate: ostype?

- Accessors ostype.element, ostype.set-element!

  The getter is defined automatically, but, as with records, we must
  explicitly specify the setter.

- Constructor: make-ostype & {initial-element 0}

Enumerations
------------

An enumeration is a structure whose instances are values explicitly
supplied in the definition. For example:

  (define enumeration <primary-color> [:Red :Green :Blue])

- Structure predicate: primary-color?

- Accessors

  It's not possible to read from or write to an instance of an
  enumeration. The value is an immutable interned object that behaves
  as it it were an instance of an atom type.

- Constructors: primary-color key & {:test =}

  An enumeration's constructor returns one of the member values of the
  enumeration. The constructor selects the value by comparing the key
  with the defined values using the supplied test function. It returns
  the matching value.

  For example:

  ? (primary-color :Red)
  :Red

  In this example, the key :Red is identical to the returned value,
  but that need not always be the case. For example, suppose we define
  <primary-color> using strings instead:

  (define enumeration <primary-color> ["Red" "Green" "Blue"])

  Now the constructor's result looks the same:

  ? (primary-color "Red")
  "Red"

  but there is an important difference: two strings that look the same
  are not necessarily the same object. "Red" is not necessarily the
  same value as (primary-color "Red"); the two strings could be
  distinct. Only the one returned from the constructor is guaranteed
  to be an instance of the enumeration.

  For this reason it's best to always use the constructor to obtain
  references to instances of an enumeration.

Unions
------

A union is a set of explicitly-mentioned structures or atoms. For
example:

  (define union <id> [<fixnum> <string>])

After this definition, any instance of <fixnum> or <string> will also
be considered an instance of <id>.

Bard will never return a union structure when asked for a value's
type. It will always return the base type of the value.

- Structure predicate: id?

Although (structure-of "Fred") returns <string>, not <id>, (id?
"Fred") returns true because <string> is one of the members of the
<id> union.

Defining a union does not define accessors or constructors. The
accessors and constructors defined for the base structures remain in
effect.

-------------------
Built-in Structures
-------------------

Bard provides a rich set of built-in structures:

Types
-----
<class>
<limited-atom>
<record>
<tuple>
<enumeration>
<union>
<singleton>

Procedures
----------
<function>
<getter>
<method>
<setter>

Ordered values
--------------
<duration>
<keyword>
<posix-pathname>
<symbol>
<symbolic-pathname>
<time>
<url>

Conditions
----------
<abort>
<error>
<restart>
<warning>

Collections
-----------
<array>
<bitvector>
<cons>
<generator>
<hash-table>
<module>
<read-table>
<string>
<vector>
<wb-map>
<wb-seq>

Streams
-------
<buffer-input>
<buffer-io>
<buffer-output>
<computed-input>
<computed-io>
<computed-output>
<file-input>
<file-io>
<file-output>
<message-input>
<message-io>
<message-output>
<standard-input>
<standard-io>
<standard-output>

II. Abstract Types

Bard's atoms and structures have no subtype or supertype
relationships. They are not abstract types; they are pure
representations. The only behavior defined on them is that necessary
for constructing and deconstructing them.

Bard builds abstract types from collections of functions called
protocols, and collections of types called classes.

-------
Classes
-------

A class is a named collection of types. That is, it's a collection of
atom types, structures, and perhaps other classes.

A Bard class, unlike a class in most languages, has no internal
structure. Classes don't have member functions; they don't have
instance variables. A class has its name, its superclass and subclass
relationships, and its member types; that's all.

Defining a class is simple: you just need to specify its name and the
names of any direct superclasses:

  (define class Point [])
  (define class Point2D [Point])
  (define class Point3D [Point])

We'll see in a moment how a class can gain member types.

---------
Protocols
---------

A protocol is a set of generic functions defined on some set of
classes. For example:

  (define protocol ~Ratio
    numerator (-> Ratio -> Integer)
    denominator (-> Ratio -> Integer))

Here we define a protocol called ~Ratio. It refers to two classes:
Ratio and Integer. It defines two generic functions: numerator and
denominator.

The protocol does not specify which structures or atoms may be
considered Ratios or Integers. It doesn't say anything about how to
execute the functions numerator and denominator; it just establishes
that the ~Ratio protocol exists, that it has the functions numerator
and denominator, and that the inputs and outputs of those functions
are of type Ratio and Integer.

------------------
Members of Classes
------------------

The most common way to establish that a structure or atom is a member
of a class is to define a method on a protocol function that mentions
the class.

For example, we can easily make <ratio> a member of the Ratio class:

  (define method (numerator r)
    with {r <ratio>}
    (ratio.num r))

That's all it takes. Since the ~Ratio protocol requires that the
argument to numerator is a Ratio, and since we've said in this method
definition that numerator accepts instances of <ratio>, this method
definition amounts to an assertion that <ratio> is a member of Ratio.

Bard will warn us that the ~Ratio protocol's implementation is
incomplete because we haven't defined a method for denominator, but
other than that, everything will work as expected.

We can of course add other types to Ratio:

  (define method (numerator r)
    with {r <fixnum>}
    r)

  (define method (numerator r)
    with {r <bignum>}
    r)

------------------------------
Built-in Classes and Protocols
------------------------------

Bard's standard library is in the form of a collection of standard
classes and protocols. The standard classes are arranged in a taxonomy
of subclass/superclass relationships. As an example, Integer is a
subclass of Rational, which is a subclass of Real, which is in turn a
subclass of Number.

Classes
-------

The standard classes are:

Anything
  Adjustable
  Boolean
    False
    True
  Collection
    Array
    List
      Vector
        Text
    Map
    Pair
    Stream
      BufferStream
      ComputeStream
      Consumer
      FileStream
      MessageStream
        Agent
          Bard
      NetworkStream
      Producer
        Generator
      StandardIOStream
  Condition
    Abort
    Error
    Restart
    Warning
  Limited
  Mutable
  Ordered
    Character
    Duration
    Name
      ResourceName
        Pathname
          PosixPathname
          SymbolicPathname
        URL
      Symbol
    Number
      Complex
      Real
        Float
        Rational
          Integer
          Ratio
    Time
  Procedure
    Accessor
      Getter
      Setter
    Function
    Method
  Type
    Class
    Protocol
    Singleton
    Structure

Protocols
---------

The standard protocols are:

~Abort
~Accessor
~Adjustable
~Agent
~Anything
~Bard
~Boolean
~BufferStream
~Character
~Class
~Collection
~Complex
~ComputeStream
~Condition
~Construction
~Consumer
~Conversion
~Copying
~Duration
~Error
~False
~FileStream
~Float
~Function
~Generator
~Getter
~Integer
~Limited
~List
~Map
~MessageStream
~Method
~Mutable
~Name
~NetworkStream
~Number
~Ordered
~Pair
~Pathname
~PosixPathname
~Procedure
~Producer
~Protocol
~Ratio
~Rational
~Real
~ResourceName
~Restart
~Setter
~Singleton
~StandardIOStream
~Stream
~Structure
~Symbol
~SymbolicPathname
~Text
~Time
~True
~Type
~URL
~Vector
~Warning



