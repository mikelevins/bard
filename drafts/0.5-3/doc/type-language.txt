The Bard 0.5 Type Language

Used in defining new types.

Base types

All data in Bard are represented as instances of a small number of
base types. The base types are:

- bits - an immediate machine integer
- procedure - an applicable object
- list - a sequence of values
- record - a mapping from keys to values
- values - a tuple of values

These base types are built into Bard. All other types are
constructed by combining and restricting these types.

A type is its own constructor. You can create instances of the
type by aplying it to parameters that are used to initialize the
instance.

Here are a few examples:

    bard> (bits 1 1 0 1 1)
    #bits 11011

    bard> (procedure (x) (* x x))
    #procedure (^ (x) (* x x))

    bard> (list 1 2 3)
    #list (1 2 3)

    bard> (record 'x {} 'y {})
    #record {x {} y {}}

    bard> (values 1 2 3)
    1 
    2 
    3

You can create a restricted version of a base type by passing it to
the function `the` with some arguments. For example:

    bard> (the bits 0 255)
    #type (bits 0 255)

    bard> (the list character 0 undefined)
    #type (list character 0 undefined)

The first type in the example is a bits type that represents values in
the range 0-255; the second is a list type that can only contain
elements of type character and that can hold a number of elements from
0 to infinity.

Deriving types

New types are constructed by restricting and combining the base
dataypes.

Here's a simple example:

    bard> (define type unsigned-byte (the bits 0 255))
    unsigned-byte

    bard> (unsigned-byte 128)
    #unsigned-byte 128

    bard> (unsigned-byte 1024)
    ERROR 1024 is an invalid initialization value for type unsigned-byte

Here's a slightly more complicated example: a list of characters
restricted to have length 4:

    bard> (define type ostype (the list character 4 4))
    ostype

The function `the` derives a new type from an existing one, given some
rules about the new type that are passed as arguments after the type.

'the' is polymorphic: the method it uses to construct the new type can
be specialized for particular types and particular arguments to
`the`. The chosen method is called a deriver.

The deriver for list takes a type argument that determines what types
of elements the list can contain, followed by a minimum-count
argument and a maximum-count argument. The minimum-count can be any
non-negative integer, or a false value, in which case zero is
assumed. The maximum-count can be any non-negative integer (as long as
it's equal to or greater than the minimum-count), or undefined, in
which case the type can hold any number of elements.

The type argument can be Anything, in which case the derived type can
contain elements of any type. It can be any defined type, in which
case the derived type can only hold values of that type.

Composite types

The type language enables you to describe types that are combinations
of other types and values.

`singleton` creates a type that has exactly one instance: the value
passed as an argument to the `singleton` constructor:

    bard> (singleton 5)
    #singleton 5

If two values are identical then `singleton` will always yield
identical singleton objects for them.

`synonym` creates a type that is simply a name for another defined
type:

    bard> (synonym dollars single-float)
    #synonym dollars

`enumeration` creates a type whose members are exactly the values
passed to the `enumeration` constructor:

    bard> (enumeration 1 "Hello" nothing)
    #enumeration (1 "Hello" nothing)

It's possible for two different strings to look the same, so there's
no guarantee that when you type in "Hello", the resulting value is a
member of the above enumeration. You can avoid that problems that
loophole might cause by using the `get` function to obtain
instances of an enumeration:

    bard> (define type things (enumeration 1 "Hello" nothing))
    things

    bard> (identical? (get things "Hello")(get things "Hello"))
    true

`union` creates a type whose members are instances of any of several
other named types:

    bard> (define type id (union integer string))
    id

    bard> (instance? 1 id)
    true

    bard> (instance? "Fred" id)
    true

    bard> (instance? :some-keyword id)
    false

Constructor and deriver methods

A type is also a constructor function. That function is polymorphic;
you can write methods that customize how instances of the type are
constructed.

    bard> (define type person (the record 'name {:type string :default nothing} 'status {:type symbol :default nothing}))
    person

    bard> (define method (person &key (:name nothing)(:income nothing))
            (when (not name)
              (signal "ERROR: tried to create a person without a name"))
            (when (not income)
              (signal "ERROR: tried to create a person without an income"))
            (next-method :name name 
                         :status (if (> income 1000000)
                                   'rich
                                   'poor)))
    person

    bard> (person :name "Fred" :income 2000000)
    #person {name "Fred" status rich}

    bard> (person :name "Barney" :income 20000)
    #person {name "Barney" status poor}

The same kind of control is available for derivers, the type-deriving
methods on the function `the`. You can specialize a deriver by
defining a method on the singleton type. For example, if we wanted to
write a customized deriver for person, we would start like this:

    bard> (define method (the (p (singleton person)) &key ...)
            ...)

The method defined on the type (singleton person) will be applied when
someone uses `the` like this:

    bard> (the person ...)

