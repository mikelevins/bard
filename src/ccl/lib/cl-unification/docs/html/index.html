<html>
 <head>
     <title>CL Unification</title>
     <link rel="stylesheet" href="main.css">
 </head>
	
 <body marginheight="0" marginwidth="0" leftmargin="0" topmargin="0" bgcolor="#ffffff">

 <table border="0" cellpadding="0" cellspacing="0" width="100%" height="100%" vspace="0" hspace="0">
  <tr>
  <td colspan="3">
   <div class="header"
        style="font-family:=Verdana,Arial,Helvetica; font-size: 18px; color: #41286f;">
    <strong><i>CL Extensions: UNIFICATION</i><string>
    <div class="navigation">
     <a href="index.html" class="navigation-link-selected">Home</a>
      | <a href="downloads.html" class="navigation-link">Downloads</a>
      | <a href="mailing-lists.html" class="navigation-link">Mailing Lists</a>
      | <a href="links.html" class="navigation-link">Links</a>
    </div>
   </div>
   <div class="black-line"><img src="images/shim.gif" height="1" width="1"></div>
   <div class="middle-bar"><img src="images/shim.gif" height="5" width="1"></div>
   <div class="black-line"><img src="images/shim.gif" height="1" width="1"></div>
  </td>
 </tr>

 <tr height="100%">
  <td height="100%">&nbsp;<div class="sidebar"></div></td>
  <td valign="top" width="80%" height="100%">

  <div class="content">
  <div class="text" style="padding-top: 10px;">

  <h1>Common Lisp Extensions: UNIFICATION</h1>

  <p>The notion of <em>unification</em> originated in the field of
  formal logic (e.g. <a href="#R65">[R65]</a>,) and has been used
  extensively in Computer Science and Programming Languages.  Most
  notably, <strong>Prolog</strong> uses the full power of
  unification.</p>

  <p>
  Unification is also at the core of <em>type checking</em> algorithms
  in the tradition of Milner's, and a limited form - <em>pattern
  matching</em> - is available to the user in languages of the ML and
  Haskell family.</p>

  <p>The library presented in these pages provides a full blown
  <em>unification framework</em> for <strong>Common Lisp</strong>.</p>

  <p>Writing a pattern matcher or a an unifier in <strong>Common
  Lisp</strong> is easy, as long as we limit ourselves to manipulate
  only ATOMs and CONSes.</p>

  <p>Alas, it would be much nicer if we could manipulate arbitrary
  <strong>Common Lisp</strong> objects as the ML programmer can with
  arbitrary ML objects.<p>

  <p>The library presented here is the first one (to the best of the
  author's knowledge) that is capable of manipulating arbitrary
  <strong>Common Lisp</strong> objects.</p>

  <p>The hope is that this library could be incorporated directly in
  an implementation in order to provide better type checking.</p>

  <p>This should not come as a surprise, as a compiler like CMUCL does
  include a type inference engine, which does very similar things.</p>

  <h2>Unification Basics</h2>
  
  <p>The unification process makes sure that two <em>object
  descriptions</em> containing some <em>holes</em>
  - i.e. <em>variables</em> - can be made equal (almost in the EQUALP
  sense) by assigning <em>consistent</em> values to the variables
  involved.</p>

  <p>Suppose we had a function U performing unification and returning
  a set of <em>variable assignments</em>, often called a
  <em>substitution</em>. A very simple 
  example involving the unification of two numbers could be
  <pre>
  <b>U</b>(42, 42) ==> {}
  </pre>
  The two numbers are EQL, so no variable is involved and the empty
  substitution is returned.
  <pre>
  <b>U</b>(42, 123) ==> &lt;unification failure&gt;
  </pre>
  The two numbers are not EQL, so the unification fails.
  <pre>
  <b>U</b>(42, x) ==> {x -> 42}
  </pre>
  The only way to make the unification process to succeed is to bind
  the value 42 to the variable <code>x</code>.</p>

  <p>The UNIFICATION library defines all the necessary functions and a
  <em>unification sub-language</em> to handle most of <strong>Common
  Lisp</strong>.</p>

  <h2>UNIFICATION Library</h2>

  <p>The UNIFICATION library has one main entry point, the generic function
  UNIFY, and a sub-language definition that allows us to talk about
  <strong>Common Lisp</strong> objects.</p>

  <p>The UNIFY generic function has the following signature:
  <pre>
  <b>unify</b> <i>x</i> <i>y</i> &amp;optional <i>substitution</i>
  </pre>
  Where <code><i>x</i></code> and <code><i>y</i></code> are either
  arbitrary <strong>Common Lisp</strong> objects, <em>variables</em>,
  or <em>object templates</em>.  These items constitute the so-called
  <em>extended terms</em> manipulated by the unification
  machinery.</p>

  <p><em>Variables</em> are symbols with a <code>#\?</code> as the
  first character of the name.  This is a rather traditional choice,
  although a different one based on quoted symbols is possible.
  Therefore, the following are examples of variables.
  <pre>
  ?A ?s ?qwe ?42z ?a-variable-with-a-very-long-name ?_
  </pre>
  There are two special variables, <code>?_</code> and <code>_</code>,
  which are used as anonymous place holders, they match anything, but
  never appear in a substitution.</p>

  <p>Hence, the above examples result in the following
  <pre>
  cl-prompt&gt; (<b>unify</b> 42 42)
  <i>#&lt;EMPTY ENVIRONMENT xxxxxx&gt;</i>
  </pre>

  <pre>
  cl-prompt&gt; (<b>unify</b> 42 123)
  ==> error: unification failure
  </pre>

  <pre>
  cl-prompt&gt; (<b>unify</b> 42 ?x)
  <i>#&lt;ENVIRONMENT xxxxxx&gt;</i>

  cl-prompt&gt; (<b>find-variable-value</b> '?x *)
  <i>42</i>
  </pre>
  </p>
  Where FIND-VARIABLE-VALUE is the accessor used to find the value of
  a variable in a substitution.</p>

  <p>As a more complicated example, consider the usual CONS based
  unification
  <pre>
  cl-prompt&gt; (<b>unify</b> '(foo (bar frobboz) ?baz) '(foo ?gnao 42))
  <i>#&lt;ENVIRONMENT xxxxxx&gt;</i>

  cl-prompt&gt; (<b>find-variable-value</b> '?gnao *)
  <i>(BAR FROBBOZ)</i>

  cl-prompt&gt; (<b>find-variable-value</b> '?baz **)
  <i>42</i>
  </pre>

  <p>Of course note the following behavior
  <pre>
  cl-prompt&gt; (<b>unify</b> '(foo ?x 42) '(foo 42 ?x))
  <i>#&lt;ENVIRONMENT xxxxxx&gt;</i>

  cl-prompt&gt; (<b>unify</b> '(foo ?x 42) '(foo baz ?x))
  ==> error: unification failure
  </pre>
  </p>
  

  <p>UNIFY works also on arrays and vectors. Strings are treated as
  atomic objects
  <pre>
  cl-prompt&gt; (<b>unify</b> #(1 2 3) #(1 ?x ?y))
  <i>#&lt;ENVIRONMENT xxxxxx&gt;</i>

  cl-prompt&gt; (<b>find-variable-value</b> '?x *)
  <i>2</i>
  </pre>

  <pre>
  cl-prompt&gt; (<b>unify</b> #2A((1 2 3) (a s ?z)) #2A((1 ?x ?y) (a s d)))
  <i>#&lt;ENVIRONMENT xxxxxx&gt;</i>

  cl-prompt&gt; (<b>find-variable-value</b> '?z *)
  <i>D</i>
  </pre>
  </p>

  <p>So far so good, but how can you unify two structures?  First of
  all there is no portable way (yet) to list all the slots of a given
  structure.  Secondly, by allowing the unification of arbitrary
  CONSes, we have created a short-circuit in the unification
  machinery.</p>

  <p>Dealing with object instances raises similar problems.</p>

  <p>Suppose we have the following definition
  <pre>
  (defstruct foo a s d)
  </pre>
  The straightforward
  <pre>
  (<b>unify</b> #S(FOO A 42 S NIL D NIL) (make-foo :a 42))
  </pre>
  cannot be built portably, besides, we do not even have the equivalent of the
  <code>#S(...)</code> notation for regular CLOS objects. Moreover we want
  to do other things with other data types.</p>

  <p>A simple solution is to define a <em>template sub-language</em>
  to express unifications between structure objects or standard
  objects (and other data types as well.)  Nevertheless, the
  definition of such sub-language cannot be CONS based, because in
  such case, we would conflate arbitrary CONSes and the expressions of
  the sub-language.</p>

  <p>To circumvent this problem we resort to the usual trick a ML
  programmer uses to placate the type-checker: we introduce an
  "intermediate" data type.  Essentially the following
  <pre>
  (defclass <b>template</b> ()
     ((spec :accessor template-spec :type (or cons symbol number) ...)))
  </pre>
  </p>

  <p>The TEMPLATE class is accompanied by a reader macro
  (<code>#T</code> for <em>template</em>, or <em>type</em>, with an
  abuse of language) and an
  appropriate PRINT-OBJECT method. The <code>#T</code> reader macro
  expands as
  <pre>
  <b>#T</b><i>something</i> ==> (make-instance 'template :spec <i>something</i>)
  </pre>
  With this infrastructure we can
  express the unification of the FOO instance as
  <pre>
  (<b>unify</b> #S(FOO A 42 S NIL D NIL) <b>#T(foo foo-a 42)</b>)
  </pre>
  I.e. we use the actual structure accessor FOO-A to get to the the
  value of the slot A in a FOO.  This is an example of the template
  language.</p>

  <p>A more interesting example, which involves vectors is the
  following
  <pre>
  cl-prompt> (<b>unify</b> #(1 2 3 4 5) <b>#T(vector 1 ?x &amp;rest ?rest)</b>) ; You get the idea...
  <i>#&lt;ENVIRONMENT xxxxxxx&gt;</i>

  cl-prompt> (<b>find-variable-value</b> '?rest *)
  <i>#(3 4 5)</i>
  </pre>
  I.e. we have a DESTRUCTURING-BIND on steroids.<p>

  <p>Note that separating the templates is necessary if we want to do
  something like
  <pre>
  cl-prompt> (<b>unify</b> '(1 2 3 4 5) <b>#T(list 1 ?x &amp;rest ?rest)</b>)
  <i>#&lt;ENVIRONMENT xxxxxxx&gt;</i>

  cl-prompt> (<b>find-variable-value</b> '?rest *)
  <i>(3 4 5)</i>
  </pre>
  Without the template denoted by <code>#T(list ...)</code> the
  unifier would have been utterly confused.</p>

  <p>In the following the full extent of the UNIFICATION facility is
  described in its main components.
  </p>


  <h2><a href="unifying-substitutions.html">Unifying Substitutions</a></h2>

  <h2><a href="templates.html">The Template Sub-language</a></h2>

  <h2><a href="control-flow.html">Control Flow</a></h2>

  <h2><a href="unification-dictionary.html">The UNIFICATION
  Dictionary</a></h2>

  <h2>References</h2>

  <p>
  <a name="R65">[R56]</a> J. A. Robinson, <i>A machine-oriented logic based on the
  resolution principle</i>, Journal of the ACM, Vol. 12, No. 1,
  January 1965, Pages 23--49.</p>


  <h1></h1>
  <hr>
  <em>
  <p>
  <b>DISCLAIMER:</b> The code associated to these documents is not
  completely tested and it is bound to contain errors and omissions.
  This documentation may contain errors and omissions as well.</p>

  <p>The file <tt>COPYING</tt> contains a Berkeley-style license. You
  are advised to use the code at your own risk.  No warranty
  whatsoever is provided, the author will not be held responsible for
  any effect generated by your use of the library, and you can put
  here the scarier extra disclaimer you can think of.
  </p>
  </em>
  <hr>

  

<!--
;;; Copyright (c) 2004 Marco Antoniotti, All rigths reserved.
;;;
;;; Permission to use, modify, and redistribute this code is hereby
;;; granted.
;;; The code is provided AS IS with NO warranty whatsoever. The author
;;; will not be held liable etc etc etc etc etc.
-->

  <h2>Site Map</h2>


  <p>Enjoy!</p>



  <hr>
  <p>Questions? Queries? Suggestions? Comments? Please direct them
  at <a href="mailto:marcoxa_PROVA_A_SPAMMARME@alu.org">me</a>.
  </p>

  </div>
  </div>
						
 </td>
 
 <!--  <td height="100%">&nbsp;</td> -->
 </tr>

 <tr height="100%">
  <td height="100%">&nbsp;</td>
  <td valign="top" width="80%" height="100%">

  <div class="content">
  <div class="text" style="padding-top: 10px;">

  <h1>News</h1>

  <p>News in chronological order, most recent on top.
  </p>

  <ul>
  <li><strong>2007-11-09</strong><br>
      Updated.
  <li><strong>2004-11-04</strong><br>
      Updated.
  <li><strong>2004-05-05</strong><br>
      Started the site.
  </li>
  </ul>

  </div>
  </div>
						
 </td>
 
 <td height="100%">&nbsp;</td>
 </tr>



 
 <tr>
  <td colspan="3" valign="bottom" align="right">
  <div class="copyright">
  &copy; 2004-2007, Marco Antoniotti, all rights reserved.
  </div>
  </td>
 </tr>
 
 </table>
 </body>
</html>
